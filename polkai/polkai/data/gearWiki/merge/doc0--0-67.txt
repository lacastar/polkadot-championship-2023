




Welcome! | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable 🚧StableEnglishEnglish简体中文SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksWelcome!On this pageWelcome!Welcome to Gear’s documentation portal. This is the central source of information for everyone who is looking for general information about Gear. Here you will find guides and developer's documentation that will enable you to dive deeper into developing smart contracts on the Gear Protocol.
Our Wiki outlines foundational information required, general technology overviews and key advantages of Gear’s technology, including how to implement and run your smart contracts and how to get started with the Gear node setup, while also providing full API details and examples.
All code, libraries, and tools are available on GitHub. Feel free to use the tools and libraries, log issues as you find them, or create pull requests for your bug-bears or features.
As our project is developing and growing, contributions are more than welcome!
What is the Gear Protocol?​
The Gear Protocol is a Substrate-based smart-contract platform that enables anyone to develop and run a dApp in a matter of minutes. The Gear Protocol is the most developer-friendly way to implement smart contracts with arbitrary logic and of any complexity. Gear smart-contracts run as WebAssembly programs so they can be compiled from many popular programming languages, such as Rust, C, C++ and many more.
The protocol ensures very minimal, intuitive and sufficient APIs for implementing programs and running them on multiple networks without having to rewrite them. From a technological point of view, the Gear Protocol is distinguished by fundamentally new features that enable you to create asynchronous programs with a completely new and previously unattainable user experience, namely - the Actor model for communication, the persistent memory concept and WebAssembly execution environment. The protocol dictates what actors should look like as communicating entities.
The Gear Protocol will assist with the transition to mass use of Web3 technologies by enabling the running of innovative dApps, microservices, middleware and open APIs.
What is the Gear Network?​
The Gear Protocol provides the most cost-effective way to run smart contracts. Powered by the Gear Protocol, Gear Networks can act as standalone L1 networks, as well as become a parachain in the Polkadot and Kusama ecosystem too. By deploying on Gear Protocol, developers can fully leverage the benefits offered by Gear.
Vara Network is the first stand-alone layer-1 decentralized network built and running on top of Gear Protocol.
How to engage with the Gear community​
GitHub​
Instructions and other development-focused conversations are found on our GitHub.
Discord​
General information and non-technical conversation are found on our Discord server.
Twitter​
Follow us on Twitter for regular updates: @gear_techs
Telegram​
Join Gear's official Telegram channel: @gear_tech
Medium​
Get smart with our regular articles on Medium.Edit this pageNextWhy do we build Gear?What is the Gear Protocol?What is the Gear Network?How to engage with the Gear communityGitHubDiscordTwitterTelegramMedium








Welcome! | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeUnstable 🚧Unstable 🚧StableEnglishEnglish简体中文SearchWelcome!This is unreleased documentation for Gear Documentation Portal Unstable 🚧 version.For up-to-date documentation, see the latest version (Stable).Welcome!Version: Unstable 🚧Welcome!Welcome to Gear’s documentation portal.
warningThis is the documentation for the next version of Gear. The current version is here.Edit this page








什么是 Web3? | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())跳到主要内容Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContribute下一页Unstable 🚧下一页简体中文English简体中文搜索欢迎Intro to Gear Protocol5 分钟快速入门Gear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsWeb3dApp智能合约DeFiNFTDAOGear-based NetworksGeneral topicsWeb3什么是 Web3?
Web 3.0 是互联网的全新迭代，由人工智能、机器学习和最重要的区块链技术等新技术驱动。
Web3.0 的目的是创造一个更加开放、连接和智能的互联网，对任何人而言都无需许可，并且不将个人数据货币化。
通过 Web3，任何在网络上的人都有权限使用所有 Web3 的服务。没有一个中央机构可以阻止或拒绝访问。因为 Web3 是完全去中心化的，没有一个实体拥有或控制网络。相反，社区是控制网络的人。由于为 Web3 提供动力的基础设施是图灵完备的，几乎任何可以想象到的东西都可以被编程为一个去中心化的应用程序。
除此之外，由于区块链技术的独特性质，在 Web3 上发生的大多数互动和交易将在安全、速度和成本方面受益。
价值主张很简单。Web3 的主要优势在于，它解决了 Web2 带来的最大问题--个人数据的收集和货币化。
Web3 赋予用户权力，创造了一个更高效、安全和透明  的互联网。编辑此页上一页React-hooks下一页dApp








关于 Vara 网络 | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())跳到主要内容Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContribute下一页Unstable 🚧下一页简体中文English简体中文搜索欢迎Intro to Gear Protocol5 分钟快速入门Gear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksVara 网络Gear-based NetworksVara 网络关于 Vara 网络Vara Network 是第一个在 Gear 协议之上构建和运行的独立的第 1 层去中心化网络。
快速和可扩展的非分叉升级的 Vara 网络为下一代游戏、基于金融的应用、实验性功能提供了最佳场所。不仅如此，任何其他现代用例都非常适合在 Vara 上运行。在 Vara 网络上构建生态，对于已经在 Web3 中的开发者和那些从 Web2 迁移过来的开发者来说，都是理想的选择，他们可以在最安全、高效、可扩展的环境中部署他们的去中心化应用程序。
许多下一代应用，如游戏和支付，需要低延迟执行。Vara 独立网络为这些应用程序提供了最快的入口，并释放了新的潜在应用。
Vara 网络的主要特点：

有史以来最快的真正去中心化的 L1
新功能和优化的测试台
由于 Substrate，网络稳定且可升级
非常少的治理

除了开发和运行 dApps 之外，还有几种方法可以支持 Vara Network：

为程序执行、出块和参与共识机制提供计算资源，成为验证节点。这会使 Vara 网络更安全、高效且抗审查
通过质押代币和提名验证者成为提名人
成为大使，围绕 Vara Network 和 Gear Protocol 建立教育意识、社区参与和去中心化。

有关 Vara Network 的更多信息以及如何参与社区，请访问 Vara Wiki.编辑此页上一页DAO








Gear Distinctive Features | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable 🚧StableEnglishEnglish简体中文SearchWelcome!Intro to Gear ProtocolWhy do we build Gear?Gear Distinctive FeaturesGear Protocol TechnologyGlossaryGetting StartedGear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksIntro to Gear ProtocolGear Distinctive FeaturesOn this pageGear Distinctive Features
Truly decentralized​
One of the well-known drawbacks of other platforms' smart contracts is that they cannot trigger their own functions. Instead, to run certain functions they require an external component or service to trigger on-chain transactions.
While some smart contract logic may rely on users to initiate transactions and awaken the contract, many cases require a trigger when certain conditions are met, such as reaching a specific point in time or the occurrence of a particular event. In the past, this has either limited the capabilities of smart contracts or required developers to introduce a centralized service to trigger smart contracts.
Now thanks to Gear Protocol's support for asynchronous messaging, contract developers can implement arbitrary contract logic with delayed messages that can wake the contract after a specified period of time or in response to certain events. This enables a much more extensive range of use cases for smart contracts, unlocks new decentralized functionality, and unlocks more value for users in the blockchain ecosystem.
Continuing messaging automation​
The execution of any messages in Gear, including the system messages, consumes "gas". The Gear Protocol introduces the concept of gas reservation, which allows for the creation of gas pools that can be used by programs for further execution. Each pool is unique to the program that creates it, and the gas from the pool can be consumed by the program if its "gas_available" is not sufficient.
One of the key benefits of the gas reservation is the ability to send delayed messages that can be triggered automatically at a specific time in the future. These messages, like any other message in Gear, can invoke another smart contract in the network or appear in the user's mailbox.
Perhaps most interestingly, gas reservation allows a program to send a message to itself at a later time, allowing it to continue execution after a defined period. This effectively enables a smart contract to execute itself an unlimited number of times (provided that enough gas is available for the execution).
This opens up a wide range of possibilities for the implementation of functional logic related to continuing messaging automation in smart contracts. Delayed messages are similar to cron jobs, which cannot be implemented in smart contracts on other blockchain platforms without the use of external resources. The remarkable advantage of this solution is that it eliminates the need for centralized components in dApps, ensuring they function completely on-chain and are fully decentralized and autonomous.
Applications that use delayed messages in their business logic and their source code are shown in the Smart Contract Examples section. These include applications such as: Tamagotchi battle, VaraTube, Dynamic NFT.
Payless Transactions​
Gear Protocol's Payless Transactions feature introduces a groundbreaking concept to the world of Web3, revolutionizing communication within Gear-powered networks and increasing the adoption of decentralized applications, making their ease of use closer to Web2 services and applications.
This innovative feature empowers actors to issue vouchers that enable specific users to send messages to designated programs without incurring gas fees. This paradigm-shifting approach fosters a sponsorship-like environment for users, transforming the way interactions take place in the Web3 ecosystem. An example of using vouchers is shown in the Battleship game. Users without tokens on their balance can make moves by sending messages to a program using a voucher.
Understanding Payless Transactions​
At the core of the Payless Transactions feature lies the concept of vouchers. These vouchers are crafted to grant users the ability to send messages to specific programs within the network, all without the burden of gas fees. Each voucher comes with a predetermined allocation of gas, empowering users to initiate interactions without worrying about transaction costs.
How Payless Transactions Work​


Voucher Issuance: Actors within the Vara Network can issue vouchers, creating a sponsorship mechanism for users. These vouchers are tied to specific programs and include a designated gas allocation.


Message Sending: Holders of valid vouchers can use them to send messages to the designated program. These messages can include instructions or data, enriching interactions within the network.


Gas-Free Interactions: Users who has valid vouchers can enjoy gas-free interactions when sending messages. The allocated gas from the voucher covers the associated transaction costs.


Benefits of Payless Transactions​

Encourages user participation by eliminating the gas fee barrier
Reduced сomplexity for dApps adoption
Fostering a more inclusive and vibrant network
More accessible and user-friendly (Web2-like approach)

How does it work?​
Learn how to create and use vouchers in this article.
Use cases​
For instance, let's consider some use case examples that become achievable:
NFTs​
Non-Fungible Tokens (NFTs) are unique digital assets that can be owned and traded on blockchain networks. One of the key features of NFTs is that they can be dynamic, meaning that their properties can be changed based on certain conditions. Dynamic NFTs can be updated immediately by their owner or gradually using delayed messages.
This can be useful in a variety of situations, such as updating an NFT based on changes in its price, as is done in the Curse NFT using Oracles, or in gaming applications where the properties of an NFT might change over time.
There are scenarios in which NFTs are updated:

The user can send a message to update the NFT immediately
The NFT contract can send a message to itself at regular intervals to update the token's properties
The NFT contract can send a delayed message to another actor (such as a program or account) and change the NFT's properties based on the result of processing that message.

Overall, the ability to update NFTs dynamically opens up a wide range of possibilities for their use in a variety of applications.
Gaming​
Everyone knows that the most successful games are those that are exciting, that you play with pleasure.
The success of such games depends on the right game mechanics established by the developers. The Gear Protocol offers a tool for developing such games and running them on a decentralized network, like Vara. Features such as delayed messages, payless transactions, and gas reservation become essential tools for developers aiming to create successful games on the Gear decentralized network.
Here are a few of the many examples where such functionality would be useful:
Tamagotchi is a classic digital pet game where players must care for a virtual creature by providing it food, attention, and other forms of care. As a dynamic NFT, a Tamagotchi can change its appearance based on its properties (such as hunger, fatigue, or happiness) and can notify the user when it needs to be fed or played with. The user can feed the NFT with gas, which is used to send delayed messages that are required to update the Tamagotchi's state.
"Game strategies battle" is a game in which several programs compete with each other using different algorithms or strategies. The game can be based on a variety of classic games, such as checkers, tic-tac-toe, races, or Monopoly. Each participant creates a smart contract with their own game strategy and uploads it to the blockchain. The programs then play against each other until someone wins or the gas runs out. If the gas runs out, one of the participants can continue the game by sending a message with more gas. This allows the game to continue indefinitely, with the most effective strategy ultimately emerging as the winner.
DeFi​
Decentralized finance (DeFi) applications can improve the user experience by implementing delayed messages. For example, when users deposit tokens into a liquidity pool on an automated market maker (AMM) or participate in staking to earn rewards, they often have to manually claim their earnings (known as "harvesting yield").
With the Gear Protocol, users can enjoy a set-and-forget DeFi experience where their earnings are automatically deposited into their accounts without any manual intervention. Rewards are regularly harvested, swapped for the original vault asset, and deposited again for compound farming, allowing users to earn even more without having to take any additional action.
In general, the use of delayed messages in DeFi can greatly improve the user experience by making it easier for users to earn rewards and take advantage of the benefits of DeFi without constantly having to monitor and manage their assets. This can help drive broader adoption of DeFi and unlock new opportunities for growth in the industry.Edit this pagePreviousWhy do we build Gear?NextSubstrateTruly decentralizedContinuing messaging automationPayless TransactionsUnderstanding Payless TransactionsHow Payless Transactions WorkBenefits of Payless TransactionsHow does it work?Use casesNFTsGamingDeFi








Сonfiguring a node as a Linux service | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable 🚧StableEnglishEnglish简体中文SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeSetting UpNode as a ServiceNode MonitoringBackup and RestoreDev Net ModeMulti-Node ModeNode FAQTroubleshootingDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksGear NodeNode as a ServiceOn this pageСonfiguring a node as a Linux service
Prerequisites​
You need to download or compile the gear executable file for your OS. See more
Configuration​
Copy the gear executable to the /usr/bin directory:
sudo cp gear /usr/bin
To run the Gear node as one of the Linux services, you need to configure the systemd file:
cd /etc/systemd/systemsudo nano gear-node.service
Configure and save:
[Unit]Description=Gear NodeAfter=network.target[Service]Type=simpleUser=rootWorkingDirectory=/root/ExecStart=/usr/bin/gear --name "NODE_NAME" --telemetry-url "wss://telemetry.rs/submit 0"Restart=alwaysRestartSec=3LimitNOFILE=10000[Install]WantedBy=multi-user.target
noteDeclaration ExecStart points to the location of the gear binary file. In this case, it is in /usr/bin directory.
With -- additional launch parameters are indicated, but not mandatory.
That’s it. We can now start the service.
Starting the node​
Run to start the service:
sudo systemctl start gear-node
Automatically get it to start on boot:
sudo systemctl enable gear-node
How to check status of gear-node service?
sudo systemctl status gear-node
Checking logs​
You may see the service logs by running the following command:
journalctl -u gear-node
Use navigation keys to browse the logs and q key to exit.
You may see the last 50 lines of logs by adding -n 50 parameter:
journalctl -u gear-node -n 50
Add -f parameter to see the last lines of logs in continuous mode (press Ctrl+C to exit):
journalctl -u gear-node -fn 50
Update the node with the new version​
After the node has been running for a while, you may need to update it to the latest version.
You just need to replace the node executable (gear) with the latest version and restart the execution. For example, if your Linux executable is located at /usr/bin/gear (as we've configured above) you are to run:
curl https://get.gear.rs/gear-nightly-x86_64-unknown-linux-gnu.tar.xz | sudo tar -xJC /usr/binsudo systemctl restart gear-node
Remove the node​
If you no longer need to run the node, you can completely purge it from the disk.
warningNote that once you delete the node, you will not be able to fully restore it. Refer to the Backup and Restore article to know about the important data to be backed up.
You are to remove the node's storage, the service configuration, and the executable itself:
sudo systemctl stop gear-nodesudo systemctl disable gear-nodesudo rm -rf /root/.local/share/gearsudo rm /etc/systemd/system/gear-node.servicesudo rm /usr/bin/gearEdit this pagePreviousSetting UpNextNode MonitoringPrerequisitesConfigurationStarting the nodeChecking logsUpdate the node with the new versionRemove the node








Backup and restore the node | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable 🚧StableEnglishEnglish简体中文SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeSetting UpNode as a ServiceNode MonitoringBackup and RestoreDev Net ModeMulti-Node ModeNode FAQTroubleshootingDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksGear NodeBackup and RestoreOn this pageBackup and restore the node
Data structure​
Gear node stores its data in a dedicated directory.

Linux: $HOME/.local/share/gear
macOS: $HOME/Library/Application Support/gear
Windows: %USERPROFILE%\AppData\Local\gear.exe

For example if you run the node as the root user on Linux ($HOME = /root) the absolute path of node's data directory will be:
/root/.local/share/gear
Let's explore the data that the node stores in this directory.
└── gear    └── chains        ├── dev        │   └── ...        ├── gear_staging_testnet_v7        │   ├── db        │   │   └── full        │   ├── keystore        │   └── network        └── vara_network            ├── db            │   └── full            ├── keystore            └── network
Chains​
The node can connect to different chains. The chain can be selected using the --chain argument. The default chain is the staging test network at the moment. Its data is located in gear/chains/gear_staging_testnet_v7 directory.
If you connect to the Vara network, the chain subdirectory name will be vara_network resulting in the gear/chains/vara_network path.
If you start the node with the --dev argument, the virtual network in development mode will run with the data stored in the gear/chains/dev directory.
Database​
The database keeps the blockchain state in the local node storage. It synchronizes with other nodes over a peer-to-peer protocol. One can choose the DB format using the --database argument. Possible options are:

rocksdb (default): use RocksDB as database engine, data is stored in <chain>/db/full subdirectory.
paritydb: use ParityDB as database engine, data is stored in <chain>/paritydb/full subdirectory.
paritydb-experimental: deprecated experimental mode of the ParityDB engine (will be removed in future releases), data is stored in <chain>/paritydb/full subdirectory.

Note that the database contents depends on the pruning mode of the node. By default the node keeps only the last 256 blocks. To keep all the blocks use the --pruning=archive argument when running the node.
The database can be deleted and synchronized from scratch at any time. Use the gear purge-chain command to completely delete the DB.
Network key​
The network private key is used to calculate the unique peer identifier (started with 12D3KooW). This key is stored in <chain>/network/secret_ed25519 file. The key file is the binary file containing 32 bytes of the Ed25519 (by default) private key. You can use hexdump command to read the key:
hexdump -e '1/1 "%02x"' /root/.local/share/gear/chains/gear_staging_testnet_v7/network/secret_ed25519# 42bb2fdd46edfa4f41a5f0f9c1a5a1d407a39bafbce6f07456a2c8d9963c8f5c
You can override this key by running the node with the --node-key argument:
gear --node-key=42bb2fdd46edfa4f41a5f0f9c1a5a1d407a39bafbce6f07456a2c8d9963c8f5c# Discovered new external address for our node: /ip4/127.0.0.1/tcp/30333/ws/p2p/12D3KooWMRApe2S5QMdhHwmcDapDxZ7xf2Xa3z2HfCCYoHTmjiXV
If there is no --node-key argument, the node uses the key from the secret_ed25519 file. If it does not exist, it is created with a newly generated secret key.
The network key file cannot be recovered if lost. Therefore, you are to keep it (or the private key itself) to have the possibility to run the node with the same peer ID.
Moving the node​
To move the node to a new server you are to backup then restore the following (provided paths are for default Staging Testnet V7 node's parameters):


The network private key of the node:

Linux: $HOME/.local/share/gear/chains/gear_staging_testnet_v7/network/secret_ed25519
macOS: $HOME/Library/Application Support/gear/chains/gear_staging_testnet_v7/network/secret_ed25519
Windows: %USERPROFILE%\AppData\Local\gear.exe\chains\gear_staging_testnet_v7\network\secret_ed25519



(optional) The database:

Linux: $HOME/.local/share/gear/chains/gear_staging_testnet_v7/db/full
macOS: $HOME/Library/Application Support/gear/chains/gear_staging_testnet_v7/db/full
Windows: %USERPROFILE%\AppData\Local\gear.exe\chains\gear_staging_testnet_v7\db\full



(optional) The service configuration if you've configured the node as a service:

Linux: /etc/systemd/system/gear-node.service



If you don't backup the database, you can always synchronize it from scratch, but keep in mind that this process may take some time.
infoDon't forget to stop the node before backing up the database. Otherwise you can get a corrupted database.sudo systemctl stop gear-nodeEdit this pagePreviousNode MonitoringNextDev Net ModeData structureChainsDatabaseNetwork keyMoving the node








Running Gear node in Dev Net mode | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable 🚧StableEnglishEnglish简体中文SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeSetting UpNode as a ServiceNode MonitoringBackup and RestoreDev Net ModeMulti-Node ModeNode FAQTroubleshootingDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksGear NodeDev Net ModeRunning Gear node in Dev Net mode
Dev net is helpful for the development and debugging of your smart contracts. You can upload your program directly to a local node, send messages to a program and validate the program's logic.
To run the Gear node in a dev net mode:


Compile or download nightly build for your operating system as described in setting-up.


Run the node in dev mode (we assume the executable is in /usr/bin directory):


gear --dev


Follow https://idea.gear-tech.io/ and connect to a local dev node. Click network selection via the left top button, choose Development -> Local node, and click the Switch button. Use the Idea portal for sending messages, reading the program's state, etc.


To purge any existing dev chain state, use:


gear purge-chain --dev

To start a dev chain with detailed logging, use:

RUST_LOG=debug RUST_BACKTRACE=1 gear -lruntime=debug --devEdit this pagePreviousBackup and RestoreNextMulti-Node Mode








Troubleshooting | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable 🚧StableEnglishEnglish简体中文SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeSetting UpNode as a ServiceNode MonitoringBackup and RestoreDev Net ModeMulti-Node ModeNode FAQTroubleshootingDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksGear NodeTroubleshootingOn this pageTroubleshooting
Typical errors and solutions are described here.
Unavailable LOCK file​


Error: IO error: While lock file /root/.local/share/gear/chains/gear_staging_testnet_v7/db/full/LOCK: Resource temporarily unavailable


Solution: You seem to be running several Gear node instances. Note that only one node instance is allowed to run. You likely have configured the node as a service and then ran the second instance from the command line. You should either stop the service or don't run the Gear node from the command line.
You can see the current node processes by running the command:
ps aux | grep gear
If you want to break all node processes you may run:
pkill -sigint gear
Note that the SystemD service can't be stopped by the command above. Run instead:
sudo systemctl stop gear-node


Unexpected argument when starting the node service​


Error: Found argument '\' which wasn't expected, or isn't valid in this context


Solution: The gear-node.service configuration file seems to be misconfigured. Some versions of SystemD do not accept the backslash character (\) as a line break. Therefore, it is better to write each of the config entry on one line.
Refer to https://wiki.gear-tech.io/node/node-as-service for properly configuring the node as a service.
Don't forget to restart the node after fixing the service configuration:
sudo systemctl daemon-reloadsudo systemctl restart gear-node


Corrupted data base​


Error: Database version cannot be read from existing db_version file


Alternative error: Invalid argument: Column families not opened: ..., col2, col1, col0


Solution: The root of this problem is the lack of the disk free space. You may check the free space using the following command:
df -h
Also, you may check how many space is used by the blockchain DB:
du -h $HOME/.local/share/gear/chains/gear_staging_testnet_v7/db/full
Please refer to the System Requirements to see the minimum disk space required.
You need to free more space then purge the chain:
sudo systemctl stop gear-node# Provide more free space on the diskgear purge-chainsudo systemctl start gear-node


Node executable file obsolescence​


Error: Verification failed for block <block-id> received from peer <peer-id>


Alternative error: runtime requires function imports which are not present on the host


Solution: Update the node binary to the latest version.


Masked service​


Error: Failed to start gear-node.service: Unit gear-node.service is masked.


Solution: Please check: https://askubuntu.com/questions/1017311/what-is-a-masked-service

Edit this pagePreviousNode FAQNextIntroductionUnavailable LOCK fileUnexpected argument when starting the node serviceCorrupted data baseNode executable file obsolescenceMasked service








Calculate gas | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable 🚧StableEnglishEnglish简体中文SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGetting StartedKeyringCalculate GasUpload ProgramPay Program rentUpload CodeSend MessageRead StateVouchersMetadata & Type CreationMailboxEventsCookbookGear-JS toolsGeneral topicsGear-based NetworksGear-JSCalculate GasOn this pageCalculate gas
Gear nodes charge gas fees for all network operations, whether that be executing a program’s code or processing a message. This gas is paid for by the initiator of these actions.
They guarantee successful message processing and to avoid errors like Gaslimit exceeded, you can simulate the execution in advance to calculate the exact amount of gas that will be consumed.
Calculate gas for messages​
To find out the minimum gas amount required to send extrinsic, use api.program.calculateGas.[method]. Depending on the conditions, you can calculate gas for initializing a program or processing a message in handle() or reply().
infoGas calculation returns the GasInfo object, which contains 5 parameters:
min_limit - minimum gas limit required for the execution
reserved - gas amount that will be reserved for other on-chain interactions
burned - number of gas burned during message processing
may_be_returned - value that can be returned in some cases
waited - notifies that the message will be added to the waitlist

Init (for upload_program extrinsic)​
const code = fs.readFileSync('demo_ping.opt.wasm');const gas = await api.program.calculateGas.initUpload(  '0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d', // source id  code,  '0x00', // payload  0,      // value  true,   // allow other panics);console.log(gas.toHuman());
Init (for create_program extrinsic)​
const codeId = '0x…';const gas = await api.program.calculateGas.initCreate(  '0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d', // source id  codeId,  '0x00', // payload  0,      // value  true,   // allow other panics);console.log(gas.toHuman());
Handle​
import { getProgramMetadata } from '@gear-js/api';const metadata = await getProgramMetadata('0x' + fs.readFileSync('demo_new_meta.meta.txt'));const gas = await api.program.calculateGas.handle(  '0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d', // source id  '0xa178362715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d', // program id  {    id: {      decimal: 64,      hex: '0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d',    },  },      // payload  0,      // value  false,  // allow other panics  metadata,);console.log(gas.toHuman());
Reply to a message​
import { getProgramMetadata } from '@gear-js/api';const metadata = await getProgramMetadata('0x' + fs.readFileSync('demo_async.meta.txt'));const gas = await api.program.calculateGas.reply(  '0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d', // source id  '0x518e6bc03d274aadb3454f566f634bc2b6aef9ae6faeb832c18ae8300fd72635', // message id  'PONG', // payload  0,      // value  true,   // allow other panics  metadata,);console.log(gas.toHuman());Edit this pagePreviousKeyringNextUpload ProgramCalculate gas for messagesInit (for upload_program extrinsic)Init (for create_program extrinsic)HandleReply to a message








program-rent | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable 🚧StableEnglishEnglish简体中文SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGetting StartedKeyringCalculate GasUpload ProgramPay Program rentUpload CodeSend MessageRead StateVouchersMetadata & Type CreationMailboxEventsCookbookGear-JS toolsGeneral topicsGear-based NetworksGear-JSPay Program rentprogram-rentTo pay program rent, use the following JavaScript code:
// program.payRent has params:// programId// blockCount - number of blocks for which we want to extendconst tx = await api.program.payRent('0x...', 100_000);tx.signAndSend(account, (events) => {   events.forEach(({ event }) => console.log(event.toHuman()));});
You can calculate the current rent price using the following code:
const price = api.program.calculatePayRent(blockCount);
If a program was paused and its pages removed from storage, you can restore it using the api.program.resumeSession methods:

init: Start a new session to resume the program.
push: Push a bunch of program pages.
commit: Finish the resume session.

Here's how you can resume a paused program:
const program = await api.programStorage.getProgram(programId, oneBlockBeforePauseHash);const initTx = api.program.resumeSession.init({  programId,  allocations: program.allocations,  codeHash: program.codeHash.toHex(),});let sessionId;initTx.signAndSend(account, ({ events }) => {  events.forEach(({ event: { method, data } }) => {    if (method === 'ProgramResumeSessionStarted') {      sessionId = data.sessionId.toNumber();    }  });});const pages = await api.programStorage.getProgramPages(programId, program, oneBlockBeforePauseHash);for (const memPage of Object.entries(page)) {  const tx = api.program.resumeSession.push({ sessionId, memoryPages: [memPage] });  tx.signAndSend(account);}const tx = api.program.resumeSession.commit({ sessionId, blockCount: 20_000 });tx.signAndSend(account);Edit this pagePreviousUpload ProgramNextUpload Code








Send Message | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable 🚧StableEnglishEnglish简体中文SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGetting StartedKeyringCalculate GasUpload ProgramPay Program rentUpload CodeSend MessageRead StateVouchersMetadata & Type CreationMailboxEventsCookbookGear-JS toolsGeneral topicsGear-based NetworksGear-JSSend MessageOn this pageSend Message
Use api.message.send method to send messages to the program:
try {  const message = {    destination: destination, // programId    payload: somePayload,    gasLimit: 10000000,    value: 1000,    // prepaid: true,    // account: accountId,    // if you send message with issued voucher  };  // In that case payload will be encoded using meta.types.handle.input type  let extrinsic = api.message.send(message, meta);  // So if you want to use another type you can specify it  extrinsic = api.message.send(message, meta, meta.types.other.input);} catch (error) {  console.error(`${error.name}: ${error.message}`);}try {  await extrinsic.signAndSend(keyring, (event) => {    console.log(event.toHuman());  });} catch (error) {  console.error(`${error.name}: ${error.message}`);}
noteIn real conditions to ensure successful message processing, the calculation of the required gas for processing the message should be performed by using api.program.calculateGas method.more info
Send reply message​
When you need to reply to a message received from a program, use api.message.reply:
try {  const reply = {    replyToId: messageId,    payload: somePayload,    gasLimit: 10000000,    value: 1000,    // prepaid: true,    // account: accountId,    // if you send message with issued voucher  };  // In this case payload will be encoded using `meta.types.reply.input` type.  const extrinsic = api.message.sendReply(reply, meta);} catch (error) {  console.error(`${error.name}: ${error.message}`);}try {  await extrinsic(keyring, (events) => {    console.log(event.toHuman());  });} catch (error) {  console.error(`${error.name}: ${error.message}`);}Edit this pagePreviousUpload CodeNextRead StateSend reply message








Gear 介绍 | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())跳到主要内容Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContribute下一页Unstable 🚧下一页简体中文English简体中文搜索欢迎Intro to Gear Protocol5 分钟快速入门Gear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based Networks欢迎本页总览Gear 介绍欢迎来到 Gear 的文档门户。这是一个中央信息源，供每个 人寻找关于 Gear 的重要信息、指南和开发人员的文档。
我们的 Wiki 概述了所需的基础信息、一般技术概述、Gear 技术的主要优势、帮助开始设置 Gear 节点、如何上传你的智能合约，同时还提供完整的 API 细节和例子。
所有的代码、库和工具都可以在 Github 上获得，并采用 Apache-2.0 许可证。欢迎使用这些工具和库，记录你发现的问题，也可以为你发现的 bug 或增加的功能创建 PR。
由于我们的项目正在发展和壮大，我们非常欢迎你的贡献。
什么是 Gear Protocol？​
Gear 是一个基于 Substrate 的智能合约平台，使任何人都能在几分钟内部署一个 dApp。Gear 是运行智能合约的最具成本效益的方式，这些智能合约是由许多流行的编程语言（如 Rust、C、C++ 等）编译而成。它确保了非常简约、直观和充分的 API，可以在多个网络上运行新写的和现有的程序，而不必重写。智能合约存储在区块链的状态中，并被调用，根据要求保留其状态。
Gear 正计划成为 Polkadot 和 Kusama 网络中的一个准成员，在这些各自的网络中托管智能合约。这将意味着，通过在 Gear 上的部署，开发者将能够以最小的成本利用 Polkadot 和 Kusama 的网络及生态系统的所有好处。
Gear 将通过使创新的 dApps、微服务、中间件和开放的 API  的运行，协助过渡到大规模用 Web3 技术。
What is Gear Network?​
Gear Protocol provides the most cost-effective way to run smart contracts that have been compiled from many popular programming languages, such as Rust, C, C++ and many more.
Powered by Gear Protocol, Gear Networks imply a standalone L1 network as well as are planning on becoming a parachains in the Polkadot and Kusama networks to host smart contracts on these respective networks. This will mean that by deploying on Gear Network, developers would be able to take advantage of all the benefits of the Polkadot and Kusama networks and ecosystems at minimal cost.
如何与 Gear 社区互动​
Github​
技术说明和其他开发相关的对话可以在我们的 Github 中找到。
Discord​
综合信息和非技术相关的信息及对话可以在我们的 Discord 中找到。
Twitter​
关注我们的 Twitter 以获取最新的消息。
Telegram​
加入我们的电报群
官方电报群  中文电报群
Medium​
我们定期在我们的 Medium 频道 上发布更新和文章。编辑此页下一页术语表什么是 Gear Protocol？What is Gear Network?如何与 Gear 社区互动GithubDiscordTwitterTelegramMedium








Read State | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable 🚧StableEnglishEnglish简体中文SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGetting StartedKeyringCalculate GasUpload ProgramPay Program rentUpload CodeSend MessageRead StateVouchersMetadata & Type CreationMailboxEventsCookbookGear-JS toolsGeneral topicsGear-based NetworksGear-JSRead StateOn this pageRead State
There are two different ways to query the program State:

Query the full State of the program. To read the full State of the program, you need to have only the metadata of this program. You can call api.programState.read method to get the state.

import { GearApi } from '@gear-js/api';const api = await GearApi.create({  providerAddress: 'wss://testnet.vara-network.io',});await api.programState.read({ programId: '0x…' }, programMetadata);
Also, you can read the State of the program at some specific block specified by its hash:
await api.programState.read(  { programId: '0x…', at: '0x…' },  programMetadata,);

If you are using the custom functions to query only specific parts of the program State (see more), then you should call api.programState.readUsingWasm method:

// ...import { getStateMetadata } from '@gear-js/api';const stateWasm = readFileSync('path/to/state.meta.wasm');const metadata = await getStateMetadata(stateWasm);const state = await api.programState.readUsingWasm(  {    programId: '0x…',    fn_name: 'name_of_function_to_execute',    stateWasm,    argument: { input: 'payload' },  },  metadata,);
Cookbook​
To read state in JavaScript applications you can use fetch browser API to get buffer from meta.wasm:
// ...const res = await fetch(metaFile);const arrayBuffer = await res.arrayBuffer();const buffer = await Buffer.from(arrayBuffer);const metadata = await getStateMetadata(buffer);// get State only of the first walletconst firstState = await api.programState.readUsingWasm(  { programId: '0x…', fn_name: 'first_wallet', buffer },  metadata,);// get wallet State by idconst secondState = await api.programState.readUsingWasm(  { programId: '0x…', fn_name: 'wallet_by_id', buffer,  argument: { decimal: 1, hex: '0x01' } },  metadata,);Edit this pagePreviousSend MessageNextVouchersCookbook








Mailbox | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable 🚧StableEnglishEnglish简体中文SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGetting StartedKeyringCalculate GasUpload ProgramPay Program rentUpload CodeSend MessageRead StateVouchersMetadata & Type CreationMailboxEventsCookbookGear-JS toolsGeneral topicsGear-based NetworksGear-JSMailboxOn this pageMailbox
The mailbox contains messages from the program that are waiting for user action.
Read messages from Mailbox​
const api = await GearApi.create();const mailbox = await api.mailbox.read(  '5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY',);console.log(mailbox);
Claim value​
To claim value from a message in the mailbox use api.mailbox.claimValue.submit method.
const api = await GearApi.create();const submitted = await api.mailbox.claimValue.submit(messageId);await api.mailbox.claimValue.signAndSend(/* ... */);
Waitlist​
To read the program's waitlist use api.waitlist.read method.
const api = await GearApi.create();const programId = '0x1234…';const waitlist = await api.waitlist.read(programId);console.log(waitlist);Edit this pagePreviousMetadata & Type CreationNextEventsRead messages from MailboxClaim valueWaitlist








Events | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable 🚧StableEnglishEnglish简体中文SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGetting StartedKeyringCalculate GasUpload ProgramPay Program rentUpload CodeSend MessageRead StateVouchersMetadata & Type CreationMailboxEventsCookbookGear-JS toolsGeneral topicsGear-based NetworksGear-JSEventsOn this pageEvents
Events are generated for certain operations during execution. The following sections describe events that are part of the default Gear runtime.
To subscribe to all events:
const unsub = await api.query.system.events((events) => {  console.log(events.toHuman());});// Unsubscribeunsub();
Gear Events Types​
MessageQueued​
Summary: When a user successfully sends a message to a program and it gets added to the Gear message queue.
MessageQueued {    /// Generated id of the message.    id: MessageId,    /// Account id of the source of the message.    source: T::AccountId,    /// Program id, who is the message's destination.    destination: ProgramId,    /// Entry point for processing of the message.    /// On the sending stage, the processing function    /// of the program is always known.    entry: MessageEntry,}
UserMessageSent​
Summary: When someone has sent a message to the user.
UserMessageSent {    /// Message sent.    message: UserMessage,    /// Block number of expiration from `Mailbox`.    ///    /// Equals `Some(_)` with block number when message    /// will be removed from `Mailbox` due to some    /// reasons (see #642, #646 and #1010).    ///    /// Equals `None` if message wasn't inserted to    /// `Mailbox` and appears as only `Event`.    expiration: Option<T::BlockNumber>,}
UserMessageRead​
Summary: When a message has been marked as "read" and it has been removed from the Mailbox. This event only affects messages, which were already prior inserted into the Mailbox.
UserMessageRead {    /// Id of the message read.    id: MessageId,    /// The reason for the reading (removal from `Mailbox`).    ///    /// NOTE: See more docs about reasons at `gear_common::event`.    reason: UserMessageReadReason,}
MessagesDispatched​
Summary: The result of when a message is processed within the block.
MessagesDispatched {    /// Total amount of messages removed from message queue.    total: MessengerCapacityOf<T>,    /// Execution statuses of the messages, which were already known    /// by `Event::MessageQueued` (sent from user to program).    statuses: BTreeMap<MessageId, DispatchStatus>,    /// Ids of programs, which state changed during queue processing.    state_changes: BTreeSet<ProgramId>,}
MessageWaited​
Summary: When a message's execution has been delayed and it has been added to the Gear waitlist.
MessageWaited {    /// Id of the message waited.    id: MessageId,    /// Origin message id, which started messaging chain with programs,    /// where currently waited message was created.    ///    /// Used to identify by the user that this message associated    /// with him and the concrete initial message.    origin: Option<GasNodeId<MessageId, ReservationId>>,    /// The reason of the waiting (addition to `Waitlist`).    ///    /// NOTE: See more docs about reasons at `gear_common::event`.    reason: MessageWaitedReason,    /// Block number of expiration from `Waitlist`.    ///    /// Equals block number when message will be removed from `Waitlist`    /// due to some reasons (see #642, #646 and #1010).    expiration: T::BlockNumber,}
MessageWoken​
Summary: When a message is ready to continue its execution and has been removed from the Waitlist.
MessageWoken {    /// Id of the message woken.    id: MessageId,    /// The reason of the waking (removal from `Waitlist`).    ///    /// NOTE: See more docs about reasons at `gear_common::event`.    reason: MessageWokenReason,}
CodeChanged​
Summary: When a program's code has been altered.
CodeChanged {    /// Id of the code affected.    id: CodeId,    /// Change applied on code with current id.    ///    /// NOTE: See more docs about change kinds at `gear_common::event`.    change: CodeChangeKind<T::BlockNumber>,}
ProgramChanged​
Summary: Any data related to program changed.
ProgramChanged {    /// Id of the program affected.    id: ProgramId,    /// Change applied on program with current id.    ///    /// NOTE: See more docs about change kinds at `gear_common::event`.    change: ProgramChangeKind<T::BlockNumber>,}
ProgramResumeSessionStarted​
Summary: Program resume session has been started.
ProgramResumeSessionStarted {  /// Id of the session.  session_id: SessionId,  /// Owner of the session.  account_id: T::AccountId,  /// Id of the program affected.  program_id: ProgramId,  /// Block number when the session will be removed if not finished.  session_end_block: T::BlockNumber}        
Check what the event is​
api.query.system.events((events) => {  events    .filter(({ event }) => api.events.gear.MessageQueued.is(event))    .forEach(({ event: { data } }) => {      console.log(data.toHuman());    });  events    .filter(({ event }) => api.events.balances.Transfer.is(event))    .forEach(({ event: { data } }) => {      console.log(data.toHuman());    });});
Subscribe to specific gear events​
Subscribe to messages sent from a program​
const unsub = api.gearEvents.subscribeToGearEvent(  'UserMessageSent',  ({    data: {      message: { id, source, destination, payload, value, reply },    },  }) => {    console.log(`  messageId: ${id.toHex()}  source: ${source.toHex()}  payload: ${payload.toHuman()}  `);  },);// Unsubscribeunsub();
Subscribe to messages intended for a program​
const unsub = api.gearEvents.subscribeToGearEvent(  'MessageQueued',  ({ data: { id, source, destination, entry } }) => {    console.log({      messageId: id.toHex(),      programId: destination.toHex(),      userId: source.toHex(),      entry: entry.isInit        ? entry.asInit        : entry.isHandle        ? entry.asHandle        : entry.asReply,    });  },);// Unsubscribeunsub();
Subscribe to Transfer events​
const unsub = await api.gearEvents.subscribeToTransferEvents(  ({ data: { from, to, amount } }) => {    console.log(`    Transfer balance:    from: ${from.toHex()}    to: ${to.toHex()}    amount: ${+amount.toString()}    `);  },);// Unsubscribeunsub();
Subscribe to new blocks​
const unsub = await api.gearEvents.subscribeToNewBlocks((header) => {  console.log(    `New block with number: ${header.number.toNumber()} and hash: ${header.hash.toHex()}`,  );});// Unsubscribeunsub();Edit this pagePreviousMailboxNextCookbookGear Events TypesMessageQueuedUserMessageSentUserMessageReadMessagesDispatchedMessageWaitedMessageWokenCodeChangedProgramChangedProgramResumeSessionStartedCheck what the event isSubscribe to specific gear eventsSubscribe to messages sent from a programSubscribe to messages intended for a programSubscribe to Transfer eventsSubscribe to new blocks








Gear React application template | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable 🚧StableEnglishEnglish简体中文SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGetting StartedKeyringCalculate GasUpload ProgramPay Program rentUpload CodeSend MessageRead StateVouchersMetadata & Type CreationMailboxEventsCookbookGear-JS toolsGear React application templateMeta CLIReact-hooksGeneral topicsGear-based NetworksGear-JSGear-JS toolsGear React application templateOn this pageGear React application template
Introducing Gear React Application Template: Accelerate Your Decentralized App Development
Are you looking to swiftly launch your decentralized application (dApp) on Gear-powered blockchains? Look no further! Gear React Application Template, also known as create-gear-app, is a pre-configured application template designed to streamline the development process. With its well-thought-out infrastructure and convenient features, it allows developers to quickly create and deploy their dApps on Gear-powered blockchains.
Gear React Application Template can be found on GitHub. This template is packed with a range of benefits and features that make it an ideal choice for developers seeking efficiency and simplicity in their dApp development workflow.
Features​
Let's delve into the key features that Gear React Application Template has to offer:


Gear API Connections: Integrating your dApp with Gear-powered blockchains is made seamless with pre-configured API connections, saving developers the hassle of manually setting up the necessary connections. By leveraging Gear's powerful infrastructure, developers can easily interact with the blockchain and access essential blockchain functionalities.


Login Interface: User authentication is a critical aspect of any application, and Gear React Application Template includes a pre-built login interface. This feature enables developers to quickly implement user authentication and securely manage user access to their dApps. With this functionality readily available, developers can focus on building the core features of their dApp without worrying about the authentication process.


Gear React-Hooks Support: Gear React Application Template is designed to take advantage of Gear's react-hooks library, providing developers with a smooth and intuitive development experience. The template includes all the necessary environments and configurations to seamlessly integrate react-hooks into your dApp.


Branded UI-Kit: User experience plays a crucial role in the success of any application. Gear React Application Template offers a branded UI-kit that ensures a visually appealing and consistent user interface. The UI-kit is designed to align with Gear's branding guidelines, providing developers with a head start in creating an attractive and professional-looking dApp. This feature allows developers to focus on developing the unique aspects of their application while maintaining a polished and cohesive design.


Gear React Application Template is an invaluable resource for various developers in the blockchain space. Whether you are a seasoned blockchain developer or just starting your journey, this template can significantly speed up your dApp development process. It simplifies the integration with Gear-powered blockchains, provides a robust login interface, offers support for Gear react-hooks, and includes a branded UI-kit for a visually appealing application.
Furthermore, Gear React Application Template is particularly beneficial for developers who prioritize efficiency and value a well-structured and standardized development workflow. By leveraging the template's pre-configured infrastructure, developers can save precious time and effort that would otherwise be spent on setting up and integrating the various components required for a blockchain application.
Installation​
Simply clone this repo to your local folder:
git clone https://github.com/gear-foundation/dapps-react-app.git d-appEdit this pagePreviousCookbookNextMeta CLIFeaturesInstallation








Gear Library | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable 🚧StableEnglishEnglish简体中文SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsIntroductionGear LibraryMailboxState FunctionsMetadataData Encoding/DecodingAsynchronous ProgrammingCreate ProgramGas ReservationDelayed MessagesConsistency and ReliabilitySystem SignalsReply DepositUpload ProgramProgram RentProgram TestingTesting with gtestTesting with gclientSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksDeveloping Smart ContractsGear LibraryOn this pageGear Library
The Gear Protocol’s library gstd provides all the necessary and sufficient functions and methods for developing smart-contracts.
Importing familiar types via prelude​
The gstd default prelude lists things that Rust automatically imports into every program. It re-imports default std modules and traits. std can be safely replaced with gstd in the Gear programs on Rust.
See more details here.
Message handling​
The Gear Protocol allows users and programs to interact with other users and programs via messages. Messages can contain a payload that will be able to be processed during message execution. Interaction with messages is possible thanks to the module msg:
use gstd::msg;
Message processing is possible only inside the defined functions init(), handle(), hadle_reply(), and state(). They also define the context for processing such messages.

Get a payload of the message currently being processed and decode it:

#![no_std]use gstd::{msg, prelude::*};#[no_mangle]extern "C" fn handle() {    let payload_string: String = msg::load().expect("Unable to decode `String`");}

Reply to the message with payload:

#![no_std]use gstd::msg;#[no_mangle]extern "C" fn handle() {    msg::reply("PONG", 0).expect("Unable to reply");}

Send message to user:

#![no_std]use gstd::{msg, prelude::*};#[no_mangle]extern "C" fn handle() {    // ...    let id = msg::source();    let message_string = "Hello there".to_string();    msg::send(id, message_string, 0).expect("Unable to send message");}
You can see more cases of using the msg module in our documentation.
Execution info​
A program can get some useful information about the current execution context by using the exec module:
use gstd::exec;

Send a reply after the block timestamp reaches the indicated date:

#![no_std]use gstd::{exec, msg};#[no_mangle]extern "C" fn handle() {    // Timestamp is in milliseconds since the Unix epoch    if exec::block_timestamp() >= 1672531200000 {        msg::reply(b"Current block has been generated after January 01, 2023", 0)            .expect("Unable to reply");    }}

Get self value balance of a program:

#![no_std]use gstd::exec;#[no_mangle]extern "C" fn handle() {    // Get self value balance in program    let my_balance = exec::value_available();}
You can read more about program syscalls here.
Logging inside the contracts​
Macro gstd::debug provides an ability to debug contract during program execution:
#![no_std]use gstd::{debug, msg, prelude::*};#[no_mangle]extern "C" fn handle() {    let payload_string: String = msg::load().expect("Unable to decode `String`");    debug!("Received message: {payload_string:?}");}
noteThe debug! macro is available only when the "debug" feature is enabled for the gstd crate.[dependencies]gstd = { git = "https://github.com/gear-tech/gear.git", tag = "v1.0.2", features = ["debug"] }Edit this pagePreviousIntroductionNextMailboxImporting familiar types via preludeMessage handlingExecution infoLogging inside the contracts








Store data | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable 🚧StableEnglishEnglish简体中文SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsIntroductionGear LibraryMailboxState FunctionsMetadataData Encoding/DecodingAsynchronous ProgrammingCreate ProgramGas ReservationDelayed MessagesConsistency and ReliabilitySystem SignalsReply DepositUpload ProgramProgram RentProgram TestingTesting with gtestTesting with gclientSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksDeveloping Smart ContractsState FunctionsOn this pageStore data
Persistent data of the Gear smart contract is stored in the same way as in a classic program and does not require initialization of the external storage.
// Describe state structure#[derive(TypeInfo, Decode, Encode, Clone)]pub struct Wallet {    pub id: ActorId,    pub person: String,}// Declare and initialize the statestatic mut WALLETS: Vec<Wallet> = Vec::new();
If you're programming in Rust or other object-oriented languages, you should be familiar with most types. However, the ActorId type is something new when developing contracts via the Gear Protocol.
infoActorId is a special type that represents an 32 bytes array and defines any ID in Gear Protocol.
State functions​
To display the contract state information, the state() function is used. It allows you to instantly read the contract status (for example, contract balance). Reading state is a free function and does not require gas costs.
Example of the returning all wallets defined above:
#[no_mangle]extern "C" fn state() {    msg::reply(unsafe { WALLETS.clone() }, 0).expect("Failed to share state");}
Additionally, you can handle incoming payload and return only the necessary part of the state. For example, you can return only the selected wallet:
#[no_mangle]extern "C" fn state() {    let index: usize = msg::load().expect("Unable to decode `usize`");    let wallets = unsafe { WALLETS.clone() };    if index < wallets.len() => {        msg::reply(wallets[index], 0).expect("Failed to share state");    } else {        panic!("Wallet index out of bounds");    }}
Custom program to read the state​
Additionally, you can create your own program to read the state. This wrapper will allow you to implement custom functions for the client side, not depending on the main program.
This has a number of advantages, for example, you will always be able to read the state even if the program changes (as long as the incoming or outgoing types have not changed). Or you are creating a service based on an already existing program and you need some of your own functions to get your own chanks of data from the state.
To do this, we need to create an independent program and describe the necessary functions inside the metawasm trait. For example:
// ...use gmeta::metawasm;#[metawasm]pub mod metafns {    pub type State = Vec<Wallet>;    pub fn all_wallets(state: State) -> Vec<Wallet> {        state    }    pub fn first_wallet(state: State) -> Option<Wallet> {        state.first().cloned()    }    pub fn last_wallet(state: State) -> Option<Wallet> {        state.last().cloned()    }}
Or more complex example:
// ...use gmeta::metawasm;#[metawasm]pub mod metafns {    pub type State = Vec<Wallet>;    pub fn wallet_by_id(state: State, id: Id) -> Option<Wallet> {        state.into_iter().find(|w| w.id == id)    }    pub fn wallet_by_person(state: State, person: String) -> Option<Wallet> {        state.into_iter().find(|w| w.person == person)    }}
To build *.meta.wasm, the following build.rs file in the root of your project is required:
fn main() {    gear_wasm_builder::build_metawasm();}
Learn more how metadata works.Edit this pagePreviousMailboxNextMetadataState functionsCustom program to read the state








Data encoding/decoding | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable 🚧StableEnglishEnglish简体中文SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsIntroductionGear LibraryMailboxState FunctionsMetadataData Encoding/DecodingAsynchronous ProgrammingCreate ProgramGas ReservationDelayed MessagesConsistency and ReliabilitySystem SignalsReply DepositUpload ProgramProgram RentProgram TestingTesting with gtestTesting with gclientSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksDeveloping Smart ContractsData Encoding/DecodingOn this pageData encoding/decoding
To optimize how data is sent and received over the network, Gear uses the parity-scale-codec - a Rust implementation of the SCALE Codec. This codec is used by the Substrate nodes' internal runtime. SCALE is a lightweight format that enables the serialization and deserialization of data. Encoding (and decoding) data using SCALE makes it highly suitable for resource-constrained execution environments like blockchain runtimes and low-power/low-memory devices.
To use SCALE codec in your program, you should add it in Cargo.toml:
[dependencies]// ...codec = { package = "parity-scale-codec", version = "3.6", default-features = false }
use codec::{Decode, Encode};#[derive(Encode, Decode)]enum MyType {    MyStruct { field: ... },    ...}
infoWe only need the Encode and Decode traits when using wrapped methods from gstd, such as: msg::load, msg::send, msg::reply, msg::send_for_reply etc.In methods like msg::load_bytes, msg::send_bytes, or msg::reply_bytes we operate with a set of bytes, so nothing needs to be decoded/encoded.
Learn more about SCALE Codec here.
scale-info​
scale-info is a library to describe Rust types, intended for providing information about the structure of encodable SCALE types.
The definitions provide third party tools (e.g. a UI client) with information about how they are able to decode types agnostic of language. The interface that uses scale-info for Gear programs is called metadata. It defines incoming and outgoing types for all necessary entry points and allows contracts and the client part to understand each other.
infoLearn more how to use metadata in contract.
To use scale-info in your project:
[dependencies]// ...scale-info = { version = "2.9", default-features = false, features = ["derive"] }
Learn more about scale-info hereEdit this pagePreviousMetadataNextAsynchronous Programmingscale-info








Gas Reservation | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable 🚧StableEnglishEnglish简体中文SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsIntroductionGear LibraryMailboxState FunctionsMetadataData Encoding/DecodingAsynchronous ProgrammingCreate ProgramGas ReservationDelayed MessagesConsistency and ReliabilitySystem SignalsReply DepositUpload ProgramProgram RentProgram TestingTesting with gtestTesting with gclientSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksDeveloping Smart ContractsGas ReservationGas Reservation
Gas reservation is the powerful feature of Gear Protocol that enables the new approach to smart-contract programming and modern use cases.
Briefly, a program can send a message using gas that was reserved before instead of using gas from the currently processing message.
One of the key advantage of this feature is an ability of sending messages delayed in time automatically to any actor in the network - a user or another smart contract as well as to itself. In fact, a program is able to execute itself unlimited number of blocks (provided that enough gas for execution is kept available).
A program developer can provide a special function in the program's code which takes some defined amount of gas from the amount available for this program and reserves it. A reservation gets a unique identifier that can be used by a program to get this reserved gas and use it later.
To reserve the amount of gas for further usage use the ReservationId::reserve function:
let reservation_id = ReservationId::reserve(RESERVATION_AMOUNT, TIME)    .expect("Reservation across executions");
You also have to indicate the block count within which the reserve must be used. Gas reservation is not free: the reservation for one block costs some gas. The reserve function returns ReservationId, which one can use for sending a message with that gas. To send a message using the reserved gas:
msg::send_from_reservation(reservation_id, program, payload, value)    .expect("Failed to send message from reservation");
If gas is not needed within the time specified during the reservation, it can be unreserved and the gas will be returned to the user who made the reservation.
id.unreserve().expect("Unreservation across executions");
Programs can have different executions, change state and evaluate somehow, but when it is necessary, a program can send a message with this reserved gas instead of using its own gas.
For example, let's consider the game that works completely on-chain. The players are smart contracts that compete with each other by implementing various playing strategies. Usually, in these types of games, there is a master contract that starts the game and controls the move order between the players.
To start the game, someone sends a message to the contract. The gas attached to this message is spent on the players' contracts, which in turn spend gas on their execution. Since the game can last quite a lot of rounds, the attached gas may not be enough to complete the game. You can send a message asking the program to continue the game, or you can use the gas reservation and make a fully automatic play.
Using gas reservation the contract will be able to hold the game without interruption.Edit this pagePreviousCreate ProgramNextDelayed Messages








Ensuring reliability in asynс programming | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable 🚧StableEnglishEnglish简体中文SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsIntroductionGear LibraryMailboxState FunctionsMetadataData Encoding/DecodingAsynchronous ProgrammingCreate ProgramGas ReservationDelayed MessagesConsistency and ReliabilitySystem SignalsReply DepositUpload ProgramProgram RentProgram TestingTesting with gtestTesting with gclientSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksDeveloping Smart ContractsConsistency and ReliabilityOn this pageEnsuring reliability in asynс programming
One of the key features of the Gear Protocol is its use of the Actor model for message-passing communication. The Actor model framework enables asynchronous messaging and parallel computation, which  drastically improves the achievable speed and scalability of dApps. In the Actor model, programs do not share state and instead communicate with each other through messages. If a program sends an asynchronous message to another program, it has to wait for a reply from the other program before it can proceed with the next operation.
When a program interacts with another program, the transaction becomes "distributed." A distributed transaction is a set of operations performed across multiple databases or, in the case of the Gear Protocol, across multiple actors with their own states. Distributed transactions must possess these properties:

Atomicity - all data changes are treated as if they were a single operation. That is, either all of the modifications are made, or none of them are made;
Consistency - this property implies that when a transaction begins and ends, the state of data is consistent.

For example, transactions on the Ethereum blockchain are atomic, meaning that if a transaction fails due to an error, all of its effects on the global state are rolled back as if the transaction never occurred. Many blockchain applications rely on the atomicity of transactions, but this can be a problem when building asynchronous applications using the programming paradigm used on Ethereum, as you may encounter the problem of not being able to recover program state after a failed transaction.
Consider a simple token exchange where a user wants to swap tokens A for tokens B in a liquidity pool. The swap contract would send a message to the token A contract and a message to the token B contract. If one of these messages succeeds and the other fails for some reason, the state of the token A contract would be changed while the state of the token B contract would remain unchanged. This can cause inconsistencies in the state of the data and make it difficult to recover from failed transactions. As a result, it is important to consider different programming paradigms for implementing distributed transactions.
Let's look at different programming methods using the example of a token exchange.
Splitting a token swap transaction into 3 separate transactions​
Consider the following situation: we have a liquidity pool of token A and token B, and also a user who wants to exchange his tokens A for tokens B.
Step 1 : A user sends a MakeOrder message to the swap contract. During that transaction the contract sends a message to the fungible token contract. The result of executing this message can be a success or a failure. The worst case scenario is having a lack of gas when processing a message in the token contract or in the subsequent execution of the swap contract. However, since the token contract supports idempotency, the user can simply restart the transaction and complete it.


Step 2:  A user sends an ExecuteOrder message to the swap contract. The swap contract just calculates the amount of tokens a user will receive and saves the new state of the liquidity poll.


Step 3:  A user sends a Withdraw message to the swap contract and receives tokens B. The situation here is the same as in the first step.


It is possible to execute a swap in one transaction. To resolve the problem of atomicity we can use the following patterns here:

2 PC - 2 Phase Commit protocol (And also its extension - 3 phase commit protocol);
Saga Pattern.

Two phase commit protocol​
Theory:
We have a coordinator that sends messages to participants. The two-phase commit protocol has two parts: the prepare phase and the commit phase.
Preparation phase:
During the preparation phase, the coordinator and participants perform the following dialog:

Coordinator:
The coordinator directs each participant database server to prepare to commit the transaction.
Participants:
Every participant notifies the coordinator whether it can commit to its transaction branch.
Coordinator:
The coordinator, based on the response from each participant, decides whether to commit or roll back the transaction. It decides to commit only if all participants indicate that they can commit to their transaction branches. If any participant indicates that it is not ready to commit to its transaction branch (or if it does not respond), the coordinator decides to end the global transaction.

Commit phase:
During the commit phase, the coordinator and participants perform the following dialog:

Coordinator:
The coordinator writes the commit record or rollback record to the coordinator's logical log and then directs each participant to either commit or roll back the transaction.
Participants:
If the coordinator issued a commit message, the participants commit the transaction by writing the commit record to the logical log and then sending a message to the coordinator acknowledging that the transaction was committed. If the coordinator issued a rollback message, the participants roll back the transaction but do not send an acknowledgment to the coordinator.
Coordinator:
If the coordinator issues a message to commit the transaction, it waits to receive acknowledgment from each participant before it ends the global transaction. If the coordinator issued a message to roll back the transaction, it does not wait for acknowledgments from the participants.

Let's see how it can be used in the example of a token swap contract. We consider the following situation: the account wants to exchange his tokens (let’s call it tokenA) for other tokens (tokenB) using the liquidity pool in the swap contract.
In that case the swap contract is a coordinator contract and tokens contracts are participants.
The swap contract makes the following steps:
Prepare phase

Swap contract:
Swap contract sends the messages to token contracts to prepare transfer tokens (Messages can be sent in parallel). In fact, token contracts must lock funds at this stage.
Token contract:
Token contracts make all necessary checks, and in case of success, lock funds and reply to the swap contract that they are ready to make a transaction.
Swap contract:
Swap contract handles the messages from the token contracts and decides whether to commit or abort the global transaction.
receives tokens B. The situation here is the same as in the first step.



Commit phase

Swap contract:
If token contracts confirm their readiness to execute the transaction, the swap contract sends them a message to commit the state. Otherwise, the swap contract tells them to abort the transaction.
Token contract:
Token contracts finally change their state and send replies to the swap contract;
`Swap contracts:
Swap contract handles the messages from the token contracts and saves the result about transaction execution.



Of course, all that workflow handles the case when the gas runs out during the message execution.
Pros:

Messages can be sent in parallel;
If cases with a lack of gas are taken into account, then the data consistency is achieved.

Cons:

The participants have to wait for the message from the coordinator, they can’t commit or abort themselves;
The coordinator plays an important role: if it fails to send the message then all participants go to the blocked state (in our example: the funds in token contracts are blocked).

Three phase commit protocol.​
Theory: It is similar to two-phase commit protocol but it tries to solve the problems with blocking the state of participants and to give the participants the opportunity to recover their states themselves.
Prepare phase:
The same steps of two phase commit protocol are followed here:

Coordinator:
The coordinator sends a prepare message to all participants and waits for replies;
Participants:
If the participants are ready to commit a transaction they send the ready message, otherwise they send no message to the coordinator.
Coordinator:
Based on replies the coordinator decides either to go to the next state or not. If any of the participants respond with no message or if any of the participants fails to respond within a defined time, the coordinator sends an abort message to every participant.  It is important to highlight the differences from two phase commit protocol:

The coordinator limits the response time from the participant. We can implement this by sending a message with an indicated amount of gas or indicated number of blocks the coordinator is ready to wait;
If the coordinator fails at this state, then the participants are able to abort the transaction (i.e. unlock their state) using delayed messages. So, in that phase, the timeout cases abort.



Prepare-to-commit phase:

Coordinator:
The coordinator sends a prepare-to-commit message to all participants and gets acknowledgements from everyone;
Participants:
Receiving a prepare-to-commit message, a participant knows that the unanimous decision was to commit. As was already mentioned in the prepare phase, if a participant fails to receive this message in time, then it aborts. However, if a participant receives an abort message then it can immediately abort the transaction.
The possible problem: the coordinator fails during sending a prepare-to-commit to participants. So some participants are in phase 2, others are in phase 1. It's a disaster because the first group will commit, the second group will abort in case of timeout.
So we have to make sure that If one of the participants has received a precommit message, they can all commit. If the coordinator falls, any of the participants, being at the second stage, can become the coordinator itself and continue the transaction.
Coordinator:
Having received acknowledgements from all the participants, the coordinator goes to the next phase.

The three-phase commit protocol accomplishes two things:

Enables use of a recovery coordinator (it can be a coordinator itself that starts a new transaction, or a participant). If a coordinator died, a recovery coordinator can query a participant.

If the participant is found to be in phase 2, that means that every participant has completed phase 1 and voted on the outcome. The completion of phase 1 is guaranteed. It is possible that some participants may have received commit requests (phase 3). The recovery coordinator can safely resume at phase 2.
If the participant was in phase 1, that means NO participant has started commits or aborts. The protocol can start at the beginning.
If the participant was in phase 3, the coordinator can continue in phase 3 – and make sure everyone gets the commit/abort request


Every phase can now time out – there is no indefinite wait as in the two-phase commit protocol.

Phase 1:
Participant aborts if it doesn’t hear from a coordinator in time;
Coordinator sends aborts to all if it doesn’t hear from any participant.
Phase 2:
If a participant times out waiting for a coordinator, elect a new coordinator.



Let’s get back to our swap contract.
Preparation phase:
The following cases are possible:

all token contracts receive the message;
the swap contract fails to wait for response from any token contract
the swap contract fails itself.

In the case of a fall, if a transaction isn't restarted, the swap contract will not move to the second phase and the token contracts will unlock their state using delayed messages.


Pre-Commit phase:
At this stage we can have a failure in the swap contract or in the token contract only due to the lack of gas.  To solve this problem we can use gas reservation as follows:

The swap contract receives the information about error in its handle_signal;
Using gas reservation (so, it’s necessary to care about gas reservations before), the swap contract sends a message to itself to restart the transaction from the second phase. (The same logic can also be used in the preparation phase).



Commit phase:
As in the previous stage we can have a failure only due to the lack of gas. Here it is not so critical, since at this stage all participants can commit themselves.
Saga pattern​
Theory:
A saga is a sequence of local transactions. Each local transaction updates the database and publishes a message or event to trigger the next local transaction in the saga. If a local transaction fails because it violates a business rule then the saga executes a series of compensating transactions that undo the changes that were made by the preceding local transactions. Thus, Saga consists of multiple steps whereas 2PC acts like a single request.
There are two ways of coordination sagas:

Choreography - each local transaction publishes domain events that trigger local transactions in other services;
Orchestration - an orchestrator (object) tells the participants what local transactions to execute.

We will consider the orchestration based Saga where there would be an orchestrator (swap contract) to manage the entire operation from one center.
The swap operation consists of the following steps:

Swap contract receives a message to exchange tokens in the liquidity pool. So, it must transfer tokens A from the account to its address and then transfer tokens B to the user.
It creates the first task: transfer tokens from the user to the swap contract. It also creates a compensating transaction for the first task: transfer tokens from the swap contract back to the user. The second task is to transfer tokens from the swap contract to the user.
It starts executing the first task. If the execution fails, it cancels the transaction. If it’s successful, the swap contract executes the second task;
If the execution of the second task is successful, the transaction is completed. Otherwise, the swap contract executes the compensation transaction for the first task.



It is important to note that compensatory transactions should not fail due to any logical error. They can only fall due to lack of gas. If this happens, then you need to restart the transaction again or use the gas reservation. The idempotency of the token contract guarantees that the transaction will be completed to the end without any duplicate transactions.Edit this pagePreviousDelayed MessagesNextSystem SignalsSplitting a token swap transaction into 3 separate transactionsTwo phase commit protocolThree phase commit protocol.Saga pattern








System signals | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable 🚧StableEnglishEnglish简体中文SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsIntroductionGear LibraryMailboxState FunctionsMetadataData Encoding/DecodingAsynchronous ProgrammingCreate ProgramGas ReservationDelayed MessagesConsistency and ReliabilitySystem SignalsReply DepositUpload ProgramProgram RentProgram TestingTesting with gtestTesting with gclientSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksDeveloping Smart ContractsSystem SignalsSystem signals
The Gear Protocol ensures system and program's state consistency via introducing special handling mechanisms for potential issues and corner cases.
Gear actors have three common entry points - init, handle, handle_reply. Another special system entry point introduced by the Gear Protocol is handle_signal. It allows the system to communicate with programs if it is necessary to notify (signal) that some event related to the program's messages has happened. Only the system (Gear node runtime) can send signal messages to a program.
First of all, it can be useful to free up resources occupied by the program. A custom async logic in Gear implies storing Futures in a program's memory. The execution context of Futures can occupy some significant amount of memory in the case of many futures. When a program sends a message and waits for a reply to be woken, the reply can not be received. So there might be the case that if the initial message in the waitlist runs out of gas or the gas amount is not enough to properly finish the execution, the program’s state will be rolled back and Future will never be freed.
In this case, Futures remain in memory pages forever. Other messages are not aware of Futures associated with other messages. Over time, Futures accumulate in the program's memory so eventually a large amount of Futures limits the max amount of space the program can use.
In case a message has been removed from the waitlist due to gas constraints, the system sends a system message (signal) that is baked by an amount of reserved gas, which informs the program that it’s message was removed from the waitlist. Based on this info, a program can clean up its used system resources (Futures).
The gstd library provides a separate exec::system_reserve_gas function for reserving gas specifically for system signal messages. It cannot be used for sending other regular cross-actor messages:
exec::system_reserve_gas(1_000_000_000).expect("Error during system gas reservation");
Even if this function hasn't been called, the system will reserve gas for system messages automatically with the default amount of 1_000_000_000.
If a signal message appears, it uses gas specifically reserved for such kinds of messages. If no gas has been reserved for system messages, they are just skipped and the program will not receive them.
If gas has been reserved but no system messages occur during the current execution, then this gas returns back from where it was taken. The same relates to gas reserved for non-system messages - gas returns back after a defined number of blocks or by the program’s command.
handle_signal has a default implementation if the smart contract has async init or/and async main functions (see Asynchronous Programming for more details about async entry points). To define your own signal handler, you need to use the gstd::async_init/gstd::async_main macro with the specified handle_signal argument. For example:
#[gstd::async_main(handle_signal = my_handle_signal)]async fn main() {    // ...}fn my_handle_signal() {    // ...}
infoNote that the custom signal handler derives its default behavior.
Some useful functions that can be used in handle_signal:

msg::signal_from - returns an identifier of the message which caused the signal;
msg::signal_code - returns the reason code of the signal (see SignalCode enum for more details).

It can be useful for a developer when writing communication between programs. Developer can define my_handle_signal function and implement some logic there. For example, Program A sent a message to Program B. Program A is waiting for a reply from Program B but Program B runs out of gas. The current execution will be interrupted, but the system will send a signal to Program A and indicates the message identifier during which the execution was interrupted.
So, Program A sends a message and saves the message identifier:
exec::system_reserve_gas(2_000_000_000)    .expect("Error during system gas reservation");let result = msg::send_for_reply(address, payload, value, reply_deposit);let (msg_id, msg_future) = if let Ok(msg_future) = result {    (msg_future.waiting_reply_to, msg_future)} else {    // handle the error here};// save the `msg_id` in program stateunsafe { STATE.msg_id == msg::id() };let reply = msg_future.await;
The execution fails in Program B, and Program A receives a signal:
#[no_mangle]extern "C" fn my_handle_signal() {    if unsafe { STATE.msg_id == msg::signal_from() } {        // write logic here    }}
However, it is important to understand that the execution of my_handle_signal should not be long and should not consume a lot of gas. It can be used for tracking failures during the transaction. The program can use the information about failures the next time it is executed.
For programs written using the Gear Protocol's gstd library, such signals can be sent to programs automatically under the hood when applicable. If a smart contract developer implements a program using gcore or Gear's syscalls, then such signals should be considered in the program's code explicitly.Edit this pagePreviousConsistency and ReliabilityNextReply Deposit








Glossary | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable 🚧StableEnglishEnglish简体中文SearchWelcome!Intro to Gear ProtocolWhy do we build Gear?Gear Distinctive FeaturesGear Protocol TechnologyGlossaryGetting StartedGear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksIntro to Gear ProtocolGlossaryOn this pageGlossary
Account​
In cryptocurrency systems, a user is represented by an account that has an address(es) with specific balances associated with their address. Besides that, an account can contain additional details such as contact information, eligibility for rewards, and more.
Actor​
A computational entity that, in response to a message it receives, can concurrently: send a finite number of messages to other actors; create a finite number of new actors; designate the behavior to be used for the next message it receives.
Actor Model​
The principle of the Actor model approach for communication is that programs never share any state and just exchange messages between each other.
Blockchain​
A blockchain is a decentralized and distributed system of recording information in ways that make it almost impossible to change, hack or manipulate.
Block​
A data structure in the blockchain database, where transaction data in a cryptocurrency blockchain are permanently recorded. A block records some or all of the most recent transactions not yet validated by the network. Once the data is validated, the block is closed.
Block height​
A number of blocks preceding it in the blockchain.
Block hash​
A unique hash of the block that is aimed to maintain the integrity of the data stored in the block.
Bridges​
Bridges are ways for two economically sovereign blockchains to communicate with each other.
Collators​
Collators maintain parachains by collecting parachain transactions from users and producing state transition proofs for Relay Chain validators.
Decentralized Application (dApp)​
A Decentralized Application, or dApp for short, is an application that can operate autonomously, typically through the use of smart contracts, that runs on a blockchain network.
Decentralized Autonomous Organization (DAO)​
A Decentralized Autonomous Organization, or DAO for short, is an organization that’s represented by rules encoded in a smart contract that is transparent and controlled by the organization members instead of being influenced by central entities.
Decentralized Finance (DeFi)​
Decentralized Finance, or DeFi for short, are financial services that are powered by decentralized applications and blockchain technology.
Layer-0 protocol​
The ground floor for all blockchain protocols. Examples of operating Layer 0 blockchains include Kusama and Polkadot.
Layer-1 blockchain protocol​
A term used to describe the underlying main blockchain architecture. It’s a set of solutions that improve the base protocol itself to make the overall system more scalable. The two approaches proposed for implementing Layer 1 solutions include the consensus protocol and sharding. Examples of operating Layer-1 blockchains include Bitcoin, Ethereum etc.
Layer-2 blockchain protocol​
A secondary framework or protocol that is built on top of an existing blockchain system. The main goal of these protocols is to solve the transaction speed and scaling difficulties that are being faced by the major cryptocurrency networks.
Ledger​
A list of entries containing transactions signed by account owners. A blockchain is a type of distributed ledger.
Memory Parallelism​
Memory-level parallelism is a term in computer architecture referring to the ability to have pending multiple memory operations, in particular, cache misses or translation lookaside buffer misses, at the same time.
Node​
A computer device that runs on a blockchain network for message processing; it can also be a validator (block producer). Node makes the information available to everyone via a connected device.
Non-Fungible Tokens (NFTs)​
A Non-Fungible Token is a unique unit of data that’s represented as a cryptographic token that’s stored on a blockchain.
Parachain​
Parachains are application specific data structures that are integrated into the Polkadot and Kusama networks by connecting to the main Relay Chain. They enable transactions to be spread out and processed in parallel over an ecosystem.
Polkadot​
Polkadot is an open-source blockchain network that is aiming to enable cross-chain communication between different blockchain networks.
Relay Chain​
The Relay Chain is the central chain of the Polkadot network. It is responsible for the networks' shared security, consensus and transaction settlements.
Rust​
A multi-paradigm, general-purpose programming language designed for performance and safety, especially safe concurrency. Rust is syntactically similar to C++.
Sharding​
Sharding is the process of dividing a blockchain’s database into smaller “shards” to spread the transactional load to help make the network more scalable.
Smart Contracts​
A smart contract is a transactional computer program that can execute transactions automatically once certain conditions have been met, without any intervention.
Substrate​
Substrate is the modular framework for building customized blockchains and the foundation for the whole Polkadot ecosystem. Substrate allows developers to quickly build and launch a blockchain that will be capable of connecting to the Polkadot or Kusama networks.
Transaction​
A record in a digital ledger that represents an atomic event in a blockchain. In the case of Gear Protocol transactions can be of four types: create a program; send a message; dequeue messages; balance transfers.
Validator​
A node that verifies transactions on a blockchain and produces blocks.
Wallet​
A blockchain wallet is an application that allows users to store and manage their cryptocurrencies.
Web3​
Web3 is the third evolution of the internet that is heavily supported by blockchain technology and decentralized applications.
WebAssembly (Wasm)​
WebAssembly is a way to run applications in programming languages other than JavaScript as web pages. Essentially, Wasm is just a binary code format to be executed on a virtual machine that runs on all modern browsers. But whereas in the past you were required to use JavaScript to run code on a web page, Wasm makes it possible to run code in browsers written in programming languages other than JavaScript.
While the first implementations of Wasm virtual machines have landed in web browsers, there are also non-browser implementations for general-purpose use, including Wasmer, Wasmtime, etc.Edit this pagePreviousState TransitionNextGetting StartedAccountActorActor ModelBlockchainBlockBlock heightBlock hashBridgesCollatorsDecentralized Application (dApp)Decentralized Autonomous Organization (DAO)Decentralized Finance (DeFi)Layer-0 protocolLayer-1 blockchain protocolLayer-2 blockchain protocolLedgerMemory ParallelismNodeNon-Fungible Tokens (NFTs)ParachainPolkadotRelay ChainRustShardingSmart ContractsSubstrateTransactionValidatorWalletWeb3WebAssembly (Wasm)








Program Rent | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable 🚧StableEnglishEnglish简体中文SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsIntroductionGear LibraryMailboxState FunctionsMetadataData Encoding/DecodingAsynchronous ProgrammingCreate ProgramGas ReservationDelayed MessagesConsistency and ReliabilitySystem SignalsReply DepositUpload ProgramProgram RentProgram TestingTesting with gtestTesting with gclientSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksDeveloping Smart ContractsProgram RentOn this pageProgram Rent
Gear Protocol utilizes a rent-based program management system. When developers upload a program (smart contract) to the network, its expiration date is assigned. The expiration period is measured in blocks.
After the expiration date, the program is automatically removed from storage, unless the owner chooses to extend its life by paying rent. The owner must indicate the number of additional blocks they can pay for, and they need to pay the rent in utility tokens to keep the program active beyond its initial expiration date.
infoCurrent initial rent period: 5,000,000 blocks (on Vara it will be around 173 days)
After uploading a program, you can observe a similar event:
gear.ProgramChanged
{    "id": "0xde76e4cf663ff825d94944d6f060204e83fbb5e24f8dfdbbdc25842df4f4135d",    "change": {        "Active": {            "expiration": "12,834,248"        }    }}
How to extend the rent of the program?​
To extend the rent period of a program, simply call the special extrinsic gear.payProgramRent(programId, blockCount). See more
Can I restore a deleted program?​
Yes. Since the blockchain stores all states for the entire history, you can restore the program's state to the previous block before it was deleted.
Why does Gear use the program rent system?​

Optimization and efficient resource usage
Stimulating utility token usage
Edit this pagePreviousUpload ProgramNextProgram TestingHow to extend the rent of the program?Can I restore a deleted program?Why does Gear use the program rent system?








Testing with gtest | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable 🚧StableEnglishEnglish简体中文SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsIntroductionGear LibraryMailboxState FunctionsMetadataData Encoding/DecodingAsynchronous ProgrammingCreate ProgramGas ReservationDelayed MessagesConsistency and ReliabilitySystem SignalsReply DepositUpload ProgramProgram RentProgram TestingTesting with gtestTesting with gclientSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksDeveloping Smart ContractsTesting with gtestOn this pageTesting with gtest
gtest simulates a real network by providing mockups of the user, program, balances, mailbox, etc. Since it does not include parts of the actual blockchain, it is fast and lightweight. But being a model of the blockchain network, gtest cannot be a complete reflection of the latter.
As we said earlier, gtest is excellent for unit and integration testing. It is also helpful for debugging Gear program logic. Nothing other than the Rust compiler is required for running tests based on gtest. It is predictable and robust when used in continuous integration.
Import gtest lib​
To use the gtest library, you must import it into your Cargo.toml file in the [dev-dependencies] block to fetch and compile it for tests only:
[package]name = "first-gear-app"version = "0.1.0"authors = ["Your Name"]edition = "2021"[dependencies]gstd = { git = "https://github.com/gear-tech/gear.git", tag = "v1.0.2" }[build-dependencies]gear-wasm-builder = { git = "https://github.com/gear-tech/gear.git", tag = "v1.0.2" }[dev-dependencies]gtest = { git = "https://github.com/gear-tech/gear.git", tag = "v1.0.2" }
gtest capabilities​

Initialization of the common environment for running smart contracts:

    // This emulates node's and chain's behavior.    //    // By default, sets:    // - current block equals 0    // - current timestamp equals UNIX timestamp of your system.    // - minimal message id equal 0x010000..    // - minimal program id equal 0x010000..    let sys = System::new();

Program initialization:

    // Initialization of program structure from file.    //    // Takes as arguments reference to the related `System` and the path to wasm binary relatively    // the root of the crate where the test was written.    //    // Sets free program id from the related `System` to this program. For this case it equals 0x010000..    // Next program initialized without id specification will have id 0x020000.. and so on.    let _ = Program::from_file(        &sys,        "./target/wasm32-unknown-unknown/release/demo_ping.wasm",    );    // Also, you may use the `Program::current()` function to load the current program.    let _ = Program::current(&sys);    // We can check the id of the program by calling `id()` function.    //    // It returns `ProgramId` type value.    let ping_pong_id = ping_pong.id();    // There is also a `from_file_with_id` constructor to manually specify the id of the program.    //    // Every place in this lib, where you need to specify some ids,    // it requires generic type 'ID`, which implements `Into<ProgramIdWrapper>`.    //    // `ProgramIdWrapper` may be built from:    // - u64;    // - [u8; 32];    // - String;    // - &str;    // - ProgramId (from `gear_core` one's, not from `gstd`).    //    // String implementation means the input as hex (with or without "0x")    // Numeric    let _ = Program::from_file_with_id(        &sys,        105,        "./target/wasm32-unknown-unknown/release/demo_ping.wasm",    );    // Hex with "0x"    let _ = Program::from_file_with_id(        &sys,        "0xe659a7a1628cdd93febc04a4e0646ea20e9f5f0ce097d9a05290d4a9e054df4e",        "./target/wasm32-unknown-unknown/release/demo_ping.wasm",    );    // Hex without "0x"    let _ = Program::from_file_with_id(        &sys,        "e659a7a1628cdd93febc04a4e0646ea20e9f5f0ce097d9a05290d4a9e054df5e",        "./target/wasm32-unknown-unknown/release/demo_ping.wasm",    );    // Array [u8; 32] (e.g. filled with 5)    let _ = Program::from_file_with_id(        &sys,        [5; 32],        "./target/wasm32-unknown-unknown/release/demo_ping.wasm",    );    // If you initialize program not in this scope, in cycle, in other conditions,    // where you didn't save the structure, you may get the object from the system by id.    let _ = sys.get_program(105);

Getting the program from the system:

    // If you initialize program not in this scope, in cycle, in other conditions,    // where you didn't save the structure, you may get the object from the system by id.    let _ = sys.get_program(105);

Initialization of styled env_logger:

    // Initialization of styled `env_logger` to print logs (only from `gwasm` by default) into stdout.    //    // To specify printed logs, set the env variable `RUST_LOG`:    // `RUST_LOG="target_1=logging_level,target_2=logging_level" cargo test`    //    // Gear smart contracts use `gwasm` target with `debug` logging level    sys.init_logger();

Sending messages:

    To send message to the program need to call one of two program's functions:    // `send()` or `send_bytes()` (or `send_with_value` and `send_bytes_with_value` if you need to send a message with attached funds).    //    // Both of the methods require sender id as the first argument and the payload as second.    //    // The difference between them is pretty simple and similar to `gstd` functions    // `msg::send()` and `msg::send_bytes()`.    //    // The first one requires payload to be CODEC Encodable, while the second requires payload    // implement `AsRef<[u8]>`, that means to be able to represent as bytes.    //    // `send()` uses `send_bytes()` under the hood with bytes from payload.encode().    //    // First message to the initialized program structure is always the init message.    let res = program.send_bytes(100001, "INIT MESSAGE");

Processing the result of the program execution:

    // Any sending functions in the lib returns `RunResult` structure.    //    // It contains the final result of the processing message and others,    // which were created during the execution.    //    // It has 4 main functions.    // Returns the reference to the Vec produced to users messages.    // You may assert them as you wish, iterating through them.    assert!(res.log().is_empty());    // Returns bool which shows that there was panic during the execution    // of the main message.    assert!(!res.main_failed());    // Returns bool which shows that there was panic during the execution    // of the created messages during the main execution.    //    // Equals false if no others were called.    assert!(!res.others_failed());    // Returns bool which shows that logs contain a given log.    //    // Syntax sugar around `res.log().iter().any(|v| v == arg)`.    assert!(!res.contains(&Log::builder()));    // To build a log for assertion you need to use `Log` structure with its builders.    // All fields here are optional.    // Assertion with Logs from core are made on the Some(..) fields    // You will run into panic if you try to set the already specified field.    //    // Constructor for success log.    let _ = Log::builder();    // Constructor for error reply log.    //    // Note that error reply never contains payload.    // And its exit code equals 1, instead of 0 for success replies.    let _ = Log::error_builder();    // Let’s send a new message after the program has been initialized.    // The initialized program expects to receive a byte string "PING" and replies with a byte string "PONG".    let res = ping_pong.send_bytes(100001, "PING");    // Other fields are set optionally by `dest()`, `source()`, `payload()`, `payload_bytes()`.    //    // The logic for `payload()` and `payload_bytes()` is the same as for `send()` and `send_bytes()`.    // First requires an encodable struct. The second requires bytes.    let log = Log::builder()        .source(ping_pong_id)        .dest(100001)        .payload_bytes("PONG");    assert!(res.contains(&log));    let wrong_log = Log::builder().source(100001);    assert!(!res.contains(&wrong_log));    // Log also has `From` implementations from (ID, T) and from (ID, ID, T),    // where ID: Into<ProgramIdWrapper>, T: AsRef<[u8]>    let x = Log::builder().dest(5).payload_bytes("A");    let x_from: Log = (5, "A").into();    assert_eq!(x, x_from);    let y = Log::builder().dest(5).source(15).payload_bytes("A");    let y_from: Log = (15, 5, "A").into();    assert_eq!(y, y_from);    assert!(!res.contains(&(ping_pong_id, ping_pong_id, "PONG")));    assert!(res.contains(&(1, 100001, "PONG")));

Spending blocks:

    // You may control time in the system by spending blocks.    //    // It adds the amount of blocks passed as arguments to the current block of the system.    // Same for the timestamp. Note, that for now 1 block in Gear network is 1 sec duration.    sys.spend_blocks(150);

Balance:

    // If you need to send a message with value you have to mint balance for the message sender:    let user_id = 42;    sys.mint_to(user_id, 5000);    assert_eq!(sys.balance_of(user_id), 5000);    // To give the balance to the program you should use `mint` method:    let prog = Program::current(&sys);    prog.mint(1000);    assert_eq!(prog.balance(), 1000);Edit this pagePreviousProgram TestingNextTesting with gclientImport gtest libgtest capabilities








Testing with gclient | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable 🚧StableEnglishEnglish简体中文SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsIntroductionGear LibraryMailboxState FunctionsMetadataData Encoding/DecodingAsynchronous ProgrammingCreate ProgramGas ReservationDelayed MessagesConsistency and ReliabilitySystem SignalsReply DepositUpload ProgramProgram RentProgram TestingTesting with gtestTesting with gclientSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksDeveloping Smart ContractsTesting with gclientOn this pageTesting with gclient
gclient is intended to be used as a tool for testing Gear programs with a real blockchain network. It allows you to send extrinsics and RPCs by connecting to the network. We recommend using gclient for end-to-end testing to ensure the program works as expected in the real blockchain world.
It is essential to underline that testing with gclient requires the running node as the second part of the test suite. The gclient interacts with the node over the WebSocket protocol. Depending on the purpose of testing, gclient can communicate with either a local or a remote node. The best choice is to use the local node in developer mode for initial debugging and continuous integration.
Testing with gclient is slower than gtest and produces more build artifacts, so it is better suited as the last mile in quality control. However, gclient gives the most accurate test results.
Import gclient lib​
To use the gclient library, you must import it into your Cargo.toml file in the [dev-dependencies] block. Also, you need to add some external crates that are used together with gclient:
[package]name = "first-gear-app"version = "0.1.0"authors = ["Your Name"]edition = "2021"[dependencies]gstd = { git = "https://github.com/gear-tech/gear.git", tag = "v1.0.2", features = ["debug"] }[build-dependencies]gear-wasm-builder = { git = "https://github.com/gear-tech/gear.git", tag = "v1.0.2" }[dev-dependencies]gclient = { git = "https://github.com/gear-tech/gear.git", tag = "v1.0.2" }tokio = { version = "1", features = ["full"] }
Running the node​
The best way is to download the latest node binary for your operating system from https://get.gear.rs. Then unpack the package and run the node. Here and below, we assume the node is running in developer mode.
Windows x64MacOS ARMMacOS x64Linux x64curl -O https://get.gear.rs/gear-nightly-x86_64-pc-windows-msvc.ziporWindows x64: gear-nightly-x86_64-pc-windows-msvc.zipUnzip the downloaded package, then run:gear.exe --devTerminal:wget https://get.gear.rs/gear-nightly-aarch64-apple-darwin.tar.xz && \tar xvf gear-nightly-aarch64-apple-darwin.tar.xz && \rm gear-nightly-aarch64-apple-darwin.tar.xzRun the node in development mode:./gear --devTerminal:wget https://get.gear.rs/gear-nightly-x86_64-apple-darwin.tar.xz && \tar xvf gear-nightly-x86_64-apple-darwin.tar.xz && \rm gear-nightly-x86_64-apple-darwin.tar.xzRun the node in development mode:./gear --devTerminal:wget https://get.gear.rs/gear-nightly-x86_64-unknown-linux-gnu.tar.xz && \tar xvf gear-nightly-x86_64-unknown-linux-gnu.tar.xz && \rm gear-nightly-x86_64-unknown-linux-gnu.tar.xzRun the node in development mode:./gear --dev
Open the second terminal window and run tests using cargo as it was described in the previous section.
Simple example​
Let's add an end-to-end test to our first-gear-app introduced in the Getting Started section.
Add the tests directory next to the src directory and create the end2end.rs file in it.
└── first-gear-app    ├── Cargo.toml    ├── src    │   └── lib.rs    └── tests        └── end2end.rs
end2end.rs:
use gclient::{EventProcessor, GearApi, Result};const WASM_PATH: &str = "./target/wasm32-unknown-unknown/release/first_gear_app.opt.wasm";#[tokio::test]#[ignore]async fn test_example() -> Result<()> {    // Create API instance    let api = GearApi::dev().await?;    // Subscribe to events    let mut listener = api.subscribe().await?;    // Check that blocks are still running    assert!(listener.blocks_running().await?);    // Calculate gas amount needed for initialization    let gas_info = api        .calculate_upload_gas(            None,            gclient::code_from_os(WASM_PATH)?,            vec![],            0,            true,            None,        )        .await?;    // Upload and init the program    let (message_id, program_id, _hash) = api        .upload_program_bytes_by_path(            WASM_PATH,            gclient::now_micros().to_le_bytes(),            vec![],            gas_info.min_limit,            0,        )        .await?;    assert!(listener.message_processed(message_id).await?.succeed());    let payload = b"PING".to_vec();    // Calculate gas amount needed for handling the message    let gas_info = api        .calculate_handle_gas(None, program_id, payload.clone(), 0, true, None)        .await?;    // Send the PING message    let (message_id, _hash) = api        .send_message_bytes(program_id, payload, gas_info.min_limit, 0)        .await?;    assert!(listener.message_processed(message_id).await?.succeed());    Ok(())}
Run the following command and wait for all tests to be green:
cargo test --release -- --include-ignored
It's recommended to mark with the #[ignore] attribute tests with gclient to separate their slow execution from the rest. To execute ignored tests with Cargo, add the --include-ignored flag after a double dash (--) as shown above.
Let's explore what we've done in the test function above.
Firstly, we instantiate the API that allows interaction with the node by calling correspondent extrinsics. Then we create an event listener, as getting the feedback from the node is possible only by subscribing to events. We use the API instance both for invoking RPC calls (e.g., calculating the gas amount needed for processing) and sending extrinsics (e.g., uploading the program and sending a message). Events listener allows us to get the result of operation.
More details about gclient​
Please refer to the gclient docs for more information about its capabilities and use cases.Edit this pagePreviousTesting with gtestNextPrerequisitesImport gclient libRunning the nodeSimple exampleMore details about gclient








How to create an account | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable 🚧StableEnglishEnglish简体中文SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAIDEA OverviewAccountCreate AccountSS58 account formatGear-JSGeneral topicsGear-based NetworksGear IDEAAccountCreate AccountOn this pageHow to create an account
Key information and security​
Account represents an identity - typically a person or an organization, that is capable of making transactions or holding funds. Users can upload smart-contracts and interact with them through transactions in blockchain networks built on top of Gear Protocol. To make this happen, users need to connect a Substrate account. Gear Idea portal can work with Substrate accounts in any connected Gear-powered networks. Moreover this account can be used for holding funds and making transactions in any network of the Dotsama ecosystem and even more.
There are several ways to create a Substrate account, depending on whether you are using a desktop or a mobile device.
There are two main features that make up an account - an address and a key:

An address is the public aspect of the account. This is essentially a location that can be shared with others in order to send transactions to and from.
A key is the private part of the account. This is what enables you as an account owner to access the address. The only way to access your account is via your private key (using the mnemonic phrase, seed, or your account's JSON file and a password).

Storing your accounts​
tipSeed phraseYour seed or mnemonic phrase is the key to your account. If you lose seed you will lose access to your account. We recommend that you store your seed in secure places like encrypted hard drives, non-digital devices or ideally, paper. Never share your private key with anyone.
tipJSON fileJSON file is a backup of your account encrypted with a password. By using JSON, you can import/ restore your account in any wallet. Without a password, you will not be able to restore access to your account. If you use JSON, store the file and passwords in a safe place.
How to create account​
Via Talisman Wallet​
Talisman is a popular and user-friendly wallet for creating and managing Substrate accounts. Being connected to web3 applications across various networks, Talisman browser extension allows to store, send and receive assets.


Install Talisman extension for your browser here


Open the extension by clicking on the logo in the menu bar.


In the opened application, click "New wallet":




Enter a strong password:


And that's it. Your wallet has been created:

Via Subwallet​
Subwallet is another advanced wallet for managing Substrate as well as EVM accounts.


To install Subwallet follow this link


Open Subwallet by clicking on its logo in the browser menu bar.


Click "Create new account":




Select the type of account you want to create (Subwallet allows you to create Substrate-like and Ethereum accounts at once). Copy your seed phrase and keep it in the same place:



Provide your password in the next step. And click "Add the account with the generated seed"


Congratulations, your wallet has been successfully created!
Via Polkadot.js browser extension​
The polkadot.js browser extension is the original application created by Parity Technologies for managing Substate accounts. This method involves installing the polkadot.js plugin and using it as a "virtual vault" that's separate from your browser to store your private keys and sign transactions.

You can install the extension via the following links.

Install on Chromium-based browser.
Install on FireFox.


Open the extension by clicking on the logo in the menu bar


Click the large plus button to create a new account. Alternatively, you can navigate to the smaller plus icon in the top right and select "Create New Account".


img alt

Save the seed phrase in a safe place using the security advices at the beginning of this article.



Specify the name of your account and a strong password for making transactions. Click "Add the account with the generated seed".


noteThe password that you choose here will be used to encrypt this account's information. You will need to re-enter it when attempting to process any kind of outgoing transaction, or when using it to cryptographically sign a message. This password is stored locally on the browser extension.
You've now successfully created a new account using the polkadot.js browser extension.
Via mobile app​
If you need access to your accounts on a mobile device, then you can use the following mobile wallets for the Polkadot/Kusama ecosystem:


All supported wallets you can check here.
Via console​
If you have Gear node installed, you can generate a new seed phrase using the command:
./gear key generate | grep phrase
And then import the generated seed phrase into any convenient wallet.
Frequently Asked Questions​
Is this account portable?​

Yes, you can access your account on a different device or wallet of your choice as long as you have the account's seed
phrase or JSON file associated with the account.

Can I transact directly in the polkadot.js browser extension?​

There isn't functionality to make transactions directly in the polkadot.js browser extension.
To make transactions, you need to launch Gear Idea on your browser.
Before you can make any transactions, you have to allow Gear Idea to access your account.
The browser extension is what holds your account information. You choose which websites get to access this information.
Edit this pagePreviousIDEA OverviewNextSS58 account formatKey information and securityStoring your accountsHow to create accountVia Talisman WalletVia SubwalletVia Polkadot.js browser extensionVia mobile appVia consoleFrequently Asked Questions








What is DeFi? | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable 🚧StableEnglishEnglish简体中文SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsWeb3dAppsSmart ContractsDeFiNFTDAOGear-based NetworksGeneral topicsDeFiWhat is DeFi?
Decentralized finance is a collection of financial services that are an alternative to the current financial system.
While the traditional financial sector is opaque, tightly controlled and outdated, DeFi empowers individuals by providing them with more personal control over their finances. DeFi applications enable individuals to borrow, save, invest and trade without having to rely on third parties like banks, exchanges or lending institutions. It’s able to do this because it’s built on blockchain technology, making use of cryptocurrencies and smart contracts which can execute transactions automatically and instantaneously.
DeFi solves many problems within the traditional financial system. For a start, it makes financial services more accessible and inclusive. This is significant because it enables over 1.7 billion people, who were previously excluded, to have access to a safe and secure financial industry.
On top of that, DeFi is much faster and more efficient than traditional financial services because applications are powered by smart contracts. This removes the requirement for intermediaries, which removes a lot of the incurred costs associated with financial services.
DeFi applications can be accessed 24/7, anywhere in the world, meaning that individuals are not limited to operating on and at specific dates and times or in specific time zones.Edit this pagePreviousSmart ContractsNextNFT








What are NFTs? | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable 🚧StableEnglishEnglish简体中文SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsWeb3dAppsSmart ContractsDeFiNFTDAOGear-based NetworksGeneral topicsNFTWhat are NFTs?
A Non-Fungible Token (NFT) is a unique type of cryptographic token that enables the tokenization of unique units of data to be stored on a blockchain.
NFTs can essentially represent anything that is unique, with their most common use case today being tokens that represent digital artwork.
However, contrary to many beliefs, NFT’s use cases do not stop at verifying true authenticity and ownership of artwork alone.
NFTs can represent anything that is not fungible. This means that anything with unique properties now has a way to be cryptographically represented in order to be stored on a blockchain to benefit from its unique features.
NFTs can be used to represent anything from the deeds to a house to a receipt for a product or service.
In the future, it’s likely that all unique units of data will be represented as NFTs in one way or another because they’re securer ways of storing valuable data and they’re extremely accessible, which makes traditionally illiquid assets much more liquid.Edit this pagePreviousDeFiNextDAO








Gear React-hooks | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable 🚧StableEnglishEnglish简体中文SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGetting StartedKeyringCalculate GasUpload ProgramPay Program rentUpload CodeSend MessageRead StateVouchersMetadata & Type CreationMailboxEventsCookbookGear-JS toolsGear React application templateMeta CLIReact-hooksGeneral topicsGear-based NetworksGear-JSGear-JS toolsReact-hooksOn this pageGear React-hooks
Hooks allow functional components to have access to programs running on Gear networks and significantly simplify the development of front-end applications.
For example, refer to this article that demonstrates the creation of a React application that connects to an NFT smart contract running on the blockchain.
Installation​
npm install @gear-js/react-hooks
or
yarn add @gear-js/react-hooks
Getting started​
Simple as it is, here's a quick example:
import { useReadFullState } from '@gear-js/react-hooks';import { useMetadata } from './use-metadata'import meta from 'assets/meta/meta.txt';function State() {  const programId = '0x01';  const { metadata } = useMetadata(meta);  const { state } = useReadFullState(programId, meta);  return <div>{JSON.stringify(state)}</div>;}export { State };
Cookbook​
infoIn order for these hooks to work, the application must be wrapped in the appropriate Providers. As it is presented in the example. If you use create-gear-app, then all the necessary environment has already been provided.
useApi​
useApi provides access to the Gear API connected to the selected RPC-node.
import { useApi } from '@gear-js/react-hooks';const { api, isApiReady } = useApi();
useAccount​
useAccount provides interaction with Polkadot-js extension API, allows to manage accounts from it (for example to sign transactions).
import { useAccount } from '@gear-js/react-hooks';const { account, isAccountReady } = useAccount();
useAlert​
useAlert shows any alert in the application context.
import { useAlert } from '@gear-js/react-hooks';const alert = useAlert();// type?: 'info' | 'error' | 'loading' | 'success';alert.success('success message')
useMetadata​
This hook is auxiliary and it is not pre-installed in the react-hook library. useMetadata allows converting the program's metadata (.txt file) into the required format.
import { useEffect, useState } from 'react';import {  getProgramMetadata,  ProgramMetadata} from '@gear-js/api';import { Buffer } from 'buffer';export const useMetadata = (source: RequestInfo | URL) => {  const [data, setData] = useState<ProgramMetadata>();  useEffect(() => {    fetch(source)      .then((res) => res.text())      .then((raw) => getProgramMetadata(`0x${raw}`))      .then((meta) => setData(meta));  }, [source]);  return { metadata: data };};
useWasmMetadata​
This hook is auxiliary and it is not pre-installed in the react-hook library. useWasmMetadata allows getting Buffer array from the program meta.wasm. Buffer is required always when using custom functions to query specific parts of the program State.
import { useEffect, useState } from 'react';import { Buffer } from 'buffer';export const useWasmMetadata = (source: RequestInfo | URL) => {  const [data, setData] = useState<Buffer>();  useEffect(() => {    if (source) {      fetch(source)        .then((response) => response.arrayBuffer())        .then((array) => Buffer.from(array))        .then((buffer) => setData(buffer))        .catch(({ message }: Error) => console.error(`Fetch error: ${message}`));    }    // eslint-disable-next-line react-hooks/exhaustive-deps  }, [source]);  return { buffer: data };};
useSendMessage​
useSendMessage allows sending messages to the program.
import { useSendMessage } from '@gear-js/react-hooks';import { useMetadata } from './useMetadata';import meta from 'assets/meta/meta.txt';function sendMessage() {  const programId = '0x01';  const { metadata } = useMetadata(meta);  return useSendMessage(programId, metadata);}
useReadFullState​
useReadFullState allows reading full program State.
import { useReadFullState } from '@gear-js/react-hooks';import { useMetadata } from './useMetadata';import meta from 'assets/meta/meta.txt';function readFullState() {  const programId = '0x01';  const { metadata } = useMetadata(meta);  const { state } = useReadFullState(programId, metadata);  return state;}
useReadWasmState​
useReadWasmState allows reading program State using specific functions.
import { useReadWasmState } from '@gear-js/react-hooks';import { useWasmMetadata } from './useMetadata';import stateMetaWasm from 'assets/wasm/state.meta.wasm';function useProgramState<T>(functionName: string, payload?: any) {  const programId = '0x01';  const { buffer } = useWasmMetadata(stateMetaWasm);  return useReadWasmState<T>(    programId,    buffer,    functionName,    payload,  );}function firstState() {  const payload = 'some_payload'  const { state } = useProgramState('foo_1', payload);  return state;}function secondState() {  // if program state function doesn't have initial payload  const { state } = useProgramState('foo_2', null);  return state;}
useCreateHandler​
useCreateHandler provides a tool for uploading the Gear program to the chain.
import { useCreateHandler } from '@gear-js/react-hooks';import meta from 'assets/meta/meta.txt';import { useMetadata } from './useMetadata';export function useCreateProgram(onSuccess: (programId: Hex) => void) {  const codeHash = '0x01';  const { metadata } = useMetadata(meta);  const createProgram = useCreateHandler(codeHash, meta);  return (payload) => createProgram(payload, { onSuccess });}Edit this pagePreviousMeta CLINextWeb3InstallationGetting startedCookbookuseApiuseAccountuseAlertuseMetadatauseWasmMetadatauseSendMessageuseReadFullStateuseReadWasmStateuseCreateHandler








Actor 模型 | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())跳到主要内容Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContribute下一页Unstable 🚧下一页简体中文English简体中文搜索欢迎Intro to Gear Protocol术语表我们为什么创建 Gear？Gear 的独特性Gear Protocol TechnologyActor 模型SubstrateWebAssembly (Wasm)持久化内存Gear 网络状态状态转移5 分钟快速入门Gear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksIntro to Gear ProtocolGear Protocol TechnologyActor 模型本页总览Actor 模型
在并行计算系统中，“消息通信”方法意味着程序通过消息交换进行通信。它比“共享内存通信”更具有优势。消息传递并发比共享内存并发更容易理解。它通常被认为更健壮，比共享内存具有更好的性能。
对于进程间通信，Gear 使用 Actor 模型方案。Actor 模型的原则是，程序从不共享任何状态，只是在彼此之间交换信息。
通过 Actor 模型，系统由同时运作的对象组成，这些对象之间完全通过消息传递进行交流。虽然普通的 Actor 模型不保证消息的顺序，但 Gear 提供了一些额外的保证，即两个特定程序之间的消息的顺序被保留下来。
在 Actor 模型中，一个系统由同时运作的功能对象组成，这些对象之间完全通过消息传递进行通信。虽然一般 Actor 模型并不保证消息的顺序，但 Gear 提供了一些额外的保证，即两个特定程序之间的消息顺序被保存下来。
Actor 模型保障了高可扩展性和高容错性。
Actor​
Actor 模型中的 Actor 是可以发送和接收消息的原子计算单元。在 Gear 中，Actor 是一个程序 (智能合约) 或向程序发送消息的用户。每个 Actor 都有一个内部私有状态和一个信箱。通信是异步的，消息从信箱中弹出并分配给消息处理流，在那里按周期处理。
当一个 Actor 收到并处理一个消息时，可以响应以下内容：

向另一个 Actor 发送消息
创建另一个 Actor
改变自己的内部状态

Actor 是独立的，它们从不分享任何状态，只是相互交换信息。
使用 Actor 模型方案提供了一种在程序（智能合约）逻辑中实现基于 Actor 的并发性的方法。它可以利用各种语言构造进行异步编程（Rust 中的 Futures 和 async-await）。
Async/await 支持​
与类不同，actor 一次只允许一个任务访问它们的可变状态，这使得多个任务中的代码可以安全地与同一个 actor 实例交互。
异步函数大大简化了并发管理，但它们无法处理死锁或状态损坏的情况。为了避免死锁或状态损坏，异步函数应该避免调用可能阻塞其线程的函数。为了实现这一点，他们选择使用 await 表达式。
目前，典型的智能合约代码中缺乏对 async/await 模式的支持，这给智能合约开发人员带来了很多问题。实际上，通过手工添加函数（在 Solidity 智能合约中），以在智能合约程序流中实现更好的控制的方式，或多或少是可行的。但是问题在于，一些合约中的函数会让人们很容易混淆在合约生命周期中的哪个阶段可以调用哪个函数。
Gear 为程序提供了通用的 async/await 语法。它极大地简化了开发和测试，并减少了智能合约开发中出错的可能性。如果程序逻辑需要，Gear API 也允许通过简单地不使用 await 表达式来使用同步消息。编辑此页上一页Gear 的独特性下一页SubstrateActorAsync/await 支持








将节点程序配置成 Linux 服务 | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())跳到主要内容Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContribute下一页Unstable 🚧下一页简体中文English简体中文搜索欢迎Intro to Gear Protocol5 分钟快速入门Gear Node配置节点将节点程序配置成服务节点监控备份和恢复开发网络多节点模式常见问题常见错误Developing Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksGear Node将节点程序配置成服务本页总览将节点程序配置成 Linux 服务
前期准备​
你需要依据自己的操作系统下载或者自行编译 gear-node 可执行文件。更多信息。
配置服务​
为了将 Gear 节点程序作为 Linux 的服务，你需要参照以下方式来配置 systemd 文件：
从 root 目录开始：
cd /etc/systemd/systemsudo nano gear-node.service
配置并保存：
[Unit]Description=Gear NodeAfter=network.target[Service]Type=simpleUser=rootWorkingDirectory=/root/ExecStart=/usr/bin/gear --name "NODE_NAME" --telemetry-url "wss://telemetry.rs/submit 0"Restart=alwaysRestartSec=3LimitNOFILE=10000[Install]WantedBy=multi-user.target
备注ExecStart 指向 gear 二进制文件所在的位置。在示例中是在 /usr/bin 目录。
使用 -- 引入额外的启动参数，但这些参数并不是必须的。
运行节点​
到这里我们就可以使用以下命令来启动服务：
sudo systemctl start gear-node
使其能够随系统自动启动：
sudo systemctl enable gear-node
检查 gear-node 服务状态：
sudo systemctl status gear-node
检查日志​
运行以下命令可以查看服务日志：
journalctl -u gear-node
使用导航键浏览日志，使用q键退出。
你可以通过添加参数-n 50来查看最后 50 行日志：
journalctl -u gear-node -n 50
添加-f参数，在连续模式下查看日志的最后一行 (按 Ctrl+C 退出)：
journalctl -u gear-node -fn 50
更新节点版本​
你只需要把节点的可执行文件（gear）替换成最新版本，然后重新启动执行。
例如，如果你的 Linux 可执行文件位于/usr/bin（如我们上面的配置），你要运行：
wget https://get.gear.rs/gear-nightly-x86_64-unknown-linux-gnu.tar.xzsudo tar -xvf gear-nightly-x86_64-unknown-linux-gnu.tar.xz -C /usr/binrm gear-nightly-x86_64-unknown-linux-gnu.tar.xzsudo systemctl restart gear-node
删除节点​
运行以下命令，删除节点的存储、服务配置和可执行文件：
sudo systemctl stop gear-nodesudo systemctl disable gear-nodesudo rm -rf /root/.local/share/gearsudo rm /etc/systemd/system/gear-node.servicesudo rm /usr/bin/gear编辑此页上一页配置节点下一页节点监控前期准备配置服务运行节点检查日志更新节点版本删除节点








运行一个 Gear 开发节点 | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())跳到主要内容Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContribute下一页Unstable 🚧下一页简体中文English简体中文搜索欢迎Intro to Gear Protocol5 分钟快速入门Gear Node配置节点将节点程序配置成服务节点监控备份和恢复开发网络多节点模式常见问题常见错误Developing Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksGear Node开发网络运行一个 Gear 开发节点
开发节点对于开发和调试智能合约非常有用。你可以直接上传程序到本地节点，向程序发送消息，并验证程序的逻辑。
使用开发模式运行 Gear 节点：


按照 https://wiki.gear-tech.io/zh-cn/node/setting-up/ 中的描述，为你的操作系统编译或下载最新构建版本。


使用开发模式运行节点：


./gear --dev


访问 https://idea.gear-tech.io/ 并连接到本地开发节点。通过左上方的按钮点击网络切换，选择 Development -> Local node，然后点击切换按钮。使用 Idea 发送消息，读取程序状态等。


要清除开发链的节点数据，请使用：


./gear purge-chain --dev

要运行一个有详细日志的开发链，请使用：

RUST_LOG=debug RUST_BACKTRACE=1 ./gear -lruntime=debug --dev编辑此页上一页备份和恢复下一页多节点模式








Getting started | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable 🚧StableEnglishEnglish简体中文SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGetting StartedKeyringCalculate GasUpload ProgramPay Program rentUpload CodeSend MessageRead StateVouchersMetadata & Type CreationMailboxEventsCookbookGear-JS toolsGeneral topicsGear-based NetworksGear-JSGetting StartedOn this pageGetting started
Gear-JS API​
The Gear-JS API provides a set of utilities, libraries and tools that enable JavaScript applications to interact with smart contracts running in the Gear network via queries to a Gear node.
Sections below describe tools that you can use in your JS application to implement basic functions such as managing your key pair (account), calculating gas required for network operations, uploading program in the network, sending a message to a program, reading program's state, getting messages from the user's mailbox, working with metadata and more. Some useful code snippets are provided in the Cookbook section.
The basic API is implemented on the Substrate layer and is the same for all Substrate-based networks. The Gear-JS API code is available on GitHub. Complete API overview can be found on the Polkadot documentation portal.
noteSince Vara and Vara Testnet can have different runtime versions, they may have different extrinsic signatures. If your application is operating on the Vara Network, it is more convenient to use the VaraApi class instead of GearApi and VaraTestnetApi for the Vara Testnet Network.
Installation​
npm install @gear-js/api
or
yarn add @gear-js/api
Getting started​
Start the API connection to the local running RPC node:
import { GearApi } from '@gear-js/api';const gearApi = await GearApi.create();
You can also connect to a different node:
const gearApi = await GearApi.create({  providerAddress: 'ws[s]://someIP[:somePort]',});
noteBelow are a few entry points for interact with Gear RPC Node.For connection to local node use:ws://127.0.0.1:9944For connection to Vara Network Testnet use:wss://testnet.vara-network.io
Getting node info
const chain = await gearApi.chain();const nodeName = await gearApi.nodeName();const nodeVersion = await gearApi.nodeVersion();const genesis = gearApi.genesisHash.toHex();
Example​
This simple example describes how to subscribe to a new blocks and get chain spec:
async function connect() {  const gearApi = await GearApi.create({    providerAddress: 'wss://testnet.vara-network.io',  });  const [chain, nodeName, nodeVersion] = await Promise.all([    gearApi.chain(),    gearApi.nodeName(),    gearApi.nodeVersion(),  ]);  console.log(    `You are connected to chain ${chain} using ${nodeName} v${nodeVersion}`,  );  const unsub = await gearApi.gearEvents.subscribeToNewBlocks((header) => {    console.log(      `New block with number: ${header.number.toNumber()} and hash: ${header.hash.toHex()}`,    );  });}connect().catch(console.error);
Also, refer to the article that demonstrates the creation of a React application that connects to an NFT smart contract running on the blockchain.Edit this pagePreviousSS58 account formatNextKeyringGear-JS APIInstallationGetting startedExample








创建一个多节点本地测试网络 | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())跳到主要内容Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContribute下一页Unstable 🚧下一页简体中文English简体中文搜索欢迎Intro to Gear Protocol5 分钟快速入门Gear Node配置节点将节点程序配置成服务节点监控备份和恢复开发网络多节点模式常见问题常见错误Developing Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksGear Node多节点模式创建一个多节点本地测试网络
对于更高级的智能合约调试和测试，更接近真实的网络环境，你可以建立本地测试网，由几个互连的节点组成。这种模式可以看到多节点共识算法的运行情况。
运行具有两个验证节点的本地测试网，分别为 Alice 和 Bob，它们拥有local测试网的初始权限，并被赋予测试网单元，更多细节请看配置。
注意：这将需要两个终端 (每个节点一个)。

首先运行 Alice 节点。下面的命令使用默认的 TCP 端口 (30333)，并指定/tmp/alice 作为链数据库位置。
Alice 的节点 ID 是12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp（传统表示为：QmRpheLN4JWdAnY7HGJfWFNbfkQCb6tFf4vA6hgjMZKrR）；这由 node-key 决定。

./gear \  --base-path /tmp/alice \  --chain=local \  --alice \  --node-key 0000000000000000000000000000000000000000000000000000000000000001 \  --telemetry-url "wss://telemetry.rs/submit 0"
Alice 节点将在 块#0 以空闲模式运行，等待第二个验证节点。
  Gear Node  ✌️ version 0.1.0-6dc8d24edd9  ❤️ by Gear Technologies, 2021-2022  📋 Chain specification: Gear Local Testnet  🏷 Node name: Alice  👤 Role: AUTHORITY  💾 Database: RocksDb at /tmp/alice/chains/gear_local_testnet/db/full  ⛓ Native runtime: gear-610 (gear-1.tx1.au1)  👶 Creating empty BABE epoch changes on what appears to be first startup.  Using default protocol ID "sup" because none is configured in the chain specs  🏷 Local node identity is: 12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp  💻 Operating system: macos  💻 CPU architecture: aarch64  📦 Highest known block at #0  〽️ Prometheus exporter started at 127.0.0.1:9615  Running JSON-RPC HTTP server: addr=127.0.0.1:9933, allowed origins=Some(["http://localhost:*", "http://127.0.0.1:*", "https://localhost:*", "https://127.0.0.1:*", "https://polkadot.js.org"])  Running JSON-RPC WS server: addr=127.0.0.1:9944, allowed origins=Some(["http://localhost:*", "http://127.0.0.1:*", "https://localhost:*", "https://127.0.0.1:*", "https://polkadot.js.org"])  🏁 CPU score: 1020MB/s  🏁 Memory score: 37732MB/s  🏁 Disk score (seq. writes): 1496MB/s  🏁 Disk score (rand. writes): 421MB/s  👶 Starting BABE Authorship worker  💤 Idle (0 peers), best: #0 (0x22c7…6847), finalized #0 (0x22c7…6847), ⬇ 0 ⬆ 0  💤 Idle (0 peers), best: #0 (0x22c7…6847), finalized #0 (0x22c7…6847), ⬇ 0 ⬆ 0  💤 Idle (0 peers), best: #0 (0x22c7…6847), finalized #0 (0x22c7…6847), ⬇ 0 ⬆ 0  💤 Idle (0 peers), best: #0 (0x22c7…6847), finalized #0 (0x22c7…6847), ⬇ 0 ⬆ 0
另外，你可以在监测网站（https://telemetry.rs）的 Gear Local Testnet 标签下找到 Alice 节点名称。

在另一个终端，使用下面的命令，在不同的 TCP 端口（30334）上启动 Bob 的节点，链数据库位置在 /tmp/bob。--bootnodes 选项将使 Bob 节点与 Alice 节点在 TCP 30333 端口连接。

  ./gear \    --base-path /tmp/bob \    --bootnodes /ip4/127.0.0.1/tcp/30333/p2p/12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp \    --chain=local \    --bob \    --port 30334 \    --ws-port 9945 \    --telemetry-url "wss://telemetry.rs/submit 0"
运行第二个验证者节点后，网络开始产生新的区块。
  Gear Node  ✌️ version 0.1.0-6dc8d24edd9  ❤️ by Gear Technologies, 2021-2022  📋 Chain specification: Gear Local Testnet  🏷 Node name: Bob  👤 Role: AUTHORITY  💾 Database: RocksDb at /tmp/bob/chains/gear_local_testnet/db/full  ⛓ Native runtime: gear-610 (gear-1.tx1.au1)  🔨 Initializing Genesis block/state (state: 0xf470…d2dc, header-hash: 0x22c7…6847)  👴 Loading GRANDPA authority set from genesis on what appears to be first startup.  👶 Creating empty BABE epoch changes on what appears to be first startup.  Using default protocol ID "sup" because none is configured in the chain specs  🏷 Local node identity is: 12D3KooWHpsf9Gp59ct6t6d1MmKHxbmZRvSWcUej7cUNmWNBdvZE  💻 Operating system: macos  💻 CPU architecture: aarch64  📦 Highest known block at #0  Running JSON-RPC HTTP server: addr=127.0.0.1:61429, allowed origins=Some(["http://localhost:*", "http://127.0.0.1:*", "https://localhost:*", "https://127.0.0.1:*", "https://polkadot.js.org"])  Running JSON-RPC WS server: addr=127.0.0.1:9945, allowed origins=Some(["http://localhost:*", "http://127.0.0.1:*", "https://localhost:*", "https://127.0.0.1:*", "https://polkadot.js.org"])  🏁 CPU score: 875MB/s  🏁 Memory score: 38353MB/s  🏁 Disk score (seq. writes): 1497MB/s  🏁 Disk score (rand. writes): 421MB/s  👶 Starting BABE Authorship worker  discovered: 12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp /ip4/192.168.1.4/tcp/30333  discovered: 12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp /ip6/::1/tcp/30333  discovered: 12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp /ip4/127.0.0.1/tcp/30333  🙌 Starting consensus session on top of parent 0x22c70bb6baf611e5c9a6b1886b307dfa25cf1972b3400e70eb15d624c8b96847  🎁 Prepared block for proposing at 1 (0 ms) [hash: 0x1f55c4a9daf8c35d4388313ad67deec4ff5e472659e2fec310bd3032bcbdfe71; parent_hash: 0x22c7…6847; extrinsics (2): [0x8bbd…2a85, 0x7d5c…0b86]]  🔖 Pre-sealed block for proposal at 1. Hash now 0xe46f6031bb73710e239665d0da4212fbdcca77d57f9504d357c078f3b315389e, previously 0x1f55c4a9daf8c35d4388313ad67deec4ff5e472659e2fec310bd3032bcbdfe71.  👶 New epoch 0 launching at block 0xe46f…389e (block slot 1667197557 >= start slot 1667197557).  👶 Next epoch starts at slot 1667198157  ✨ Imported #1 (0xe46f…389e)  🙌 Starting consensus session on top of parent 0xe46f6031bb73710e239665d0da4212fbdcca77d57f9504d357c078f3b315389e  🎁 Prepared block for proposing at 2 (0 ms) [hash: 0x66281c25f34157c713876cda6f39324a0da6a9a50c0c32310683bca875c1ab4c; parent_hash: 0xe46f…389e; extrinsics (2): [0xcb81…f7c3, 0x7d5c…0b86]]  🔖 Pre-sealed block for proposal at 2. Hash now 0x2ab179fe98969cab0970df085b86e03dbee33daed527f6595bcdbeffebc64175, previously 0x66281c25f34157c713876cda6f39324a0da6a9a50c0c32310683bca875c1ab4c.  ✨ Imported #2 (0x2ab1…4175)  🙌 Starting consensus session on top of parent 0x2ab179fe98969cab0970df085b86e03dbee33daed527f6595bcdbeffebc64175  🎁 Prepared block for proposing at 3 (0 ms) [hash: 0xb5b9be01adb191671e0421f4673f8bee0751481aaac7ea453d806161e3b46dd7; parent_hash: 0x2ab1…4175; extrinsics (2): [0x7771…de48, 0x7d5c…0b86]]  🔖 Pre-sealed block for proposal at 3. Hash now 0xf2ed128d41d96da623281745555a0fe00a033630aacf57ac02acc31ced267db0, previously 0xb5b9be01adb191671e0421f4673f8bee0751481aaac7ea453d806161e3b46dd7.  ✨ Imported #3 (0xf2ed…7db0)

网络已经启动！如果想停止网络，只需在两个运行会话中按下 Ctrl + C即可。
编辑此页上一页开发网络下一页常见问题








常见错误 | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())跳到主要内容Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContribute下一页Unstable 🚧下一页简体中文English简体中文搜索欢迎Intro to Gear Protocol5 分钟快速入门Gear Node配置节点将节点程序配置成服务节点监控备份和恢复开发网络多节点模式常见问题常见错误Developing Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksGear Node常见错误本页总览常见错误
这里介绍了常见的错误和解决方案。
LOCK 文件不可用​


错误： IO 错误：While lock file /root/.local/share/gear/chains/gear_staging_testnet_v7/db/full/LOCK: Resource temporarily unavailable


解决方式：  你似乎在运行几个 Gear 节点实例。注意，只允许运行一个节点实例。你很可能把节点配置为一个服务，然后从命令行运行第二个实例。你应该停止该服务，或者不要从命令行运行 Gear 节点。


你可以通过运行命令查看当前的节点进程：
ps aux | grep gear
如果你想停止所有的节点进程，可以运行：
pkill -sigint gear
注意，SystemD 服务不能通过上述命令停止。改为运行：
sudo systemctl stop gear-node
启动节点服务时出现意外参数​


错误： Found argument '\' which wasn't expected, or isn't valid in this context


解决方式： gear-node.service 配置文件似乎有错误。某些版本的 SystemD 不接受反斜线字符 (\) 作为分行符。因此，最好将每个配置项写在一行。
请参考 https://wiki.gear-tech.io/node/node-as-service，将节点正确配置为服务。
不要忘记在修复服务配置后重新启动节点：
sudo systemctl daemon-reloadsudo systemctl restart gear-node


损坏的数据库​


错误： Database version cannot be read from existing db_version file


替代错误： Invalid argument: Column families not opened: ..., col2, col1, col0


解决方式： 这个问题的根源是磁盘空间不足。你可以用以下命令检查可用空间。
df -h
此外，你可以检查区块链数据库使用了多少空间。
du -h $HOME/.local/share/gear/chains/gear_staging_testnet_v7/db/full
请参考 系统要求，查看所需的最小磁盘空间。
你需要释放更多的空间，然后裁剪链：
sudo systemctl stop gear-node# Provide more free space on the diskgear purge-chainsudo systemctl start gear-node


节点可执行文件过期​


错误： Verification failed for block <block-id> received from peer <peer-id>


替代错误： runtime requires function imports which are not present on the host


解决方式： 更新   node 到最新版本。


服务被锁定​


错误： Failed to start gear-node.service: Unit gear-node.service is masked.


解决方式： 请检查此链接：https://askubuntu.com/questions/1017311/what-is-a-masked-service

编辑此页上一页常见问题下一页可执行函数LOCK 文件不可用启动节点服务时出现意外参数损坏的数据库节点可执行文件过期服务被锁定








上传程序 | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())跳到主要内容Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContribute下一页Unstable 🚧下一页简体中文English简体中文搜索欢迎Intro to Gear Protocol5 分钟快速入门Gear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JS开始Keyring计算 Gas上传程序Pay Program rent提交代码发送消息读取状态Vouchers元数据 与 Type CreationMailboxEvents示例Gear-JS toolsGeneral topicsGear-based NetworksGear-JS上传程序上传程序
编译为 Wasm 的智能合约可以作为程序上传到 Gear 网络。在上传期间，它在网络中被初始化，以便能够与网络中的其他参与者（程序和用户）发送和接收消息。
const code = fs.readFileSync('path/to/program.wasm');const program = {  code,  gasLimit: 1000000,  value: 1000,  initPayload: somePayload,};try {  const { programId, salt, submitted } = await gearApi.program.upload(    uploadProgram,    meta,  );} catch (error) {  console.error(`${error.name}: ${error.message}`);}try {  await gearApi.program.signAndSend(keyring, (event) => {    console.log(event.toHuman());  });} catch (error) {  console.error(`${error.name}: ${error.message}`);}
备注对于计算init信息处理所需的 gas，应该使用GearApi.program.calculateGas.initUpload()。请看更多相关信息编辑此页上一页计算 Gas下一页Pay Program rent








program-rent | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())跳到主要内容Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContribute下一页Unstable 🚧下一页简体中文English简体中文搜索欢迎Intro to Gear Protocol5 分钟快速入门Gear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JS开始Keyring计算 Gas上传程序Pay Program rent提交代码发送消息读取状态Vouchers元数据 与 Type CreationMailboxEvents示例Gear-JS toolsGeneral topicsGear-based NetworksGear-JSPay Program rentprogram-rentTo pay program rent, use the following JavaScript code:
// program.payRent has params:// programId// blockCount - number of blocks for which we want to extendconst tx = await api.program.payRent('0x...', 100_000);tx.signAndSend(account, (events) => {   events.forEach(({ event }) => console.log(event.toHuman()));});
You can calculate the current rent price using the following code:
const price = api.program.calculatePayRent(blockCount);
If a program was paused and its pages removed from storage, you can restore it using the api.program.resumeSession methods:

init: Start a new session to resume the program.
push: Push a bunch of program pages.
commit: Finish the resume session.

Here's how you can resume a paused program:
const program = await api.programStorage.getProgram(programId, oneBlockBeforePauseHash);const initTx = api.program.resumeSession.init({  programId,  allocations: program.allocations,  codeHash: program.codeHash.toHex(),});let sessionId;initTx.signAndSend(account, ({ events }) => {  events.forEach(({ event: { method, data } }) => {    if (method === 'ProgramResumeSessionStarted') {      sessionId = data.sessionId.toNumber();    }  });});const pages = await api.programStorage.getProgramPages(programId, program, oneBlockBeforePauseHash);for (const memPage of Object.entries(page)) {  const tx = api.program.resumeSession.push({ sessionId, memoryPages: [memPage] });  tx.signAndSend(account);}const tx = api.program.resumeSession.commit({ sessionId, blockCount: 20_000 });tx.signAndSend(account);编辑此页上一页上传程序下一页提交代码








发送消息 | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())跳到主要内容Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContribute下一页Unstable 🚧下一页简体中文English简体中文搜索欢迎Intro to Gear Protocol5 分钟快速入门Gear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JS开始Keyring计算 Gas上传程序Pay Program rent提交代码发送消息读取状态Vouchers元数据 与 Type CreationMailboxEvents示例Gear-JS toolsGeneral topicsGear-based NetworksGear-JS发送消息本页总览发送消息
向程序发送消息：
try {  const message = {    destination: destination, // programId    payload: somePayload,    gasLimit: 100_000_000,    value: 1000,  };  // By default, the payload will be encoded using meta.handle_input type  const submitted = await gearApi.message.submit(message, meta);  // If you need to specify a different handler  // For example  await gearApi.message.submit(message, meta, meta.async_handle_input);} catch (error) {  console.error(`${error.name}: ${error.message}`);}try {  await gearApi.message.signAndSend(keyring, (event) => {    console.log(event.toHuman());  });} catch (error) {  console.error(`${error.name}: ${error.message}`);}
备注在实际情况下，为确保成功处理信息，应通过使用api.program.calculateGas方法来计算处理信息所需的 gas。请看更多相关信息
发送回复信息​
当你需要回复从一个程序收到的信息时，请使用这个例子：
try {  const reply = {    replyToId: messageId,    payload: somePayload,    gasLimit: 10000000,    value: 1000,  };  // In that case, the payload will be encoded using meta.async_handle_input type if it exists, if not it will be used meta.async_init_input  const submitted = await gearApi.reply.submit(reply, meta);  // If you need to specify a handler mannualy  // For example  await gearApi.reply.submit(reply, meta, meta.async_init_input);} catch (error) {  console.error(`${error.name}: ${error.message}`);}try {  await gearApi.reply.signAndSend(keyring, (events) => {    console.log(event.toHuman());  });} catch (error) {  console.error(`${error.name}: ${error.message}`);}编辑此页上一页提交代码下一页读取状态发送回复信息








Basics & Metadata / Type creation | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())跳到主要内容Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContribute下一页Unstable 🚧下一页简体中文English简体中文搜索欢迎Intro to Gear Protocol5 分钟快速入门Gear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JS开始Keyring计算 Gas上传程序Pay Program rent提交代码发送消息读取状态Vouchers元数据 与 Type CreationMailboxEvents示例Gear-JS toolsGeneral topicsGear-based NetworksGear-JS元数据 与 Type Creation本页总览Basics & Metadata / Type creation
元数据实现了客户端（JavaScript 应用程序）和智能合约（Rust 程序）之间的交互。元数据是一种接口映射，可以将一组字节码识别为可理解的结构，并将其排序，并展示出它所要实现的功能。
元数据有两种类型。
ProgramMetadata​
ProgramMetadata 用于编码/解码进出程序的信息，并读取整个程序的 State。在这种情况下，元数据看起来像一个十六进制字符串，并在 Gear 程序编译时自动生成。
要获取程序的元数据，请使用 getProgramMetadata 方法：
import { getProgramMetadata } from '@gear-js/api';const metadata = getProgramMetadata('0x…');// 函数 getProgramMetadata() 以十六进制格式获取程序的元数据// 它返回一个 `ProgramMetadata` 类的对象，其属性 `types` 包含所有程序类型metadata.types.init.input; // 程序初始化的输入信息metadata.types.init.output; // 程序初始化的输出信息 // input/output 可用于程序的所有入口处metadata.types.state; // contains type for decoding state output
StateMetadata​
这是处理元数据最方便的方式。它可以创建任何自定义函数，只查询程序状态的特定部分，而不是读取整个程序的状态。这对于具有大状态的大型程序来说是特别有用的。
为了读取程序 State 的自定义实现，可以调用StateMetadata 函数来获取元数据。该函数将 meta.wasm 作为 Buffer 来读取 State。它返回 StateMetadata 类的对象，该类具有查询程序 State 的功能。
import { getStateMetadata } from '@gear-js/api';const fileBuffer = fs.readFileSync('path/to/state.meta.wasm');const metadata = await getStateMetadata(fileBuffer);metadata.functions; //  是一个对象，其键是函数名称，值是输入/输出类型的对象
元数据类方法​
ProgramMetadata 和 StateMetadata 类都有一些方法，可以帮助了解一个或另一个类型是什么，以及获得类型的名称（因为类型在注册表中以数字表示）。此外，还有一些编码和解码数据的方法。
import { ProgramMetadata } from '@gear-js/api`;const metadata = getProgramMetadata('0x…');// 返回具有此索引的类型的名称metadata.getTypeName(4);// 返回该类型的结构metadata.getTypeDef(4);// 如果需要得到一个带有额外字段（name，type，kind，len）的类型结构，必须传递第二个参数metadata.getTypeDef(4, true);// 返回所有存在于程序注册表中的自定义类型metadata.getAllTypes();// 使用指定类型编码或解码 payloadmetadata.createType(4, { value: 'value' });
Type creation​
关于基本类型和方法的更多信息可以在 Polkadot 的文档中找到。
如果出于某种原因，你需要“手动”创建一个类型来对任何消息体进行编码/解码。
import { CreateType } from '@gear-js/api';// 如果 "TypeName" 已经注册，可以使 用以下方式。更多内容请看 https://polkadot.js.org/docs/api/start/types.create#choosing-how-to-createconst result = CreateType.create('TypeName', somePayload);// Otherwise need to add metadata containing TypeName and all required types // 否则需要添加包含 TypeName 和所有必要类型的元数据const result = CreateType.create('TypeName', somePayload, metadata);
这个函数的结果是 Codec 类型的数据，它有以下方法：
result.toHex(); // - returns a hex represetation of the valueresult.toHuman(); // - returns human-friendly object representation of the valueresult.toString(); //  - returns a string representation of the valueresult.toU8a(); // - encodes the value as a Unit8Arrayresult.toJSON(); // - converts the value to JSON编辑此页上一页Vouchers下一页MailboxProgramMetadataStateMetadata元数据类方法Type creation








示例 | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())跳到主要内容Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContribute下一页Unstable 🚧下一页简体中文English简体中文搜索欢迎Intro to Gear Protocol5 分钟快速入门Gear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JS开始Keyring计算 Gas上传程序Pay Program rent提交代码发送消息读取状态Vouchers元数据 与 Type CreationMailboxEvents示例Gear-JS toolsGeneral topicsGear-based NetworksGear-JS示例本页总览示例
这里收集了一组以问答形式出现的有用的代码片段。
订阅新块​
const unsub = await gearApi.gearEvents.subscribeToNewBlocks((header) => {  console.log(`New block with number: ${header.number.toNumber()} and hash: ${header.hash.toHex()}`);});// Unsubscribeunsub();
获取块数据​
const data = await gearApi.blocks.get(blockNumberOrBlockHash);console.log(data.toHuman());
获取块时间戳​
const ts = await gearApi.blocks.getBlockTimestamp(blockNumberOrBlockHash);console.log(ts.toNumber());
通过块高度得到 blockHash​
const hash = await gearApi.blocks.getBlockHash(blockNumber);console.log(hash.toHex());
通过 blockHash 得到块高度​
const hash = await gearApi.blocks.getBlockNumber(blockHash);console.log(hash.toNumber());
获取所有块的事件​
const events = await gearApi.blocks.getEvents(blockHash);events.forEach((event) => {  console.log(event.toHuman());});
获取所有块的 extrinsics​
const extrinsics = await gearApi.blocks.getExtrinsics(blockHash);extrinsics.forEach((extrinsic) => {  console.log(extrinsic.toHuman());});
Get transaction fee 获取​
const gearApi = await GearApi.create();api.program.submit({ code, gasLimit });// same for gearApi.message, gearApi.reply and othersconst paymentInfo = await gearApi.program.paymentInfo(alice);const transactionFee = paymentInfo.partialFee.toNumber();consolg.log(transactionFee);编辑此页上一页Events下一页创建 Gear App订阅新块获取块数据获取块时间戳通过块高度得到 blockHash通过 blockHash 得到块高度获取所有块的事件获取所有块的 extrinsicsGet transaction fee 获取








Events | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())跳到主要内容Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContribute下一页Unstable 🚧下一页简体中文English简体中文搜索欢迎Intro to Gear Protocol5 分钟快速入门Gear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JS开始Keyring计算 Gas上传程序Pay Program rent提交代码发送消息读取状态Vouchers元数据 与 Type CreationMailboxEvents示例Gear-JS toolsGeneral topicsGear-based NetworksGear-JSEvents本页总览Events
Events are generated for certain operations during execution. The following sections describe events that are part of the default Gear runtime.
To subscribe to all events:
const unsub = await api.query.system.events((events) => {  console.log(events.toHuman());});// Unsubscribeunsub();
Gear Events Types​
MessageQueued​
Summary: When a user successfully sends a message to a program and it gets added to the Gear message queue.
MessageQueued {    /// Generated id of the message.    id: MessageId,    /// Account id of the source of the message.    source: T::AccountId,    /// Program id, who is the message's destination.    destination: ProgramId,    /// Entry point for processing of the message.    /// On the sending stage, the processing function    /// of the program is always known.    entry: MessageEntry,}
UserMessageSent​
Summary: When someone has sent a message to the user.
UserMessageSent {    /// Message sent.    message: UserMessage,    /// Block number of expiration from `Mailbox`.    ///    /// Equals `Some(_)` with block number when message    /// will be removed from `Mailbox` due to some    /// reasons (see #642, #646 and #1010).    ///    /// Equals `None` if message wasn't inserted to    /// `Mailbox` and appears as only `Event`.    expiration: Option<T::BlockNumber>,}
UserMessageRead​
Summary: When a message has been marked as "read" and it has been removed from the Mailbox. This event only affects messages, which were already prior inserted into the Mailbox.
UserMessageRead {    /// Id of the message read.    id: MessageId,    /// The reason for the reading (removal from `Mailbox`).    ///    /// NOTE: See more docs about reasons at `gear_common::event`.    reason: UserMessageReadReason,}
MessagesDispatched​
Summary: The result of when a message is processed within the block.
MessagesDispatched {    /// Total amount of messages removed from message queue.    total: MessengerCapacityOf<T>,    /// Execution statuses of the messages, which were already known    /// by `Event::MessageQueued` (sent from user to program).    statuses: BTreeMap<MessageId, DispatchStatus>,    /// Ids of programs, which state changed during queue processing.    state_changes: BTreeSet<ProgramId>,}
MessageWaited​
Summary: When a message's execution has been delayed and it has been added to the Gear waitlist.
MessageWaited {    /// Id of the message waited.    id: MessageId,    /// Origin message id, which started messaging chain with programs,    /// where currently waited message was created.    ///    /// Used to identify by the user that this message associated    /// with him and the concrete initial message.    origin: Option<GasNodeId<MessageId, ReservationId>>,    /// The reason of the waiting (addition to `Waitlist`).    ///    /// NOTE: See more docs about reasons at `gear_common::event`.    reason: MessageWaitedReason,    /// Block number of expiration from `Waitlist`.    ///    /// Equals block number when message will be removed from `Waitlist`    /// due to some reasons (see #642, #646 and #1010).    expiration: T::BlockNumber,}
MessageWoken​
Summary: When a message is ready to continue its execution and has been removed from the Waitlist.
MessageWoken {    /// Id of the message woken.    id: MessageId,    /// The reason of the waking (removal from `Waitlist`).    ///    /// NOTE: See more docs about reasons at `gear_common::event`.    reason: MessageWokenReason,}
CodeChanged​
Summary: When a program's code has been altered.
CodeChanged {    /// Id of the code affected.    id: CodeId,    /// Change applied on code with current id.    ///    /// NOTE: See more docs about change kinds at `gear_common::event`.    change: CodeChangeKind<T::BlockNumber>,}
ProgramChanged​
Summary: Any data related to program changed.
ProgramChanged {    /// Id of the program affected.    id: ProgramId,    /// Change applied on program with current id.    ///    /// NOTE: See more docs about change kinds at `gear_common::event`.    change: ProgramChangeKind<T::BlockNumber>,}
ProgramResumeSessionStarted​
Summary: Program resume session has been started.
ProgramResumeSessionStarted {  /// Id of the session.  session_id: SessionId,  /// Owner of the session.  account_id: T::AccountId,  /// Id of the program affected.  program_id: ProgramId,  /// Block number when the session will be removed if not finished.  session_end_block: T::BlockNumber}        
Check what the event is​
api.query.system.events((events) => {  events    .filter(({ event }) => api.events.gear.MessageQueued.is(event))    .forEach(({ event: { data } }) => {      console.log(data.toHuman());    });  events    .filter(({ event }) => api.events.balances.Transfer.is(event))    .forEach(({ event: { data } }) => {      console.log(data.toHuman());    });});
Subscribe to specific gear events​
Subscribe to messages sent from a program​
const unsub = api.gearEvents.subscribeToGearEvent(  'UserMessageSent',  ({    data: {      message: { id, source, destination, payload, value, reply },    },  }) => {    console.log(`  messageId: ${id.toHex()}  source: ${source.toHex()}  payload: ${payload.toHuman()}  `);  },);// Unsubscribeunsub();
Subscribe to messages intended for a program​
const unsub = api.gearEvents.subscribeToGearEvent(  'MessageQueued',  ({ data: { id, source, destination, entry } }) => {    console.log({      messageId: id.toHex(),      programId: destination.toHex(),      userId: source.toHex(),      entry: entry.isInit        ? entry.asInit        : entry.isHandle        ? entry.asHandle        : entry.asReply,    });  },);// Unsubscribeunsub();
Subscribe to Transfer events​
const unsub = await api.gearEvents.subscribeToTransferEvents(  ({ data: { from, to, amount } }) => {    console.log(`    Transfer balance:    from: ${from.toHex()}    to: ${to.toHex()}    amount: ${+amount.toString()}    `);  },);// Unsubscribeunsub();
Subscribe to new blocks​
const unsub = await api.gearEvents.subscribeToNewBlocks((header) => {  console.log(    `New block with number: ${header.number.toNumber()} and hash: ${header.hash.toHex()}`,  );});// Unsubscribeunsub();编辑此页上一页Mailbox下一页示例Gear Events TypesMessageQueuedUserMessageSentUserMessageReadMessagesDispatchedMessageWaitedMessageWokenCodeChangedProgramChangedProgramResumeSessionStartedCheck what the event isSubscribe to specific gear eventsSubscribe to messages sent from a programSubscribe to messages intended for a programSubscribe to Transfer eventsSubscribe to new blocks








Gear 库 | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())跳到主要内容Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContribute下一页Unstable 🚧下一页简体中文English简体中文搜索欢迎Intro to Gear Protocol5 分钟快速入门Gear NodeDeveloping Smart Contracts可执行函数Gear 库MailboxState 函数元数据数据序列化/反序列化异步合约创建合约Gas 预留延迟消息一致性和可靠性System Signals部署合约Reply DepositProgram Rent合约测试Testing with gtestTesting with gclientSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksDeveloping Smart ContractsGear 库本页总览Gear 库
Gear Protocol 的库gstd为开发智能合约提供了所有必要和完善的功能和方法。
通过 prelude 导入相似的类型​
gstd的默认 prelude 模块列出了 Rust 自动导入每个程序中的东西。它重新导入了默认的 std 模块和 traits。在 Rust 的 Gear 程序中，std 可以安全地替换为 gstd。
更多详细内容请看 https://docs.gear.rs/gstd/prelude/index.html
消息处理​
Gear Protocol 允许用户和程序通过消息与其他用户和程序进行交互。消息可以包含在payload，它能够在消息执行期间处理。通过模块 msg，我们可以与消息交互：
use gstd::msg;
消息处理只能在定义的函数 init()、handle() 和 hadle_reply() 内进行。它们还定义了处理此类消息的上下文。

获取当前正在处理的消息的 payload 并对其进行解码：

#![no_std]use gstd::{msg, prelude::*};#[no_mangle]extern "C" fn handle() {    let payload_string: String = msg::load().expect("Unable to decode `String`");}

使用payload回复消息：

#![no_std]use gstd::msg;#[no_mangle]extern "C" fn handle() {    msg::reply("PONG", 0).expect("Unable to reply");}

向用户发送消息：

#![no_std]use gstd::{msg, prelude::*};#[no_mangle]extern "C" fn handle() {    // ...    let id = msg::source();    let message_string = "Hello there".to_string();    msg::send(id, message_string, 0).expect("Unable to send message");}
关于 msg 的更多用法，请看 https://docs.gear.rs/gstd/msg/index.html
执行信息​
程序可以通过使用 exec 模块获取有关当前执行上下文的一些有用信息：
use gstd::exec;

在区块时间戳到达指定日期后发送回复消息：

#![no_std]use gstd::{exec, msg};#[no_mangle]extern "C" fn handle() {    // Timestamp is in milliseconds since the Unix epoch    if exec::block_timestamp() >= 1672531200000 {        msg::reply(b"Current block has been generated after January 01, 2023", 0)            .expect("Unable to reply");    }}

获得一个程序的余额：

#![no_std]use gstd::exec;#[no_mangle]extern "C" fn handle() {    // Get self value balance in program    let my_balance = exec::value_available();}
关于 syscalls 的更多用法，请看 https://docs.gear.rs/gstd/exec/index.html
在合约内部进行调试​
宏 gstd::debug 提供在程序执行期间调试合约的能力：
#![no_std]use gstd::{debug, msg, prelude::*};#[no_mangle]extern "C" fn handle() {    let payload_string: String = msg::load().expect("Unable to decode `String`");    debug!("Received message: {payload_string:?}");}编辑此页上一页可执行函数下一页Mailbox通过 prelude 导入相  似的类型消息处理执行信息在合约内部进行调试








存储数据 | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())跳到主要内容Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContribute下一页Unstable 🚧下一页简体中文English简体中文搜索欢迎Intro to Gear Protocol5 分钟快速入门Gear NodeDeveloping Smart Contracts可执行函数Gear 库MailboxState 函数元数据数据序列化/反序列化异步合约创建合约Gas 预留延迟消息一致性和可靠性System Signals部署合约Reply DepositProgram Rent合约测试Testing with gtestTesting with gclientSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksDeveloping Smart ContractsState 函数本页总览存储数据
Gear 智能合约的持久化数据的存储方式与传统程序相同，不需要初始化外部存储。
// ...// describe state structure#[derive(TypeInfo, Decode, Encode, Clone)]pub struct Wallet {    pub id: ActorId,    pub person: String,}// declare and initialize the statestatic mut WALLETS: Vec<Wallet> = Vec::new();
如果用 Rust 或其他面向对象的语言编程，你应该对大多数类型都很熟悉。然而，在 Gear 上开发合约时，ActorId 类型是一个新内容。
信息ActorId 是一个特殊的类型，代表一个 32 字节的数组，并定义了 Gear Protocol 中所有的 ID。
State 函数​
为了显示合约状态信息（类似于view函数），使用 state() 函数。它可以立即读取合约状态（例如，余额）。读取状态是一个免费函数，不需要消耗任何 gas。
要返回 State 使用：
#[no_mangle]extern "C" fn state() {    msg::reply(unsafe { WALLETS.clone() }, 0).expect("Failed to share state");}
默认情况下，state() 函数返合约的整体状态。
自定义程序读取状态​
此外，你可以创建自己的程序来读取状态。这个包装器将允许你为客户端实现自定义函数，而不依赖于  主程序。
这有很多优点，例如，即使程序改变了，也始终能够读取状态（只要输入或输出的类型没有改变）。或者你正在基于一个已经存在的程序创建服务，你需要一些自己的函数来从状态中获得你自己的数据块。
为此，我们需要创建一个独立的程序并在 metawasm 特征中描述必要的功能。例如：
// ...use gmeta::metawasm;#[metawasm]pub trait Metawasm {    type State = Vec<Wallet>;    fn all_wallets(state: Self::State) -> Vec<Wallet> {        state    }    fn first_wallet(state: Self::State) -> Option<Wallet> {        state.first().cloned()    }    fn last_wallet(state: Self::State) -> Option<Wallet> {        state.last().cloned()    }}
更多复杂的例子：
// ...use gmeta::metawasm;#[metawasm]pub trait Metawasm {    type State = Vec<Wallet>;    fn wallet_by_id(id: Id, state: Self::State) -> Option<Wallet> {        state.into_iter().find(|w| w.id == id)    }    fn wallet_by_person(person: String, state: Self::State) -> Option<Wallet> {        state.into_iter().find(|w| w.person == person)    }}
要构建 meta.wasm，需要在项目根目录下设置 build.rs 文件：
fn main() {    gear_wasm_builder::build_metawasm();}
请看更多关于 metadata的内容。编辑此页上一页Mailbox下一页元数据State 函数自定义程序读取状态








Attention developers! | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable 🚧StableEnglishEnglish简体中文SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsIntroductionGear LibraryMailboxState FunctionsMetadataData Encoding/DecodingAsynchronous ProgrammingCreate ProgramGas ReservationDelayed MessagesConsistency and ReliabilitySystem SignalsReply DepositUpload ProgramProgram RentProgram TestingTesting with gtestTesting with gclientSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksDeveloping Smart ContractsIntroductionOn this pageAttention developers!
importantWant to take your blockchain development skills to the next level? Join Gear Academy's free course, "Gear Smart Contract Developer." In this comprehensive course, you'll learn the ins and outs of developing on the Gear Protocol, from deploying programs onto the blockchain and interacting with them, to testing your programs on the Gear Network. You'll also gain hands-on experience navigating the @gear-js library for interacting with contracts on the client side and developing real-world applications, including contracts and frontends. Don't miss this opportunity to become a pro Gear blockchain developer. Enroll now in Gear Academy's "Gear Smart Contract Developer" course!
What is a Gear smart contract?​
Gear smart contract a just a program that runs on the Gear Protocol. It is a piece of code compiled to Wasm that is deployed to the blockchain and can be executed by anyone who sends a message to it. The program can store data, receive and send messages, and perform any other actions that are allowed by the Gear Protocol.
Every program should have a set of exported functions that can be called by the Gear Protocol. These functions are called entry points. The Gear Protocol has a set of predefined entry points that are used to initialize the program, handle incoming messages, and process replies to previously sent messages.
But we can't implement any business logic without using imported functions that form the API for the program. The Gear Protocol has a set of predefined API functions that can be used by any program. There are low-level functions that allow us to load incoming message's payload, send messages, and perform other actions. And there are higher-level libraries that allow us to interact with the Gear Protocol in a more convenient way.
Predefined entry points (exported functions)​
The central exported function of the Gear smart contract is handle(). It is called every time the program receives an incoming message. Below is the Rust example code:
#[no_mangle]extern "C" fn handle() {    // Execute this code during explicitly incoming message}
This function is obligatory to be defined in the program.
In this function, we are to define the main business logic of our program. For example, we can check the incoming message and perform some actions depending on the message type. Also, we can send a message to another program. Finally, we can send a reply to the message that was received by the program.
As with any other program intended to be executed in some environment, Gear smart contract has its own lifecycle. It is initialized, receives messages, and can be terminated. We are to define the optional init() function if we want to perform some actions during the initialization of the program. For example, we can store some data in the program's memory. The init() function is called only once during the program initialization.
#[no_mangle]extern "C" fn init() {    // Execute this code during contract initialization}
If there is no init() function in the program, the program will be initialized without any custom actions.
And the third most important function is handle_reply(). It is called when the program receives a reply to the message that was sent by the program. For example, we can check the reply and perform some actions depending on the reply type.
#[no_mangle]extern "C" fn handle_reply() {    // Execute this code during handling reply on the previously sent message}
There is no need to define the handle_reply() function if the program doesn't intend to receive replies. In this case, the program will ignore all incoming replies.
The reply message is similar to the ordinary message, but it has some differences:

The reply message is sent to the user or program that has sent the original message. We can't set the destination of the reply message explicitly.
We can send only one reply message per execution. We get an error if we try to send more than one reply message.
Even if the program execution is failed (for example, panic is called or the gas limit is exceeded), the reply message will be sent anyway.
The reply message is processed in handle_reply() function instead of handle() function for the ordinary message. We have mentioned this above but it is worth to underline it again.

API functions (imported functions)​
There are a lot of imported functions that can be used by the Gear smart contract. They are called API functions. These functions are provided by the runtime that executes the Gear smart contract. The most convenient way to use these functions is to use the Gear standard library called gstd. It is a set of high-level functions that are implemented on top of the low-level API functions.
More details about the Gear standard library can be found in the Gear Library section.
Basic stages of the Gear smart contract lifecycle​
Let's explore the typical lifecycle of a Gear smart contract. We will use the Rust programming language for the examples, but the same principles are applied to any other language that can be compiled into Wasm.
Step 1. Write the program code.
You can find the minimal example in the Getting Started section. It is a simple program that stores the counter, can increment and decrement it, and return the current value of the counter.
More advanced examples can be found in the Gear Fooundation organization on GitHub: https://github.com/gear-foundation
Step 2. Test the program.
We recommend using the gtest crate for testing Gear smart contracts. It allows us to write unit tests for the program and run them in the local environment.
The more advanced way to test the program is to use the gclient crate that allows you to run the program in the blockchain network. It is useful when you need to test the program in a real environment.
You can find more details about testing in the Program Testing section.
Step 3. Compile the program into Wasm.
We recommend using the gear-wasm-builder crate in a custom build script build.rs.
Add it to the [build-dependencies] section in the Cargo.toml file:
[build-dependencies]gear-wasm-builder = { git = "https://github.com/gear-tech/gear.git", tag = "v1.0.2", features = ["wasm-opt"] }
And add the following code to the build.rs file:
fn main() {    gear_wasm_builder::build();}
You can find built Wasm files in the target/wasm32-unknown-unknown/release directory.
Step 4. Deploy the program to the blockchain.
Program deployment is a process of storing the program's Wasm code on the blockchain and its initialization. The user pays a fee for the deployment transaction. The program is deployed to the blockchain only once. After that, it can be executed by anyone by sending a message to it.
If initialization fails (for example, the program panics in the init() function), the program is not deployed and the user gets an error.
Also, it is important to underline that someone should pay rent for keeping the program in the blockchain after a free period that is equal to 5 million blocks (it is about 2 months for networks with 1 block per second production). It is possible to add funds for rent using the pay_program_rent extrinsic (by the user) or with the gstd::exec::pay_program_rent API function (by the program). If the rent is not paid, the program state changes to pause, its persistent memory is removed from the storage, and the program can't be executed. The program can be resumed by uploading its memory pages to the blockchain and paying the rent.
You can find more details about program deployment in the Upload Program section.
Step 5. Execute the program.
The program can be executed by sending a message to it. The message can be sent by the user or by another program. The user pays a fee for the message execution. The program can send a reply to the message. The reply is sent to the user or program that has sent the original message.
Step 6. Terminate the program.
The program can be terminated by calling the gstd::exec::exit function. Also, the program is paused if the rent is not paid.
The program can't be executed after termination.
Smart contract key features​
Gear smart contracts have a lot of features that make them unique. Let's explore the most important of them.
State function​
Gear smart contracts can store the state in persistent memory. Anyone can read this memory from the blockchain.
To make state reading more convenient, Gear smart contracts can define the state() function.
#[no_mangle]extern "C" fn state() {    msg::reply(any_encodable_data, 0).expect("Failed to share state");}
This function is stored in the blockchain in the same Wasm blob with handle() and init() functions. But unlike them, it is not executed using extrinsic and doesn't affect the blockchain state. It can be executed for free by any node with a fully synchronized blockchain state. There is a dedicated read_state RPC call for this.
The data returned by the state() function can be converted to any convenient representation by using a state-conversion program. This is a separate program compiled into Wasm and dedicated to being executed on the off-chain runner. It should contain a set of meta-functions that accept the data returned by the state() function and return the data in a convenient format. There is a dedicated read_state_using_wasm RPC call for reading the program state using the state-conversion program.
More details about state functions can be found in the State Functions section.
Asynchronous programming​
In some cases, it is more convenient to express some concepts in an asynchronous programming style. For example, when you need to wait for a reply from another program or wait for a certain time.
Under the hood, the async/await syntax is a kind of syntactic sugar that generates a state machine around gstd::exec::wait and gstd::exec::wake functions. The state machine is stored in the program's persistent memory.
Note that in case of using async functions, you are to declare the async main() function with #[async_main] attribute instead of the handle() function:
#[gstd::async_main]async fn main() {    // Async code here}
The initialization function can also be declared as an async function:
#[gstd::async_init]async fn init() {    // Async init code here}
You can find more details about asynchronous programming in the Asynchronous Programming section.
Creating programs from programs​
Both users and programs are actors in terms of the Gear smart contract model. Therefore, any actor can create a new program and deploy it to the blockchain.
The only pre-requisite is that the code of the program should be stored in the blockchain. This can be done by using the upload_code extrinsic that returns an identifier of the uploaded code. The code can be uploaded only once, then it can be used for creating multiple programs.
There are several helper functions for creating programs from programs in the gstd::prog module.
More details about creating programs from programs can be found in the Create Program section.
Gas reservation​
Gear smart contracts use gas for measuring the complexity of the program execution. The user pays a fee for the gas used by the program. Some part of the gas limit may be reserved during the current execution to be spent later. This gas reserving mechanism can be used to shift the burden of paying for program execution from one user to another. Also, it makes it possible to run some deferred actions using delayed messages described below.
You can find more details about gas reservation in the Gas Reservation section.
Delayed messages​
Gear smart contracts can send messages to other actors not only during the current execution but also after some time. This mechanism can be used to implement deferred actions.
Use functions with *_delayed suffix from gstd::msg module to send a delayed message to a program or user. The message will be sent after the specified number of blocks.
More details about delayed messages can be found in the Delayed Messages section.
System signals​
Sometimes the system that executes the program should communicate with it in some manner. For example, the program should be notified when the rent is not paid. This can be done by using system signals.
The handle_signal() function should be declared in the program to handle system signals. It is executed when the program receives a system signal.
 #[no_mangle]extern "C" fn handle_signal() {    // Handle system signal here}
You can find more details about system signals in the System Signals section.
Reply deposit​
Usually the reply sender pays a gas fee for the reply message execution. But sometimes it is more convenient to shift this burden to the program that receives the reply. This can be done by using the reply deposit mechanism.
The reply deposit is a part of the gas limit reserved during the current execution to be spent later. The reserved gas can be used to pay for the reply message execution. To do this, the program should call the gstd::exec::reply_deposit function. This function provides a gas deposit from the current message to handle the reply message on the given message ID. This message ID should be sent within the execution. Once the destination actor or system sends a reply to it, the gas limit ignores it; if the program gives a deposit, only it will be used for the execution of handle_reply.
You can find more details about reply deposit in the Reply Deposit section.Edit this pagePreviousTroubleshootingNextGear LibraryWhat is a Gear smart contract?Predefined entry points (exported functions)API functions (imported functions)Basic stages of the Gear smart contract lifecycleSmart contract key featuresState functionAsynchronous programmingCreating programs from programsGas reservationDelayed messagesSystem signalsReply deposit








数据序列化/反序列化 | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())跳到主要内容Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContribute下一页Unstable 🚧下一页简体中文English简体中文搜索欢迎Intro to Gear Protocol5 分钟快速入门Gear NodeDeveloping Smart Contracts可执行函数Gear 库MailboxState 函数元数据数据序列化/反序列化异步合约创建合约Gas 预留延迟消息一致性和可靠性System Signals部署合约Reply DepositProgram Rent合约测试Testing with gtestTesting with gclientSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksDeveloping Smart Contracts数据序列化/反序列化本页总览数据序列化/反序列化
为了优化数据在网络上的发送和接收方式，Gear 使用parity-scale-codec，这是 SCALE 编解码器的 Rust 实现。这个编解码器被 Substrate 节点的内部 runtime 所使用。SCALE 是一种轻量级的编码格式，能够实现数据的序列化和  反序列化。使用 SCALE 对数据进行编码（和解码），它非常适用于资源受限的执行环境，如区块链运行时间和低功耗、低内存设备。
在程序中使用 SCALE codec，Cargo.toml 需要添加以下内容：
[dependencies]// ...codec = { package = "parity-scale-codec", version = "3.1.2", default-features = false }
use codec::{Decode, Encode};#[derive(Encode, Decode)]enum MyType {    MyStruct { field: ... },    ...}
信息我们只需要在使用 gstd 的包装方法时使用 Encode 和 Decode 特性，例如 msg::send，msg::reply，send_for_reply 等。像 send_byte 或reply_bytes 这样的方法，我们操作的是字节数组，所以不需要进行解码/编码。
更多的内容请看 SCALE Codec。
scale-info​
scale-info 是一个描述 Rust 类型的库， 提供有关可编码 SCALE 类型结构的信息。
这些第三方工具 (例如 UI 客户端) 提供了关于它们如何能够解码不受语言影响的类型的信息。Gear 程序使用 scale-info 的接口称为 metadata。它为所有必要的入口点定义了输入和输出类型，并允许合约和客户端相互理解。
信息如何在合约中使用 metadata，请看链接
在项目中使用 scale-info：
[dependencies]// ...scale-info = { version = "2.1.1", default-features = false, features = ["derive"] }
更多的内容请看 scale-info。编辑此页上一页元数据下一页异步合约scale-info








异步合约 | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())跳到主要内容Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContribute下一页Unstable 🚧下一页简体中文English简体中文搜索欢迎Intro to Gear Protocol5 分钟快速入门Gear NodeDeveloping Smart Contracts可执行函数Gear 库MailboxState 函数元数据数据序列化/反序列化异步合约创建合约Gas 预留延迟消息一致性和可靠性System Signals部署合约Reply DepositProgram Rent合约测试Testing with gtestTesting with gclientSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksDeveloping Smart Contracts异步合约本页总览异步合约
Gear 程序之间的异步交互与通常的异步请求类似，在使用await并通过发送消息来实现。
程序入口​
如果一个程序使用异步信息，它的主要可执行函数就会改变。
async_init()​
如果在程序初始化中存在异步调用，那么我们应该使用 async_init() 而不是 init()。
#[gstd::async_init]async fn init() {    gstd::debug!("Hello world!");}
main()​
对于异步信息也是如此，我们用 main 代替 handle 、handle_reply。
#[gstd::async_main]async fn main() {    gstd::debug!("Hello world!");}
信息async_init 可以和 async_main 一起使用。但如果使用这个宏，就不能指定 init 和 handle_reply 函数。
跨程序消息通讯
要向 Gear 程序发送消息，使用函数 send_for_reply(program, payload, value)，在这个函数中：

program - 发送消息的程序的地址
payload - 程序的消息
value - 附在消息上的资金
reply_deposit - 用于为未来的回复处理提供 gas（如果为零则跳过）

  pub fn send_for_reply_as<E: Encode, D: Decode>(    program: ActorId,    payload: E,    value: u128,    reply_deposit: u64) -> Result<CodecMessageFuture<D>>编辑此页上一页数据序列化/反序列化下一页创建合约程序入口async_init()main()








智能合约自动化延迟消息 | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())跳到主要内容Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContribute下一页Unstable 🚧下一页简体中文English简体中文搜索欢迎Intro to Gear Protocol5 分钟快速入门Gear NodeDeveloping Smart Contracts可执行函数Gear 库MailboxState 函数元数据数据序列化/反序列化异步合约创建合约Gas 预留延迟消息一致性和可靠性System Signals部署合约Reply DepositProgram Rent合约测试Testing with gtestTesting with gclientSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksDeveloping Smart Contracts延迟消息智能合约自动化延迟消息
智能合约在其他区块链上继续运行的通常方式是依靠外部的、中心化的资源。这意味着在被链上交易触发之前，这些合约的代码不会运行并对区块链的状态进行更改。
外部交易作为一个“戳”来激活智能合约并启动其逻辑。例如，我们可以通过向拍卖合约发送一个消息来启动拍卖。当拍卖时间过去后，合约将需要处理拍卖结果。然而，这将不  会发生，直到有人向合同发送适当的消息来触发这一行动。
Gear Protocol 通过引入延迟消息传递功能解决了这个问题。Gear 网络中的智能合约能够执行无限数量的区块，只要有足够的 gas 来执行。gas 预留可以保证这一点。因此，在 dApp 中包含中心化组件的需求被消除了，允许它们完全在链上运行。
msg::send_delayed(program, payload, value, delay)msg::send_bytes_delayed(program, payload, value, delay)
延迟消息将在指定的以块为单位的“延迟”之后执行。例如，在一个生成块时间为 2 秒的网络中，延迟 30 个块等于 1 分钟。
考虑到拍卖的例子，我们可以通过向拍卖合约发送消息来开始拍卖。在完成所有必要的逻辑后，拍卖合同将向自己发送一个延迟消息，这将在指定时间后解决拍卖问题。编辑此页上一页Gas 预留下一页一致性和可靠性








System signals | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())跳到主要内容Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContribute下一页Unstable 🚧下一页简体中文English简体中文搜索欢迎Intro to Gear Protocol5 分钟快速入门Gear NodeDeveloping Smart Contracts可执行函数Gear 库MailboxState 函数元数据数据序列化/反序列化异步合约创建合约Gas 预留延迟消息一致性和可靠性System Signals部署合约Reply DepositProgram Rent合约测试Testing with gtestTesting with gclientSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksDeveloping Smart ContractsSystem SignalsSystem signals
The Gear Protocol ensures system and program's state consistency via introducing special handling mechanisms for potential issues and corner cases.
Gear actors have three common entry points - init, handle, handle_reply. Another special system entry point introduced by the Gear Protocol is handle_signal. It allows the system to communicate with programs if it is necessary to notify (signal) that some event related to the program's messages has happened. Only the system (Gear node runtime) can send signal messages to a program.
First of all, it can be useful to free up resources occupied by the program. A custom async logic in Gear implies storing Futures in a program's memory. The execution context of Futures can occupy some significant amount of memory in the case of many futures. When a program sends a message and waits for a reply to be woken, the reply can not be received. So there might be the case that if the initial message in the waitlist runs out of gas or the gas amount is not enough to properly finish the execution, the program’s state will be rolled back and Future will never be freed.
In this case, Futures remain in memory pages forever. Other messages are not aware of Futures associated with other messages. Over time, Futures accumulate in the program's memory so eventually a large amount of Futures limits the max amount of space the program can use.
In case a message has been removed from the waitlist due to gas constraints, the system sends a system message (signal) that is baked by an amount of reserved gas, which informs the program that it’s message was removed from the waitlist. Based on this info, a program can clean up its used system resources (Futures).
The gstd library provides a separate exec::system_reserve_gas function for reserving gas specifically for system signal messages. It cannot be used for sending other regular cross-actor messages:
exec::system_reserve_gas(1_000_000_000).expect("Error during system gas reservation");
Even if this function hasn't been called, the system will reserve gas for system messages automatically with the default amount of 1_000_000_000.
If a signal message appears, it uses gas specifically reserved for such kinds of messages. If no gas has been reserved for system messages, they are just skipped and the program will not receive them.
If gas has been reserved but no system messages occur during the current execution, then this gas returns back from where it was taken. The same relates to gas reserved for non-system messages - gas returns back after a defined number of blocks or by the program’s command.
handle_signal has a default implementation if the smart contract has async init or/and async main functions (see Asynchronous Programming for more details about async entry points). To define your own signal handler, you need to use the gstd::async_init/gstd::async_main macro with the specified handle_signal argument. For example:
#[gstd::async_main(handle_signal = my_handle_signal)]async fn main() {    // ...}fn my_handle_signal() {    // ...}
信息Note that the custom signal handler derives its default behavior.
Some useful functions that can be used in handle_signal:

msg::signal_from - returns an identifier of the message which caused the signal;
msg::signal_code - returns the reason code of the signal (see SignalCode enum for more details).

It can be useful for a developer when writing communication between programs. Developer can define my_handle_signal function and implement some logic there. For example, Program A sent a message to Program B. Program A is waiting for a reply from Program B but Program B runs out of gas. The current execution will be interrupted, but the system will send a signal to Program A and indicates the message identifier during which the execution was interrupted.
So, Program A sends a message and saves the message identifier:
exec::system_reserve_gas(2_000_000_000)    .expect("Error during system gas reservation");let result = msg::send_for_reply(address, payload, value, reply_deposit);let (msg_id, msg_future) = if let Ok(msg_future) = result {    (msg_future.waiting_reply_to, msg_future)} else {    // handle the error here};// save the `msg_id` in program stateunsafe { STATE.msg_id == msg::id() };let reply = msg_future.await;
The execution fails in Program B, and Program A receives a signal:
#[no_mangle]extern "C" fn my_handle_signal() {    if unsafe { STATE.msg_id == msg::signal_from() } {        // write logic here    }}
However, it is important to understand that the execution of my_handle_signal should not be long and should not consume a lot of gas. It can be used for tracking failures during the transaction. The program can use the information about failures the next time it is executed.
For programs written using the Gear Protocol's gstd library, such signals can be sent to programs automatically under the hood when applicable. If a smart contract developer implements a program using gcore or Gear's syscalls, then such signals should be considered in the program's code explicitly.编辑此页上一页一致性和可靠性下一页部署合约








Reply deposit | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())跳到主要内容Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContribute下一页Unstable 🚧下一页简体中文English简体中文搜索欢迎Intro to Gear Protocol5 分钟快速入门Gear NodeDeveloping Smart Contracts可执行函数Gear 库MailboxState 函数元数据数据序列化/反序列化异步合约创建合约Gas 预留延迟消息一致性和可靠性System Signals部署合约Reply DepositProgram Rent合约测试Testing with gtestTesting with gclientSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksDeveloping Smart ContractsReply DepositReply deposit
When a program or user sends a reply to a message, it should provide gas for the reply handling. The user replies using gear.sendReply extrinsic. The program uses the msg::reply or msg::reply_with_gas function.
Sometimes, it is more convenient to provide gas for the reply handling in advance. For example, if the program sends a message to another program and waits for a reply, it can provide gas for the reply handling in advance. In this case, the program doesn't need to provide gas for the reply handling when it sends a reply.
To provide gas for the reply handling in advance, the program should use the exec::reply_deposit function:
let message_id =    msg::send(msg::source(), b"Outgoing message", 0).expect("Failed to send message");exec::reply_deposit(message_id, 1_000_000_000).expect("Error during reply deposit");#[no_mangle]extern "C" fn handle_reply() {    // The reply handling will be paid with the deposited gas}
The program can deposit gas when using the msg::send_for_reply function by setting the reply_deposit parameter. The reply_deposit parameter is the amount of gas that will be reserved for the reply handling. The reply_deposit parameter is optional. If the reply_deposit parameter is zero, the program should provide gas for the reply handling when it sends a reply.
let message_id = msg::send_for_reply(    msg::source(),    b"Outgoing message",    0,    1_000_000_000,).expect("Failed to send message");#[no_mangle]extern "C" fn handle_reply() {    // The reply handling will be paid with the deposited gas}编辑此页上一页部署合约下一页Program Rent








Program Rent | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())跳到主要内容Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContribute下一页Unstable 🚧下一页简体中文English简体中文搜索欢迎Intro to Gear Protocol5 分钟快速入门Gear NodeDeveloping Smart Contracts可执行函数Gear 库MailboxState 函数元数据数据序列化/反序列化异步合约创建合约Gas 预留延迟消息一致性和可靠性System Signals部署合约Reply DepositProgram Rent合约测试Testing with gtestTesting with gclientSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksDeveloping Smart ContractsProgram Rent本页总览Program Rent
Gear Protocol utilizes a rent-based program management system. When developers upload a program (smart contract) to the network, its expiration date is assigned. The expiration period is measured in blocks.
After the expiration date, the program is automatically removed from storage, unless the owner chooses to extend its life by paying rent. The owner must indicate the number of additional blocks they can pay for, and they need to pay the rent in utility tokens to keep the program active beyond its initial expiration date.
信息Current initial rent period: 5,000,000 blocks (on Vara it will be around 173 days)
After uploading a program, you can observe a similar event:
gear.ProgramChanged
{    "id": "0xde76e4cf663ff825d94944d6f060204e83fbb5e24f8dfdbbdc25842df4f4135d",    "change": {        "Active": {            "expiration": "12,834,248"        }    }}
How to extend the rent of the program?​
To extend the rent period of a program, simply call the special extrinsic gear.payProgramRent(programId, blockCount). See more
Can I restore a deleted program?​
Yes. Since the blockchain stores all states for the entire history, you can restore the program's state to the previous block before it was deleted.
Why does Gear use the program rent system?​

Optimization and efficient resource usage
Stimulating utility token usage
编辑此页上一页Reply Deposit下一页合约测试How to extend the rent of the program?Can I restore a deleted program?Why does Gear use the program rent system?








Testing with gtest | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())跳到主要内容Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContribute下一页Unstable 🚧下一页简体中文English简体中文搜索欢迎Intro to Gear Protocol5 分钟快速入门Gear NodeDeveloping Smart Contracts可执行函数Gear 库MailboxState 函数元数据数据序列化/反序列化异步合约创建合约Gas 预留延迟消息一致性和可靠性System Signals部署合约Reply DepositProgram Rent合约测试Testing with gtestTesting with gclientSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksDeveloping Smart ContractsTesting with gtest本页总览Testing with gtest
gtest simulates a real network by providing mockups of the user, program, balances, mailbox, etc. Since it does not include parts of the actual blockchain, it is fast and lightweight. But being a model of the blockchain network, gtest cannot be a complete reflection of the latter.
As we said earlier, gtest is excellent for unit and integration testing. It is also helpful for debugging Gear program logic. Nothing other than the Rust compiler is required for running tests based on gtest. It is predictable and robust when used in continuous integration.
Import gtest lib​
To use the gtest library, you must import it into your Cargo.toml file in the [dev-dependencies] block to fetch and compile it for tests only:
[package]name = "first-gear-app"version = "0.1.0"authors = ["Your Name"]edition = "2021"[dependencies]gstd = { git = "https://github.com/gear-tech/gear.git", tag = "v1.0.2" }[build-dependencies]gear-wasm-builder = { git = "https://github.com/gear-tech/gear.git", tag = "v1.0.2" }[dev-dependencies]gtest = { git = "https://github.com/gear-tech/gear.git", tag = "v1.0.2" }
gtest capabilities​

Initialization of the common environment for running smart contracts:

    // This emulates node's and chain's behavior.    //    // By default, sets:    // - current block equals 0    // - current timestamp equals UNIX timestamp of your system.    // - minimal message id equal 0x010000..    // - minimal program id equal 0x010000..    let sys = System::new();

Program initialization:

    // Initialization of program structure from file.    //    // Takes as arguments reference to the related `System` and the path to wasm binary relatively    // the root of the crate where the test was written.    //    // Sets free program id from the related `System` to this program. For this case it equals 0x010000..    // Next program initialized without id specification will have id 0x020000.. and so on.    let _ = Program::from_file(        &sys,        "./target/wasm32-unknown-unknown/release/demo_ping.wasm",    );    // Also, you may use the `Program::current()` function to load the current program.    let _ = Program::current(&sys);    // We can check the id of the program by calling `id()` function.    //    // It returns `ProgramId` type value.    let ping_pong_id = ping_pong.id();    // There is also a `from_file_with_id` constructor to manually specify the id of the program.    //    // Every place in this lib, where you need to specify some ids,    // it requires generic type 'ID`, which implements `Into<ProgramIdWrapper>`.    //    // `ProgramIdWrapper` may be built from:    // - u64;    // - [u8; 32];    // - String;    // - &str;    // - ProgramId (from `gear_core` one's, not from `gstd`).    //    // String implementation means the input as hex (with or without "0x")    // Numeric    let _ = Program::from_file_with_id(        &sys,        105,        "./target/wasm32-unknown-unknown/release/demo_ping.wasm",    );    // Hex with "0x"    let _ = Program::from_file_with_id(        &sys,        "0xe659a7a1628cdd93febc04a4e0646ea20e9f5f0ce097d9a05290d4a9e054df4e",        "./target/wasm32-unknown-unknown/release/demo_ping.wasm",    );    // Hex without "0x"    let _ = Program::from_file_with_id(        &sys,        "e659a7a1628cdd93febc04a4e0646ea20e9f5f0ce097d9a05290d4a9e054df5e",        "./target/wasm32-unknown-unknown/release/demo_ping.wasm",    );    // Array [u8; 32] (e.g. filled with 5)    let _ = Program::from_file_with_id(        &sys,        [5; 32],        "./target/wasm32-unknown-unknown/release/demo_ping.wasm",    );    // If you initialize program not in this scope, in cycle, in other conditions,    // where you didn't save the structure, you may get the object from the system by id.    let _ = sys.get_program(105);

Getting the program from the system:

    // If you initialize program not in this scope, in cycle, in other conditions,    // where you didn't save the structure, you may get the object from the system by id.    let _ = sys.get_program(105);

Initialization of styled env_logger:

    // Initialization of styled `env_logger` to print logs (only from `gwasm` by default) into stdout.    //    // To specify printed logs, set the env variable `RUST_LOG`:    // `RUST_LOG="target_1=logging_level,target_2=logging_level" cargo test`    //    // Gear smart contracts use `gwasm` target with `debug` logging level    sys.init_logger();

Sending messages:

    To send message to the program need to call one of two program's functions:    // `send()` or `send_bytes()` (or `send_with_value` and `send_bytes_with_value` if you need to send a message with attached funds).    //    // Both of the methods require sender id as the first argument and the payload as second.    //    // The difference between them is pretty simple and similar to `gstd` functions    // `msg::send()` and `msg::send_bytes()`.    //    // The first one requires payload to be CODEC Encodable, while the second requires payload    // implement `AsRef<[u8]>`, that means to be able to represent as bytes.    //    // `send()` uses `send_bytes()` under the hood with bytes from payload.encode().    //    // First message to the initialized program structure is always the init message.    let res = program.send_bytes(100001, "INIT MESSAGE");

Processing the result of the program execution:

    // Any sending functions in the lib returns `RunResult` structure.    //    // It contains the final result of the processing message and others,    // which were created during the execution.    //    // It has 4 main functions.    // Returns the reference to the Vec produced to users messages.    // You may assert them as you wish, iterating through them.    assert!(res.log().is_empty());    // Returns bool which shows that there was panic during the execution    // of the main message.    assert!(!res.main_failed());    // Returns bool which shows that there was panic during the execution    // of the created messages during the main execution.    //    // Equals false if no others were called.    assert!(!res.others_failed());    // Returns bool which shows that logs contain a given log.    //    // Syntax sugar around `res.log().iter().any(|v| v == arg)`.    assert!(!res.contains(&Log::builder()));    // To build a log for assertion you need to use `Log` structure with its builders.    // All fields here are optional.    // Assertion with Logs from core are made on the Some(..) fields    // You will run into panic if you try to set the already specified field.    //    // Constructor for success log.    let _ = Log::builder();    // Constructor for error reply log.    //    // Note that error reply never contains payload.    // And its exit code equals 1, instead of 0 for success replies.    let _ = Log::error_builder();    // Let’s send a new message after the program has been initialized.    // The initialized program expects to receive a byte string "PING" and replies with a byte string "PONG".    let res = ping_pong.send_bytes(100001, "PING");    // Other fields are set optionally by `dest()`, `source()`, `payload()`, `payload_bytes()`.    //    // The logic for `payload()` and `payload_bytes()` is the same as for `send()` and `send_bytes()`.    // First requires an encodable struct. The second requires bytes.    let log = Log::builder()        .source(ping_pong_id)        .dest(100001)        .payload_bytes("PONG");    assert!(res.contains(&log));    let wrong_log = Log::builder().source(100001);    assert!(!res.contains(&wrong_log));    // Log also has `From` implementations from (ID, T) and from (ID, ID, T),    // where ID: Into<ProgramIdWrapper>, T: AsRef<[u8]>    let x = Log::builder().dest(5).payload_bytes("A");    let x_from: Log = (5, "A").into();    assert_eq!(x, x_from);    let y = Log::builder().dest(5).source(15).payload_bytes("A");    let y_from: Log = (15, 5, "A").into();    assert_eq!(y, y_from);    assert!(!res.contains(&(ping_pong_id, ping_pong_id, "PONG")));    assert!(res.contains(&(1, 100001, "PONG")));

Spending blocks:

    // You may control time in the system by spending blocks.    //    // It adds the amount of blocks passed as arguments to the current block of the system.    // Same for the timestamp. Note, that for now 1 block in Gear network is 1 sec duration.    sys.spend_blocks(150);

Balance:

    // If you need to send a message with value you have to mint balance for the message sender:    let user_id = 42;    sys.mint_to(user_id, 5000);    assert_eq!(sys.balance_of(user_id), 5000);    // To give the balance to the program you should use `mint` method:    let prog = Program::current(&sys);    prog.mint(1000);    assert_eq!(prog.balance(), 1000);编辑此页上一页合约测试下一页Testing with gclientImport gtest libgtest capabilities








什么是 dApp? | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())跳到主要内容Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContribute下一页Unstable 🚧下一页简体中文English简体中文搜索欢迎Intro to Gear Protocol5 分钟快速入门Gear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsWeb3dApp智能合约DeFiNFTDAOGear-based NetworksGeneral topicsdApp什么是 dApp?
去中心化应用，或称 dApps，是指提供与传统应用类似的功能的应用，但主要区别在于它们是在去中心化的点对点网络上运行，如区块链。去中心化的应用程序提供构成 Web3 革命的服务。
因为 dApps 是去中心化的，所以没有一个实体控制着应用程序。相反，这些应用程序是开源的，其数据是公开的。DApps 使用加密令牌来帮助保持网络安全，而且它们是完全无权限的，这意味着任何人、任何地方都可以与它们互动。
除了其包容性和特别低的准入门槛之外，使 DApps 如此创新的原因是它们具有抗审查性。这意味着，由于没有单点故障，很难限制对去中心化应用的访问。这种缺乏单点故障的情况也意味着 dApps 很难被攻击，而且往往是零停机时间。
在大多数情况下，要与 dApp 互动，用户必须拥有该应用程序的原生加密代币。编辑此页上一页Web3下一页智能合约








什么是 DeFi? | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())跳到主要内容Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContribute下一页Unstable 🚧下一页简体中文English简体中文搜索欢迎Intro to Gear Protocol5 分钟快速入门Gear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsWeb3dApp智能合约DeFiNFTDAOGear-based NetworksGeneral topicsDeFi什么是 DeFi?
去中心化金融是一个金融服务的集合，是当前金融体系的替代方案。
传统金融行业不透明，受到严格控制，并且已经过时，而 DeFi 赋予了个人权力，让他们对自己的财务有更多的个人控制。DeFi 应用程序使个人能够借款、储蓄、投资和交易，而不必依赖银行、交易所或贷款机构等第三方。它能够做到这一点，因为它建立在区块链技术上，利用加密货币和智能合约，可以自动和即时地执行交易。
DeFi 解决了传统金融体系中的许多问题。首先，它使金融服务更容易获得和包容。这很重要，因为它使以前被排除在外的17亿多人能够获得安全和可靠的金融业。
除此之外，DeFi 比传统的金融服务更快、更有效，因为应用程序是由智能合约驱动的。这消除了对中介机构的要求，从而消除了许多与金融服务相关的产生的费用。
DeFi 应用程序可以在世界任何地方全天候访问，这意味着个人  不受限于在特定日期和时间或特定时区操作。编辑此页上一页智能合约下一页NFT








什么是 NFT? | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())跳到主要内容Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContribute下一页Unstable 🚧下一页简体中文English简体中文搜索欢迎Intro to Gear Protocol5 分钟快速入门Gear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsWeb3dApp智能合约DeFiNFTDAOGear-based NetworksGeneral topicsNFT什么是 NFT?
非同质化代币（NFT - Non-Fungible Token）是一种独特的加密代币类型，能够将独特的数据单位通证化，并存储在区块链上。
NFT 本质上可以代表任何独特的东西，其目前最常见的使用情况是代表数字艺术品的代币。
然而，与许多人的看法相反，NFT 的用例并不仅仅是验证艺术品的真实性和所有权。
NFT 可以代表任何不可替代的东西。这意味着，任何具有独特属性的东西现在都有办法以加密方式表示，以便存储在区块链上，从其独特的功能中获益。
NFT 可以用来代表任何东西，从房子的地契到产品或服务的收据。
在未来，所有独特的数据单位都可能以某种方式表示为 NFT，因为它们是存储有价值数据的更安全的方式，而且它们非常容易获得，这使得传统的非流动性资产的流动性大大增加。编辑此页上一页DeFi下一页DAO








What is Web3? | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable 🚧StableEnglishEnglish简体中文SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsWeb3dAppsSmart ContractsDeFiNFTDAOGear-based NetworksGeneral topicsWeb3What is Web3?
Web 3.0 is a new iteration of the internet that’s powered by new technologies like artificial intelligence, machine learning and most importantly, blockchain technology.
Web 3.0 aims to create a more open, connected and intelligent internet that is permissionless and open to everyone without monetizing personal data.
With Web3, anyone who is on the network has permission to use all Web3 services. There isn’t a central authority who can block or deny access. Because Web3 is entirely decentralized, there isn’t a single entity that owns or controls the network. Rather, the community are the ones who control the network. And because the infrastructure that powers Web3 is turing-complete, pretty much anything imaginable can get programmed as a decentralized application.
On top of that, most interactions and transactions that occur on Web3 will benefit in terms of security, speed and cost thanks to the unique nature of blockchain technology.
The value proposition is simple. The main advantage of Web3 is that it addresses the biggest problem that’s resulted from Web2 - the collection and monetization of personal data.
Web3 empowers the user and it creates a more efficient, secure and transparent Internet.Edit this pagePreviousReact-hooksNextdApps








Gear React-hooks | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())跳到主要内容Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContribute下一页Unstable 🚧下一页简体中文English简体中文搜索欢迎Intro to Gear Protocol5 分钟快速入门Gear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JS开始Keyring计算 Gas上传程序Pay Program rent提交代码发送消息读取状态Vouchers元数据 与 Type CreationMailboxEvents示例Gear-JS tools创建 Gear AppMeta CLIReact-hooksGeneral topicsGear-based NetworksGear-JSGear-JS toolsReact-hooks本页总览Gear React-hooks
Hooks allow functional components to have access to programs running on Gear networks and significantly simplify the development of front-end applications.
For example, refer to this article that demonstrates the creation of a React application that connects to an NFT smart contract running on the blockchain.
Installation​
npm install @gear-js/react-hooks
or
yarn add @gear-js/react-hooks
Getting started​
Simple as it is, here's a quick example:
import { useReadFullState } from '@gear-js/react-hooks';import { useMetadata } from './use-metadata'import meta from 'assets/meta/meta.txt';function State() {  const programId = '0x01';  const { metadata } = useMetadata(meta);  const { state } = useReadFullState(programId, meta);  return <div>{JSON.stringify(state)}</div>;}export { State };
Cookbook​
信息In order for these hooks to work, the application must be wrapped in the appropriate Providers. As it is presented in the example. If you use create-gear-app, then all the necessary environment has already been provided.
useApi​
useApi provides access to the Gear API connected to the selected RPC-node.
import { useApi } from '@gear-js/react-hooks';const { api, isApiReady } = useApi();
useAccount​
useAccount provides interaction with Polkadot-js extension API, allows to manage accounts from it (for example to sign transactions).
import { useAccount } from '@gear-js/react-hooks';const { account, isAccountReady } = useAccount();
useAlert​
useAlert shows any alert in the application context.
import { useAlert } from '@gear-js/react-hooks';const alert = useAlert();// type?: 'info' | 'error' | 'loading' | 'success';alert.success('success message')
useMetadata​
This hook is auxiliary and it is not pre-installed in the react-hook library. useMetadata allows converting the program's metadata (.txt file) into the required format.
import { useEffect, useState } from 'react';import {  getProgramMetadata,  ProgramMetadata} from '@gear-js/api';import { Buffer } from 'buffer';export const useMetadata = (source: RequestInfo | URL) => {  const [data, setData] = useState<ProgramMetadata>();  useEffect(() => {    fetch(source)      .then((res) => res.text())      .then((raw) => getProgramMetadata(`0x${raw}`))      .then((meta) => setData(meta));  }, [source]);  return { metadata: data };};
useWasmMetadata​
This hook is auxiliary and it is not pre-installed in the react-hook library. useWasmMetadata allows getting Buffer array from the program meta.wasm. Buffer is required always when using custom functions to query specific parts of the program State.
import { useEffect, useState } from 'react';import { Buffer } from 'buffer';export const useWasmMetadata = (source: RequestInfo | URL) => {  const [data, setData] = useState<Buffer>();  useEffect(() => {    if (source) {      fetch(source)        .then((response) => response.arrayBuffer())        .then((array) => Buffer.from(array))        .then((buffer) => setData(buffer))        .catch(({ message }: Error) => console.error(`Fetch error: ${message}`));    }    // eslint-disable-next-line react-hooks/exhaustive-deps  }, [source]);  return { buffer: data };};
useSendMessage​
useSendMessage allows sending messages to the program.
import { useSendMessage } from '@gear-js/react-hooks';import { useMetadata } from './useMetadata';import meta from 'assets/meta/meta.txt';function sendMessage() {  const programId = '0x01';  const { metadata } = useMetadata(meta);  return useSendMessage(programId, metadata);}
useReadFullState​
useReadFullState allows reading full program State.
import { useReadFullState } from '@gear-js/react-hooks';import { useMetadata } from './useMetadata';import meta from 'assets/meta/meta.txt';function readFullState() {  const programId = '0x01';  const { metadata } = useMetadata(meta);  const { state } = useReadFullState(programId, metadata);  return state;}
useReadWasmState​
useReadWasmState allows reading program State using specific functions.
import { useReadWasmState } from '@gear-js/react-hooks';import { useWasmMetadata } from './useMetadata';import stateMetaWasm from 'assets/wasm/state.meta.wasm';function useProgramState<T>(functionName: string, payload?: any) {  const programId = '0x01';  const { buffer } = useWasmMetadata(stateMetaWasm);  return useReadWasmState<T>(    programId,    buffer,    functionName,    payload,  );}function firstState() {  const payload = 'some_payload'  const { state } = useProgramState('foo_1', payload);  return state;}function secondState() {  // if program state function doesn't have initial payload  const { state } = useProgramState('foo_2', null);  return state;}
useCreateHandler​
useCreateHandler provides a tool for uploading the Gear program to the chain.
import { useCreateHandler } from '@gear-js/react-hooks';import meta from 'assets/meta/meta.txt';import { useMetadata } from './useMetadata';export function useCreateProgram(onSuccess: (programId: Hex) => void) {  const codeHash = '0x01';  const { metadata } = useMetadata(meta);  const createProgram = useCreateHandler(codeHash, meta);  return (payload) => createProgram(payload, { onSuccess });}编辑此页上一页Meta CLI下一页Web3InstallationGetting startedCookbookuseApiuseAccountuseAlertuseMetadatauseWasmMetadatauseSendMessageuseReadFullStateuseReadWasmStateuseCreateHandler








持久化内存 | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())跳到主要内容Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContribute下一页Unstable 🚧下一页简体中文English简体中文搜索欢迎Intro to Gear Protocol术语表我们为什么创建 Gear？Gear 的独特性Gear Protocol TechnologyActor 模型SubstrateWebAssembly (Wasm)持久化内存Gear 网络状态状态转移5 分钟快速入门Gear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksIntro to Gear ProtocolGear Protocol Technology持久化内存Gear Protocol 的另一个突出特点是持久性内存方法。它使开发更容易，消除了很多复杂性，并使协议内存管理与实际硬件和操作系统相匹配。
在 Gear 网络中运行的程序不使用存储，而是将全部状态持久化，这确保了区块链上下文的 API 面要小得多。它避免了特定领域的语言特征，也允许使用更复杂的语言结构--持久化的闭包、合成器等。
Gear Protocol 使用了巧妙的内存虚拟化技术 (尽管普通的 Wasm 没有)，内存分配和回收是该协议的第一等系统调用，还会跟踪内存访问，只加载/存储所需的内存页。这使得存储在区块链状态中的智能合约的堆栈框架（通常在期货及其合成器中发现）能够被无缝持久化，并在需要时被调用，在请求时保留其状态。
程序代码存储为一个不可变的 Wasm blob。每个程序都有固定数量的内存，在消息处理之间存在 (所谓的静态区域)。
Gear 实例持有每个程序的单独内存空间，并保证持久性。一个程序只能在它自己的内存空间内进行读写，不能访问其他程序的内存空间。单独的内存空间在程序初始化期间为其保留，不需要额外的费用（它包含在程序的初始化的费用中）。
程序可以按 64KB 的块分配所需的内存量。每个内存块分配都需要 gas 费。每个页面 (64KB) 单独存储在分布式数据库后端，但在运行时，Gear 节点构造连续运行时内存，并允许程序在其上运行而无需重新加载。
内存并行
每个程序单独的独立内存空间允许 Gear 节点上的消息处理并行化。并行处理流的数量等于 CPU 核数。每个流处理用于一组已定义程序的消息。它涉及从其  他程序或外部发送的消息 (用户事务)。
例如，给定一个消息队列，其中包含针对 100 个不同程序的消息，Gear 节点运行在一个配置了 2 个处理线程的网络上。Gear 引擎使用运行时定义的流数量 (等于一个典型的验证机上的 CPU 核的数量)，将目标程序的总数除以流的数量，并为每个流创建一个消息池 (每个流 50 个程序)。
程序被分发到不同的流中，每个消息出现在定义了目标程序的流中。因此，所有发给特定程序的消息都出现在一个处理流中。
在每个周期中，目标程序可以有多个消息，一个流处理大量程序的消息。消息处理的结果是来自每个流的一组新消息被添加到消息队列中，然后循环往复。在消息处理过程中生成的结果消息通常被发送到另一个地址 (返回原点或下一个程序)。
编辑此页上一页WebAssembly (Wasm)下一页Gear 网络状态





  
    
    
    
  
  
    window.location.href = '/zh-cn/docs/node/setting-up' + window.location.search + window.location.hash;
  







Actor Model | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable 🚧StableEnglishEnglish简体中文SearchWelcome!Intro to Gear ProtocolWhy do we build Gear?Gear Distinctive FeaturesGear Protocol TechnologySubstrateActor ModelWebAssembly (Wasm)Persistent MemoryGear Network StateState TransitionGlossaryGetting StartedGear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksIntro to Gear ProtocolGear Protocol TechnologyActor ModelOn this pageActor Model
One of the key and distinguished features of the Gear Protocol is the Actor model for message-passing communications.
Actor model framework enables asynchronous messaging and parallel computation which drastically increases the achievable speed and allows building more complex dApps in an easier way. Asynchronous format of dApps written on the Gear Protocol makes them cross-chain compatible by default.
In concurrent computing systems, “message-passing communication” means that programs communicate by exchanging messages. This has its advantages over “shared memory communication” as message passing is easier to understand than shared memory concurrency as it’s more robust and has better performance characteristics.
The principle of the Actor model approach is that programs never share any state and just exchange messages between each other. With the Actor model, a system consists of simultaneously functioning objects that communicate with each other exclusively by messaging.
While an ordinary Actor model does not guarantee message ordering, the Gear Protocol provides some additional guarantees that the order of messages between two particular programs is preserved.
Actors are isolated from each other and do not share memory. They have a state and the only way to change it is by receiving a message.
The Actor model guarantees high scalability and high fault tolerance. As applications become more computationally intensive over time in Web3, the Actor model will naturally allow advancements in CPU technology to support this continued scale.
Actor​
An Actor in the Actor model is an atomic computational unit that can send and receive messages. With Gear, any instance in the Gear Protocol is an Actor - a program (smart contract) or a user that sends messages to a program. Every Actor has an internal private state, also users have a mailbox. Communication is asynchronous, messages are popped out from the mailbox and allocated to message processing streams where they’re then processed in cycles.
When an actor receives and processes a message, the response can be the following:

Send a message to another actor
Create another actor
Change its own internal state

Actors are independent, they never share any state and just exchange messages with each other.
Using the Actor model approach provides a way to implement Actor-based concurrency inside smart contract logic. It can utilize various language constructs for asynchronous programming (Futures and async-await in Rust).
Async/await support​
Unlike classes, Actors allow only one task to access their mutable state at a time, which makes it safe for code in multiple tasks to interact with the same instance of an actor.
Asynchronous functions significantly streamline concurrency management, but they do not handle the possibility of deadlocks or state corruption. To avoid deadlocks or state corruption, async functions should avoid calling functions that may block their thread. To achieve it, they use an await expression.
Currently, the lack of normal support of async/await patterns in the typical smart contracts code brings a lot of problems for smart contract developers. Actually, achieving better control in a smart contract program flow is actually more or less possible by adding handmade functions (like in Solidity smart contracts). But the problem with many functions in a contract is that one can easily get confused - which function can be called at which stage in the contract's lifetime. It brings unnecessary complexity for developers writing smart contracts using domain specific languages.
Gear natively provides arbitrary async/await syntax for any programs. It greatly simplifies development and testing and reduces the likelihood of errors in smart contract development. The Gear Protocol's API also allows synchronous messages by simply not using await expressions if the logic of the program requires it.Edit this pagePreviousSubstrateNextWebAssembly (Wasm)ActorAsync/await support








Persistent Memory | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable 🚧StableEnglishEnglish简体中文SearchWelcome!Intro to Gear ProtocolWhy do we build Gear?Gear Distinctive FeaturesGear Protocol TechnologySubstrateActor ModelWebAssembly (Wasm)Persistent MemoryGear Network StateState TransitionGlossaryGetting StartedGear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksIntro to Gear ProtocolGear Protocol TechnologyPersistent MemoryAnother distinguished feature of the Gear Protocol is the Persistent memory approach. It is what makes development easier, removes a lot of complexity and makes protocol memory management match real-life hardware and operating systems.
Programs running in Gear Networks don’t use storage but rather their full state is persisted which ensures much less API surface for blockchain context. It avoids domain-specific language features as well as allows using much more complex language constructs — persisted boxed closures, futures compositors, etc.
The Gear Protocol uses clever memory virtualization techniques (despite vanilla Wasm does not), memory allocation and deallocation are first-class syscalls of the protocol. Memory access is also tracked and only required pages are loaded/stored. That allows heap-allocated stack frames of smart contracts stored in the blockchain’s state (typically found in futures and their compositors) to be seamlessly persisted and invoked when needed, preserving their state upon request.
Program code is stored as an immutable Wasm blob. Each program has a fixed amount of memory which persists between message-handling (so-called static area).
Gear instance holds individual memory space per program and guarantees its persistence. A program can read and write only within its own memory space and has no access to the memory space of other programs. Individual memory space is reserved for a program during its initialization and does not require an additional fee (it is included in the program's initialization fee).
A program can allocate the required amount of memory in blocks of 64KB. Each memory block allocation requires a gas fee. Each page (64KB) is stored separately on the distributed database backend, but at the run time, Gear node constructs continuous runtime memory and allows programs to run on it without reloads.
Memory parallelism
Individual isolated memory space per program allows parallelization of message processing on a Gear node. Number of parallel processing streams equals the number of CPU cores. Each stream processes messages intended for a defined set of programs. It relates to messages sent from other programs or from outside (user’s transactions).
For example, given a message queue containing messages targeted to 100 different programs, Gear node runs on a network where 2 threads of processing are configured. Gear engine uses a runtime-defined number of streams (equal to number of CPU cores on a typical validator machine), divides total amount of targeted programs to number of streams and creates a message pool for each stream (50 programs per stream).
Programs are distributed to separate streams and each message appears in a stream where its targeted program is defined. So, all messages addressed to a particular program appear in a single processing stream.
In each cycle a targeted program can have more than one message and one stream processes messages for plenty of programs. The result of message processing is a set of new messages from each stream that is added to the message queue, then the cycle repeats. The resultant messages generated during message processing are usually sent to another address (return to origin or to the next program).
Edit this pagePreviousWebAssembly (Wasm)NextGear Network State








meta-cli | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable 🚧StableEnglishEnglish简体中文SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGetting StartedKeyringCalculate GasUpload ProgramPay Program rentUpload CodeSend MessageRead StateVouchersMetadata & Type CreationMailboxEventsCookbookGear-JS toolsGear React application templateMeta CLIReact-hooksGeneral topicsGear-based NetworksGear-JSGear-JS toolsMeta CLIOn this pageDeprecation NoticeThis CLI tool is deprecated and will be removed in the future.Please use getProgramMetadata from @gear-js/api instead as described here.
Gear Meta CLI
CLI tool to encode/decode payloads and work with .meta.wasm files.
Installation​
npm install -g @gear-js/gear-meta
or
yarn global add @gear-js/gear-meta
Usage​
Full list of commands​
gear-meta --help
Available commands​
decode - Decode payload from hex
encode - Encode payload to hex
meta - Display metadata from .meta.wasm
type - Display type structure for particular type from .meta.wasm
You can simply run these commands and you will be prompted to enter the necessary data. Or you can specify data through options:
-t, --type - Type to encode or decode the payload. If it is not specified you can select it later
-m, --meta - Path to .meta.wasm file with program's metadata
-o --output - Output JSON file. If it doesn't exist it will be created
-j --payloadFromJson - If need to take the payload from json
All of these options are available for decode and encode commands
-o --output option is available for meta command
-m, --meta option is available for type command
Examples​
gear-meta encode '{"amount": 8, "currency": "GRT"}' -t init_input -m ./path/to/demo_meta.meta.wasm# Output:  # Result:  # 0x080c475254
gear-meta decode '0x080c475254' -t init_input -m ./path/to/demo_meta.meta.wasm# Output:  # Result:  # { amount: '8', currency: 'GRT' }
gear-meta type handle_input -m ./path/to/demo_meta.meta.wasm# Output:  # TypeName:  MessageIn  # { id: { decimal: 'u64', hex: 'Bytes' } }
gear-meta meta ./path/to/demo_meta.meta.wasm# Output:  # Result:  # {  #   types: '0x50000824646...0000023800',  #   init_input: 'MessageInitIn',  #   init_output: 'MessageInitOut',  #   async_init_input: 'MessageInitAsyncIn',  #   async_init_output: 'MessageInitAsyncOut',  #   handle_input: 'MessageIn',  #   handle_output: 'MessageOut',  #   async_handle_input: 'MessageHandleAsyncIn',  #   async_handle_output: 'MessageHandleAsyncOut',  #   title: 'Example program with metadata',  #   meta_state_input: 'Option<Id>',  #   meta_state_output: 'Vec<Wallet>',  #   meta_state: undefined  # }Edit this pagePreviousGear React application templateNextReact-hooksInstallationUsageFull list of commandsAvailable commandsExamples





  
    
    
    
  
  
    window.location.href = '/zh-cn/docs/api/calculate-gas' + window.location.search + window.location.hash;
  







Gear Meta CLI | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())跳到主要内容Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContribute下一页Unstable 🚧下一页简体中文English简体中文搜索欢迎Intro to Gear Protocol5 分钟快速入门Gear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JS开始Keyring计算 Gas上传程序Pay Program rent提交代码发送消息读取状态Vouchers元数据 与 Type CreationMailboxEvents示例Gear-JS tools创建 Gear AppMeta CLIReact-hooksGeneral topicsGear-based NetworksGear-JSGear-JS toolsMeta CLI本页总览Gear Meta CLI
CLI 工具，对参数进行编码/解码，并对 .meta.wasm 文件进行处理。
安装​
npm install -g @gear-js/gear-meta
或
yarn global add @gear-js/gear-meta
用法​
完整的命令列表​
gear-meta --help
可用命令​
decode - 解析 16 进制的 payload
encode - 将 payload 编码为 16 进制数据
meta - 从.meta.wasm 显示 metadata
type - 显示来自 .meta.wasm 的特定类型的类型结构
你可以运行这些命令的简写模式，系统会提示你输入必要的数据。或者你可以通过选项指定数据：
-t, --type - Type to encode or decode the payload. If it is not specified you can select it later
-m, --meta - _ .meta.wasm 文件的路径_
-o --output - 输出 JSON 文件。如果它不存在，将会创建
-j --payloadFromJson - 如果需要从 json 中获取有效载荷
_
所有这些选项都适用于 decode "和encode命令
-o --output 选项可用于 meta 命令
-m, --meta 选项可用于 type 命令
例子​
gear-meta encode '{"amount": 8, "currency": "GRT"}' -t init_input -m ./path/to/demo_meta.meta.wasm# Output:  # Result:  # 0x080c475254
gear-meta decode '0x080c475254' -t init_input -m ./path/to/demo_meta.meta.wasm# Output:  # Result:  # { amount: '8', currency: 'GRT' }
gear-meta type handle_input -m ./path/to/demo_meta.meta.wasm# Output:  # TypeName:  MessageIn  # { id: { decimal: 'u64', hex: 'Bytes' } }
gear-meta meta ./path/to/demo_meta.meta.wasm# Output:  # Result:  # {  #   types: '0x50000824646...0000023800',  #   init_input: 'MessageInitIn',  #   init_output: 'MessageInitOut',  #   async_init_input: 'MessageInitAsyncIn',  #   async_init_output: 'MessageInitAsyncOut',  #   handle_input: 'MessageIn',  #   handle_output: 'MessageOut',  #   async_handle_input: 'MessageHandleAsyncIn',  #   async_handle_output: 'MessageHandleAsyncOut',  #   title: 'Example program with metadata',  #   meta_state_input: 'Option<Id>',  #   meta_state_output: 'Vec<Wallet>',  #   meta_state: undefined  # }编辑此页上一页创建 Gear App下一页React-hooks安装用法完整的命令列表可用命令例子








快速入门 | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())跳到主要内容Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContribute下一页Unstable 🚧下一页简体中文English简体中文搜索欢迎Intro to Gear Protocol5 分钟快速入门Gear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based Networks5 分钟快速入门本页总览5 分钟入门
本指南提供了在 Gear 网络上运行智能合约的一般概述。它指导您如何编写智能合约，将其编译为 Wasm，并部署到 Gear 网络。
在这个例子中，我们将使用一个模拟真实 Gear 去中心化网络的演示环境。
前期准备​

为了方便起见，建议您为所有与 Gear 相关的内容创建一个专用目录。本文的其余部分将假设您使用的是所建议的路径。输入以下命令来在 Home 目录创建一个专用文件夹并跳转到文件夹中：

mkdir -p ~/gearcd ~/gear

确保您已经安装了在 Rust 中构建智能合约所需的所有工具。我们将使用 Rustup 来安装 Rust 编译器。

curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

现在，让我们为 rustup 安装一个 nightly 版本，因为 Gear 使用了 一些 rustup 提供的最新功能。

rustup updaterustup update nightly

我们需要把 Rust 智能合约编译为 Wasm，所以我们需要一个 Wasm 编译器。让我们将 Wasm 编译器添加到工具链中。

rustup target add wasm32-unknown-unknown --toolchain nightly
注意 如果你使用 Windows，请下载并安装 Build Tools for Visual Studio。
创建你的第一个 Gear 智能合约​

现在让我们在 gear 文件夹内，创建 contracts 文件夹，然后通过 cd 切换进文件夹

mkdir -p ~/gear/contractscd ~/gear/contracts

下一步将是为合约建立一个 Rust 库。

cargo new first-gear-app --lib
gear/contracts 目录树应该是这样的：
└── first-gear-app    ├── Cargo.toml    └── src        └── lib.rs

现在开始写一些代码。用你喜欢的编辑器打开 first-gear-app，我们使用VS Code。

code ~/gear/contracts/first-gear-app

创建 build.rs 文件，并粘贴以下代码：

fn main() {    gear_wasm_builder::build();}
同时配置Cargo.toml，可以使合约正确地创建。
[package]name = "first-gear-app"version = "0.1.0"authors = ["Your Name"]edition = "2021"license = "GPL-3.0"[dependencies]gstd = { git = "https://github.com/gear-tech/gear.git", tag = "v1.0.2", features = ["debug"] }[build-dependencies]gear-wasm-builder = { git = "https://github.com/gear-tech/gear.git", tag = "v1.0.2" }[dev-dependencies]gtest = { git = "https://github.com/gear-tech/gear.git", tag = "v1.0.2" }

用我们的第一个智能合约的代码替换 lib.rs。在编辑器中打开 src/lib.rs 并粘贴以下代码：

#![no_std]use gstd::{debug, msg, prelude::*};static mut MESSAGE_LOG: Vec<String> = vec![];#[no_mangle]unsafe extern "C" fn handle() {    let new_msg = String::from_utf8(msg::load_bytes().expect("Unable to load bytes"))        .expect("Invalid message");    if new_msg == "PING" {        msg::reply_bytes("PONG", 0).expect("Error in sending reply");    }    MESSAGE_LOG.push(new_msg);    debug!("{:?} total message(s) stored: ", MESSAGE_LOG.len());}
这个合约发送了PING消息，会收到PONG消息作为回应。

然后，编译合约代码

cd ~/gear/contracts/first-gear-app/cargo build --release
如果一切顺利，工作目录应该有一个 target 目录，如下所示的：
target    ├── CACHEDIR.TAG    ├── release    │   ├── ...    └── wasm32-unknown-unknown        ├── CACHEDIR.TAG        └── release            ├── build            │   └── ...            ├── deps            │   └── ...            ├── examples            ├── incremental            ├── first_gear_app.d            └── first_gear_app.wasm <---- this is our .wasm file
我们需要的是 target/wasm32-unknown-unknown/release 目录内的 first_gear_app.wasm 文件。现在知道它在哪里了，让我们进入下一步。
在测试网上部署你的第一个合约​
Gear provides a demo environment that emulates the real Gear decentralized network, available in idea.gear-tech.io.
Gear 提供了一个模拟真实 Gear 去中心化网络的 demo 环境，可以通过 idea.gear-tech.io 访问。
创建账户​


通过 https://polkadot.js.org/extension/ 为您的浏览器下载 Polkadot 扩展插件。这个扩展插件可以管理账户并允许用这些账户签名交易。它是一个安全的工具，允许将你的账户注入到任何基于 Substrate 的应用程序。它不执行钱包功能，例如，发送资金。


下载完成后，点击 '+' 来创建新的账户：




确保你安全的保存了 12 个单词的助记词。



选择合适的网络 - 选择 "Allow to use on any chain"。为这个账户提供任何名称和密码，并点击"Add the account with the generated seed" 来完成账户注册。



前往 idea.gear-tech.io。系统将提示你授予 Gear Tech 应用程序对你账户的访问权，点击 "Yes, allow this application access" 。




点击右上方的 Connect 按钮，选择一个账户，连接到 Gear Tech。


根据 Actor 模型，智能合约通过消息上传到网络。Gear 节点在消息处理过程中会收取一定  的 gas。账户需要有足够的资金来上传智能合约到TestNet。点击 "Get test balance"。



窗口的底部会出现一个关于成功获得余额的通知。你还可以在右上角的账户名称旁边看到当前的账户余额。

上传合约​

当你的账户余额足够时，点击 Upload program 并找到我们上面提到的 .wasm 文件。



指定合约名称，并设定 Gas limit 为 20 000 000，然后点击 Upload program 按钮。



签署交易，将合约上传到 Gear 网络。此外，签署合约并将元数据上传到 Gear 演示环境，以便可以使用该合约。为方便起见，建议设置复选框 Remember my password for the next 15 minutes 。


备注上传后，如果合约名称前面有红点，代表初始化错误。请再次上传合约，并扩大 Gas limit，可以尝试将默认值扩大 10 倍。

合约上传后，前往 Recently uploaded programs 并找到你的合约。


向合约发送消息​


现在，尝试向新上传的合约发送一条消息，看看它是如何响应的！使用这个按钮：



在打开的对话框中 PING 的 Payload 字段中，提供 20 000 000 的 gas，然后点击 Send request 按钮。





签名消息发送交易，如上传合约中的步骤 3 所示


成功处理消息后，合约会发送 PONG 作为响应：




更多内容​
除了这篇 "5 分钟入门"，你还可以参考另一篇展示在 Gear 平台上创建应用程序的简单性和便利性的文章--初学者的第一个智能合约。
这篇文章以 Voting 应用程序为例，描述了 Gear 智能合约的结构，如何使用程序的角色模型架构，处理消息，以及如何处理状态。
关于 Gear 编写智能合约的信息以及智能合约实现背后的具体内容，请访问 智能合约。编辑此页上一页状态转移下一页配置节点前期准备创建你的第一个 Gear 智能合约在测试网上部署你的第一个合约创建账户上传合约向合约发送消息更多内容








配置本地节点 | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())跳到主要内容Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContribute下一页Unstable 🚧下一页简体中文English简体中文搜索欢迎Intro to Gear Protocol5 分钟快速入门Gear Node配置节点将节点程序配置成服务节点监控备份和恢复开发网络多节点模式常见问题常见错误Developing Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksGear Node配置节点本页总览配置本地节点
介绍​
本教程覆盖了安装和运行 Gear 节点所需的步骤。
这里有两种方式来开始运行 Gear 节点。第一种方式，你可以下载预编译好的二进制文件，直接运行。第二种方式，你可以自行编译和配置。使用已经准备好的编译文件是最快和最便捷的开始方式，因为你可以跳过诸如安装 Rust、安装依赖和节点编译的过程。从另一方面来讲，如果你决定要采用自己编译的方式来创建你的开发节点，那么它将花费大约 20 分钟时间或者更多，这一切取决于你的机器配置。
信息系统配置要求​由于需要对 AVX 和 SSE 4.2 的支持，Gear 节点不能在 QEMU 虚拟 CPU 上正常工作。Gear 节点并不要求特殊的硬件配置，除了建议使用 SSD 硬盘。
采用预编译的二进制文件来安装​
依据你的操作系统，你需要下载 Gear 节点的 nightly build 版本：
Windows x64MacOS ARMMacOS x64Linux x64Terminal:curl -O https://get.gear.rs/gear-nightly-x86_64-pc-windows-msvc.zip或Windows x64: gear-nightly-x86_64-pc-windows-msvc.zipTerminal:wget https://get.gear.rs/gear-nightly-aarch64-apple-darwin.tar.xz && \tar xvf gear-nightly-aarch64-apple-darwin.tar.xz && \rm gear-nightly-aarch64-apple-darwin.tar.xz或macOS M1: gear-nightly-aarch64-apple-darwin.tar.xzTerminal:wget https://get.gear.rs/gear-nightly-x86_64-apple-darwin.tar.xz && \tar xvf gear-nightly-x86_64-apple-darwin.tar.xz && \rm gear-nightly-x86_64-apple-darwin.tar.xz或macOS Intel x64: gear-nightly-x86_64-apple-darwin.tar.xzTerminal:wget https://get.gear.rs/gear-nightly-x86_64-unknown-linux-gnu.tar.xz && \tar xvf gear-nightly-x86_64-unknown-linux-gnu.tar.xz && \rm gear-nightly-x86_64-unknown-linux-gnu.tar.xz或Linux x64: gear-nightly-x86_64-unknown-linux-gnu.tar.xz
自行编译 Gear 节点​
自行编译版本需要花费一些时间，同时需要安装一些依赖：
前期准备​
Linux 用户需要依照自己的发行版本来安装 GCC 和 Clang。
另外，需要安装包含所需的 wasm-opt 工具的 binaryen工具集。
例如在 Ubuntu 上使用如下命令：
sudo apt install -y clang build-essential binaryen cmake protobuf-compiler
在 macOS 上，你可以通过运行以下命令得到编译器工具集和binaryen。
xcode-select --installbrew install binaryen
安装 Rust​
如果你已经安装 Rust，你可以跳过这一步。
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
之后你需要重启你的终端。
安装 Wasm Toolchains:​
rustup toolchain add nightlyrustup target add wasm32-unknown-unknown --toolchain nightly
下载 Gear 代码​
git clone https://github.com/gear-tech/gear.gitcd gear
编译​
cargo build -p gear-cli --release
或
make node-release
备注你将在 /gear/target/release/gear 找到最终的编译输出前往：cd target/release
运行 Gear 节点​
信息这一步同是否是下载的预编译版本还是自己编译的版本无关。在 gear-node 安装的目录运行如下命令来链接测试网：
./gear
采用如下命令来运行开发模式的 Gear 节点：
./gear --dev
命令标记和选项​
gear [flags] [options]
--chain=testnet
链接到 Gear 测试网。
--dev
运行单节点 Gear 开发网络。
purge-chain
删除选定链的存储。需要明确链的类型 --chain=staging 或 --dev。
--help
帮助信息。
特殊环境变量​
运行 Gear 节点时开启合约日志：
RUST_LOG="gwasm=debug" gear [flags]编辑此页上一页5 分钟快速入门下一页将节点程序配置成服务介绍系统配置要求采用预编译的二进制文件来安装自行编译 Gear 节点前期准备安装 Rust安装 Wasm Toolchains:下载 Gear 代码编译运行 Gear 节点命令标记和选项特殊环境变量








Getting started | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())跳到主要内容Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContribute下一页Unstable 🚧下一页简体中文English简体中文搜索欢迎Intro to Gear Protocol5 分钟快速入门Gear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JS开始Keyring计算 Gas上传程序Pay Program rent提交代码发送消息读取状态Vouchers元数据 与 Type CreationMailboxEvents示例Gear-JS toolsGeneral topicsGear-based NetworksGear-JS开始本页总览Getting started
Gear-JS API​
Gear-JS API 提供了一组实用程序、库和工具，使 JavaScript 应用程序能够通过对 Gear 节点的查询与在 Gear 网络中运行的智能合约进行交互。
以下部分描述了你可以在 JS 应用程序中使用的工具来实现基本功能，例如管理密钥对（帐户）、计算网络操作所需的gas、在网络中上传程序、向程序发送消息、读取程序的状态、 从 mailbox 中获取消息，使用元数据等等。 Cookbook 部分提供了一些有用的代码片段。
基本的API是在Substrate层实现的，对所有基于Substrate的网络都是一样的。Gear-JS的API代码可以在GitHub上找到。完整的API概述可以在[Polkadot 文档]（https://polkadot.js.org/docs/）上找到。
安装​
npm install @gear-js/api
或者
yarn add @gear-js/api
开始​
使用 API 连接本地节点：
import { GearApi } from '@gear-js/api';const gearApi = await GearApi.create();
或者连接不同节点
const gearApi = await GearApi.create({  providerAddress: 'wss://someIP:somePort',});
备注以下是与Gear RPC节点几个入口。连接本地节点：ws://127.0.0.1:9944连接测试节点：wss://rpc-node.gear-tech.io:443
获取节点信息：
const chain = await gearApi.chain();const nodeName = await gearApi.nodeName();const nodeVersion = await gearApi.nodeVersion();const genesis = gearApi.genesisHash.toHex();
例子​
这个简单的例子描述了如何订阅一个新的区块并获得链的基本信息：
async function connect() {  const gearApi = await GearApi.create();  const [chain, nodeName, nodeVersion] = await Promise.all([    gearApi.chain(),    gearApi.nodeName(),    gearApi.nodeVersion(),  ]);  console.log(    `You are connected to chain ${chain} using ${nodeName} v${nodeVersion}`,  );  const unsub = await gearApi.gearEvents.subscribeToNewBlocks((header) => {    console.log(      `New block with number: ${header.number.toNumber()} and hash: ${header.hash.toHex()}`,    );  });}connect().catch(console.error);编辑此页上一页SS58 地址格式下一页KeyringGear-JS API安装开始例子



