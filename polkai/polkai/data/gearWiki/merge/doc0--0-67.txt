




Welcome! | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable ğŸš§StableEnglishEnglishç®€ä½“ä¸­æ–‡SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksWelcome!On this pageWelcome!Welcome to Gearâ€™s documentation portal. This is the central source of information for everyone who is looking for general information about Gear. Here you will find guides and developer's documentation that will enable you to dive deeper into developing smart contracts on the Gear Protocol.
Our Wiki outlines foundational information required, general technology overviews and key advantages of Gearâ€™s technology, including how to implement and run your smart contracts and how to get started with the Gear node setup, while also providing full API details and examples.
All code, libraries, and tools are available on GitHub. Feel free to use the tools and libraries, log issues as you find them, or create pull requests for your bug-bears or features.
As our project is developing and growing, contributions are more than welcome!
What is the Gear Protocol?â€‹
The Gear Protocol is a Substrate-based smart-contract platform that enables anyone to develop and run a dApp in a matter of minutes. The Gear Protocol is the most developer-friendly way to implement smart contracts with arbitrary logic and of any complexity. Gear smart-contracts run as WebAssembly programs so they can be compiled from many popular programming languages, such as Rust, C, C++ and many more.
The protocol ensures very minimal, intuitive and sufficient APIs for implementing programs and running them on multiple networks without having to rewrite them. From a technological point of view, the Gear Protocol is distinguished by fundamentally new features that enable you to create asynchronous programs with a completely new and previously unattainable user experience, namely - the Actor model for communication, the persistent memory concept and WebAssembly execution environment. The protocol dictates what actors should look like as communicating entities.
The Gear Protocol will assist with the transition to mass use of Web3 technologies by enabling the running of innovative dApps, microservices, middleware and open APIs.
What is the Gear Network?â€‹
The Gear Protocol provides the most cost-effective way to run smart contracts. Powered by the Gear Protocol, Gear Networks can act as standalone L1 networks, as well as become a parachain in the Polkadot and Kusama ecosystem too. By deploying on Gear Protocol, developers can fully leverage the benefits offered by Gear.
Vara Network is the first stand-alone layer-1 decentralized network built and running on top of Gear Protocol.
How to engage with the Gear communityâ€‹
GitHubâ€‹
Instructions and other development-focused conversations are found on our GitHub.
Discordâ€‹
General information and non-technical conversation are found on our Discord server.
Twitterâ€‹
Follow us on Twitter for regular updates: @gear_techs
Telegramâ€‹
Join Gear's official Telegram channel: @gear_tech
Mediumâ€‹
Get smart with our regular articles on Medium.Edit this pageNextWhy do we build Gear?What is the Gear Protocol?What is the Gear Network?How to engage with the Gear communityGitHubDiscordTwitterTelegramMedium








Welcome! | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeUnstable ğŸš§Unstable ğŸš§StableEnglishEnglishç®€ä½“ä¸­æ–‡SearchWelcome!This is unreleased documentation for Gear Documentation Portal Unstable ğŸš§ version.For up-to-date documentation, see the latest version (Stable).Welcome!Version: Unstable ğŸš§Welcome!Welcome to Gearâ€™s documentation portal.
warningThis is the documentation for the next version of Gear. The current version is here.Edit this page








ä»€ä¹ˆæ˜¯ Web3? | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())è·³åˆ°ä¸»è¦å†…å®¹Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeä¸‹ä¸€é¡µUnstable ğŸš§ä¸‹ä¸€é¡µç®€ä½“ä¸­æ–‡Englishç®€ä½“ä¸­æ–‡æœç´¢æ¬¢è¿Intro to Gear Protocol5 åˆ†é’Ÿå¿«é€Ÿå…¥é—¨Gear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsWeb3dAppæ™ºèƒ½åˆçº¦DeFiNFTDAOGear-based NetworksGeneral topicsWeb3ä»€ä¹ˆæ˜¯ Web3?
Web 3.0 æ˜¯äº’è”ç½‘çš„å…¨æ–°è¿­ä»£ï¼Œç”±äººå·¥æ™ºèƒ½ã€æœºå™¨å­¦ä¹ å’Œæœ€é‡è¦çš„åŒºå—é“¾æŠ€æœ¯ç­‰æ–°æŠ€æœ¯é©±åŠ¨ã€‚
Web3.0 çš„ç›®çš„æ˜¯åˆ›é€ ä¸€ä¸ªæ›´åŠ å¼€æ”¾ã€è¿æ¥å’Œæ™ºèƒ½çš„äº’è”ç½‘ï¼Œå¯¹ä»»ä½•äººè€Œè¨€éƒ½æ— éœ€è®¸å¯ï¼Œå¹¶ä¸”ä¸å°†ä¸ªäººæ•°æ®è´§å¸åŒ–ã€‚
é€šè¿‡ Web3ï¼Œä»»ä½•åœ¨ç½‘ç»œä¸Šçš„äººéƒ½æœ‰æƒé™ä½¿ç”¨æ‰€æœ‰ Web3 çš„æœåŠ¡ã€‚æ²¡æœ‰ä¸€ä¸ªä¸­å¤®æœºæ„å¯ä»¥é˜»æ­¢æˆ–æ‹’ç»è®¿é—®ã€‚å› ä¸º Web3 æ˜¯å®Œå…¨å»ä¸­å¿ƒåŒ–çš„ï¼Œæ²¡æœ‰ä¸€ä¸ªå®ä½“æ‹¥æœ‰æˆ–æ§åˆ¶ç½‘ç»œã€‚ç›¸åï¼Œç¤¾åŒºæ˜¯æ§åˆ¶ç½‘ç»œçš„äººã€‚ç”±äºä¸º Web3 æä¾›åŠ¨åŠ›çš„åŸºç¡€è®¾æ–½æ˜¯å›¾çµå®Œå¤‡çš„ï¼Œå‡ ä¹ä»»ä½•å¯ä»¥æƒ³è±¡åˆ°çš„ä¸œè¥¿éƒ½å¯ä»¥è¢«ç¼–ç¨‹ä¸ºä¸€ä¸ªå»ä¸­å¿ƒåŒ–çš„åº”ç”¨ç¨‹åºã€‚
é™¤æ­¤ä¹‹å¤–ï¼Œç”±äºåŒºå—é“¾æŠ€æœ¯çš„ç‹¬ç‰¹æ€§è´¨ï¼Œåœ¨ Web3 ä¸Šå‘ç”Ÿçš„å¤§å¤šæ•°äº’åŠ¨å’Œäº¤æ˜“å°†åœ¨å®‰å…¨ã€é€Ÿåº¦å’Œæˆæœ¬æ–¹é¢å—ç›Šã€‚
ä»·å€¼ä¸»å¼ å¾ˆç®€å•ã€‚Web3 çš„ä¸»è¦ä¼˜åŠ¿åœ¨äºï¼Œå®ƒè§£å†³äº† Web2 å¸¦æ¥çš„æœ€å¤§é—®é¢˜--ä¸ªäººæ•°æ®çš„æ”¶é›†å’Œè´§å¸åŒ–ã€‚
Web3 èµ‹äºˆç”¨æˆ·æƒåŠ›ï¼Œåˆ›é€ äº†ä¸€ä¸ªæ›´é«˜æ•ˆã€å®‰å…¨å’Œé€æ˜  çš„äº’è”ç½‘ã€‚ç¼–è¾‘æ­¤é¡µä¸Šä¸€é¡µReact-hooksä¸‹ä¸€é¡µdApp








å…³äº Vara ç½‘ç»œ | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())è·³åˆ°ä¸»è¦å†…å®¹Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeä¸‹ä¸€é¡µUnstable ğŸš§ä¸‹ä¸€é¡µç®€ä½“ä¸­æ–‡Englishç®€ä½“ä¸­æ–‡æœç´¢æ¬¢è¿Intro to Gear Protocol5 åˆ†é’Ÿå¿«é€Ÿå…¥é—¨Gear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksVara ç½‘ç»œGear-based NetworksVara ç½‘ç»œå…³äº Vara ç½‘ç»œVara Network æ˜¯ç¬¬ä¸€ä¸ªåœ¨ Gear åè®®ä¹‹ä¸Šæ„å»ºå’Œè¿è¡Œçš„ç‹¬ç«‹çš„ç¬¬ 1 å±‚å»ä¸­å¿ƒåŒ–ç½‘ç»œã€‚
å¿«é€Ÿå’Œå¯æ‰©å±•çš„éåˆ†å‰å‡çº§çš„ Vara ç½‘ç»œä¸ºä¸‹ä¸€ä»£æ¸¸æˆã€åŸºäºé‡‘èçš„åº”ç”¨ã€å®éªŒæ€§åŠŸèƒ½æä¾›äº†æœ€ä½³åœºæ‰€ã€‚ä¸ä»…å¦‚æ­¤ï¼Œä»»ä½•å…¶ä»–ç°ä»£ç”¨ä¾‹éƒ½éå¸¸é€‚åˆåœ¨ Vara ä¸Šè¿è¡Œã€‚åœ¨ Vara ç½‘ç»œä¸Šæ„å»ºç”Ÿæ€ï¼Œå¯¹äºå·²ç»åœ¨ Web3 ä¸­çš„å¼€å‘è€…å’Œé‚£äº›ä» Web2 è¿ç§»è¿‡æ¥çš„å¼€å‘è€…æ¥è¯´ï¼Œéƒ½æ˜¯ç†æƒ³çš„é€‰æ‹©ï¼Œä»–ä»¬å¯ä»¥åœ¨æœ€å®‰å…¨ã€é«˜æ•ˆã€å¯æ‰©å±•çš„ç¯å¢ƒä¸­éƒ¨ç½²ä»–ä»¬çš„å»ä¸­å¿ƒåŒ–åº”ç”¨ç¨‹åºã€‚
è®¸å¤šä¸‹ä¸€ä»£åº”ç”¨ï¼Œå¦‚æ¸¸æˆå’Œæ”¯ä»˜ï¼Œéœ€è¦ä½å»¶è¿Ÿæ‰§è¡Œã€‚Vara ç‹¬ç«‹ç½‘ç»œä¸ºè¿™äº›åº”ç”¨ç¨‹åºæä¾›äº†æœ€å¿«çš„å…¥å£ï¼Œå¹¶é‡Šæ”¾äº†æ–°çš„æ½œåœ¨åº”ç”¨ã€‚
Vara ç½‘ç»œçš„ä¸»è¦ç‰¹ç‚¹ï¼š

æœ‰å²ä»¥æ¥æœ€å¿«çš„çœŸæ­£å»ä¸­å¿ƒåŒ–çš„ L1
æ–°åŠŸèƒ½å’Œä¼˜åŒ–çš„æµ‹è¯•å°
ç”±äº Substrateï¼Œç½‘ç»œç¨³å®šä¸”å¯å‡çº§
éå¸¸å°‘çš„æ²»ç†

é™¤äº†å¼€å‘å’Œè¿è¡Œ dApps ä¹‹å¤–ï¼Œè¿˜æœ‰å‡ ç§æ–¹æ³•å¯ä»¥æ”¯æŒ Vara Networkï¼š

ä¸ºç¨‹åºæ‰§è¡Œã€å‡ºå—å’Œå‚ä¸å…±è¯†æœºåˆ¶æä¾›è®¡ç®—èµ„æºï¼Œæˆä¸ºéªŒè¯èŠ‚ç‚¹ã€‚è¿™ä¼šä½¿ Vara ç½‘ç»œæ›´å®‰å…¨ã€é«˜æ•ˆä¸”æŠ—å®¡æŸ¥
é€šè¿‡è´¨æŠ¼ä»£å¸å’ŒæåéªŒè¯è€…æˆä¸ºæåäºº
æˆä¸ºå¤§ä½¿ï¼Œå›´ç»• Vara Network å’Œ Gear Protocol å»ºç«‹æ•™è‚²æ„è¯†ã€ç¤¾åŒºå‚ä¸å’Œå»ä¸­å¿ƒåŒ–ã€‚

æœ‰å…³ Vara Network çš„æ›´å¤šä¿¡æ¯ä»¥åŠå¦‚ä½•å‚ä¸ç¤¾åŒºï¼Œè¯·è®¿é—® Vara Wiki.ç¼–è¾‘æ­¤é¡µä¸Šä¸€é¡µDAO








Gear Distinctive Features | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable ğŸš§StableEnglishEnglishç®€ä½“ä¸­æ–‡SearchWelcome!Intro to Gear ProtocolWhy do we build Gear?Gear Distinctive FeaturesGear Protocol TechnologyGlossaryGetting StartedGear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksIntro to Gear ProtocolGear Distinctive FeaturesOn this pageGear Distinctive Features
Truly decentralizedâ€‹
One of the well-known drawbacks of other platforms' smart contracts is that they cannot trigger their own functions. Instead, to run certain functions they require an external component or service to trigger on-chain transactions.
While some smart contract logic may rely on users to initiate transactions and awaken the contract, many cases require a trigger when certain conditions are met, such as reaching a specific point in time or the occurrence of a particular event. In the past, this has either limited the capabilities of smart contracts or required developers to introduce a centralized service to trigger smart contracts.
Now thanks to Gear Protocol's support for asynchronous messaging, contract developers can implement arbitrary contract logic with delayed messages that can wake the contract after a specified period of time or in response to certain events. This enables a much more extensive range of use cases for smart contracts, unlocks new decentralized functionality, and unlocks more value for users in the blockchain ecosystem.
Continuing messaging automationâ€‹
The execution of any messages in Gear, including the system messages, consumes "gas". The Gear Protocol introduces the concept of gas reservation, which allows for the creation of gas pools that can be used by programs for further execution. Each pool is unique to the program that creates it, and the gas from the pool can be consumed by the program if its "gas_available" is not sufficient.
One of the key benefits of the gas reservation is the ability to send delayed messages that can be triggered automatically at a specific time in the future. These messages, like any other message in Gear, can invoke another smart contract in the network or appear in the user's mailbox.
Perhaps most interestingly, gas reservation allows a program to send a message to itself at a later time, allowing it to continue execution after a defined period. This effectively enables a smart contract to execute itself an unlimited number of times (provided that enough gas is available for the execution).
This opens up a wide range of possibilities for the implementation of functional logic related to continuing messaging automation in smart contracts. Delayed messages are similar to cron jobs, which cannot be implemented in smart contracts on other blockchain platforms without the use of external resources. The remarkable advantage of this solution is that it eliminates the need for centralized components in dApps, ensuring they function completely on-chain and are fully decentralized and autonomous.
Applications that use delayed messages in their business logic and their source code are shown in the Smart Contract Examples section. These include applications such as: Tamagotchi battle, VaraTube, Dynamic NFT.
Payless Transactionsâ€‹
Gear Protocol's Payless Transactions feature introduces a groundbreaking concept to the world of Web3, revolutionizing communication within Gear-powered networks and increasing the adoption of decentralized applications, making their ease of use closer to Web2 services and applications.
This innovative feature empowers actors to issue vouchers that enable specific users to send messages to designated programs without incurring gas fees. This paradigm-shifting approach fosters a sponsorship-like environment for users, transforming the way interactions take place in the Web3 ecosystem. An example of using vouchers is shown in the Battleship game. Users without tokens on their balance can make moves by sending messages to a program using a voucher.
Understanding Payless Transactionsâ€‹
At the core of the Payless Transactions feature lies the concept of vouchers. These vouchers are crafted to grant users the ability to send messages to specific programs within the network, all without the burden of gas fees. Each voucher comes with a predetermined allocation of gas, empowering users to initiate interactions without worrying about transaction costs.
How Payless Transactions Workâ€‹


Voucher Issuance: Actors within the Vara Network can issue vouchers, creating a sponsorship mechanism for users. These vouchers are tied to specific programs and include a designated gas allocation.


Message Sending: Holders of valid vouchers can use them to send messages to the designated program. These messages can include instructions or data, enriching interactions within the network.


Gas-Free Interactions: Users who has valid vouchers can enjoy gas-free interactions when sending messages. The allocated gas from the voucher covers the associated transaction costs.


Benefits of Payless Transactionsâ€‹

Encourages user participation by eliminating the gas fee barrier
Reduced Ñomplexity for dApps adoption
Fostering a more inclusive and vibrant network
More accessible and user-friendly (Web2-like approach)

How does it work?â€‹
Learn how to create and use vouchers in this article.
Use casesâ€‹
For instance, let's consider some use case examples that become achievable:
NFTsâ€‹
Non-Fungible Tokens (NFTs) are unique digital assets that can be owned and traded on blockchain networks. One of the key features of NFTs is that they can be dynamic, meaning that their properties can be changed based on certain conditions. Dynamic NFTs can be updated immediately by their owner or gradually using delayed messages.
This can be useful in a variety of situations, such as updating an NFT based on changes in its price, as is done in the Curse NFT using Oracles, or in gaming applications where the properties of an NFT might change over time.
There are scenarios in which NFTs are updated:

The user can send a message to update the NFT immediately
The NFT contract can send a message to itself at regular intervals to update the token's properties
The NFT contract can send a delayed message to another actor (such as a program or account) and change the NFT's properties based on the result of processing that message.

Overall, the ability to update NFTs dynamically opens up a wide range of possibilities for their use in a variety of applications.
Gamingâ€‹
Everyone knows that the most successful games are those that are exciting, that you play with pleasure.
The success of such games depends on the right game mechanics established by the developers. The Gear Protocol offers a tool for developing such games and running them on a decentralized network, like Vara. Features such as delayed messages, payless transactions, and gas reservation become essential tools for developers aiming to create successful games on the Gear decentralized network.
Here are a few of the many examples where such functionality would be useful:
Tamagotchi is a classic digital pet game where players must care for a virtual creature by providing it food, attention, and other forms of care. As a dynamic NFT, a Tamagotchi can change its appearance based on its properties (such as hunger, fatigue, or happiness) and can notify the user when it needs to be fed or played with. The user can feed the NFT with gas, which is used to send delayed messages that are required to update the Tamagotchi's state.
"Game strategies battle" is a game in which several programs compete with each other using different algorithms or strategies. The game can be based on a variety of classic games, such as checkers, tic-tac-toe, races, or Monopoly. Each participant creates a smart contract with their own game strategy and uploads it to the blockchain. The programs then play against each other until someone wins or the gas runs out. If the gas runs out, one of the participants can continue the game by sending a message with more gas. This allows the game to continue indefinitely, with the most effective strategy ultimately emerging as the winner.
DeFiâ€‹
Decentralized finance (DeFi) applications can improve the user experience by implementing delayed messages. For example, when users deposit tokens into a liquidity pool on an automated market maker (AMM) or participate in staking to earn rewards, they often have to manually claim their earnings (known as "harvesting yield").
With the Gear Protocol, users can enjoy a set-and-forget DeFi experience where their earnings are automatically deposited into their accounts without any manual intervention. Rewards are regularly harvested, swapped for the original vault asset, and deposited again for compound farming, allowing users to earn even more without having to take any additional action.
In general, the use of delayed messages in DeFi can greatly improve the user experience by making it easier for users to earn rewards and take advantage of the benefits of DeFi without constantly having to monitor and manage their assets. This can help drive broader adoption of DeFi and unlock new opportunities for growth in the industry.Edit this pagePreviousWhy do we build Gear?NextSubstrateTruly decentralizedContinuing messaging automationPayless TransactionsUnderstanding Payless TransactionsHow Payless Transactions WorkBenefits of Payless TransactionsHow does it work?Use casesNFTsGamingDeFi








Ğ¡onfiguring a node as a Linux service | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable ğŸš§StableEnglishEnglishç®€ä½“ä¸­æ–‡SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeSetting UpNode as a ServiceNode MonitoringBackup and RestoreDev Net ModeMulti-Node ModeNode FAQTroubleshootingDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksGear NodeNode as a ServiceOn this pageĞ¡onfiguring a node as a Linux service
Prerequisitesâ€‹
You need to download or compile the gear executable file for your OS. See more
Configurationâ€‹
Copy the gear executable to the /usr/bin directory:
sudo cp gear /usr/bin
To run the Gear node as one of the Linux services, you need to configure the systemd file:
cd /etc/systemd/systemsudo nano gear-node.service
Configure and save:
[Unit]Description=Gear NodeAfter=network.target[Service]Type=simpleUser=rootWorkingDirectory=/root/ExecStart=/usr/bin/gear --name "NODE_NAME" --telemetry-url "wss://telemetry.rs/submit 0"Restart=alwaysRestartSec=3LimitNOFILE=10000[Install]WantedBy=multi-user.target
noteDeclaration ExecStart points to the location of the gear binary file. In this case, it is in /usr/bin directory.
With -- additional launch parameters are indicated, but not mandatory.
Thatâ€™s it. We can now start the service.
Starting the nodeâ€‹
Run to start the service:
sudo systemctl start gear-node
Automatically get it to start on boot:
sudo systemctl enable gear-node
How to check status of gear-node service?
sudo systemctl status gear-node
Checking logsâ€‹
You may see the service logs by running the following command:
journalctl -u gear-node
Use navigation keys to browse the logs and q key to exit.
You may see the last 50 lines of logs by adding -n 50 parameter:
journalctl -u gear-node -n 50
Add -f parameter to see the last lines of logs in continuous mode (press Ctrl+C to exit):
journalctl -u gear-node -fn 50
Update the node with the new versionâ€‹
After the node has been running for a while, you may need to update it to the latest version.
You just need to replace the node executable (gear) with the latest version and restart the execution. For example, if your Linux executable is located at /usr/bin/gear (as we've configured above) you are to run:
curl https://get.gear.rs/gear-nightly-x86_64-unknown-linux-gnu.tar.xz | sudo tar -xJC /usr/binsudo systemctl restart gear-node
Remove the nodeâ€‹
If you no longer need to run the node, you can completely purge it from the disk.
warningNote that once you delete the node, you will not be able to fully restore it. Refer to the Backup and Restore article to know about the important data to be backed up.
You are to remove the node's storage, the service configuration, and the executable itself:
sudo systemctl stop gear-nodesudo systemctl disable gear-nodesudo rm -rf /root/.local/share/gearsudo rm /etc/systemd/system/gear-node.servicesudo rm /usr/bin/gearEdit this pagePreviousSetting UpNextNode MonitoringPrerequisitesConfigurationStarting the nodeChecking logsUpdate the node with the new versionRemove the node








Backup and restore the node | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable ğŸš§StableEnglishEnglishç®€ä½“ä¸­æ–‡SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeSetting UpNode as a ServiceNode MonitoringBackup and RestoreDev Net ModeMulti-Node ModeNode FAQTroubleshootingDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksGear NodeBackup and RestoreOn this pageBackup and restore the node
Data structureâ€‹
Gear node stores its data in a dedicated directory.

Linux: $HOME/.local/share/gear
macOS: $HOME/Library/Application Support/gear
Windows: %USERPROFILE%\AppData\Local\gear.exe

For example if you run the node as the root user on Linux ($HOME = /root) the absolute path of node's data directory will be:
/root/.local/share/gear
Let's explore the data that the node stores in this directory.
â””â”€â”€ gear    â””â”€â”€ chains        â”œâ”€â”€ dev        â”‚Â Â  â””â”€â”€ ...        â”œâ”€â”€ gear_staging_testnet_v7        â”‚   â”œâ”€â”€ db        â”‚   â”‚Â Â  â””â”€â”€ full        â”‚   â”œâ”€â”€ keystore        â”‚   â””â”€â”€ network        â””â”€â”€ vara_network            â”œâ”€â”€ db            â”‚Â Â  â””â”€â”€ full            â”œâ”€â”€ keystore            â””â”€â”€ network
Chainsâ€‹
The node can connect to different chains. The chain can be selected using the --chain argument. The default chain is the staging test network at the moment. Its data is located in gear/chains/gear_staging_testnet_v7 directory.
If you connect to the Vara network, the chain subdirectory name will be vara_network resulting in the gear/chains/vara_network path.
If you start the node with the --dev argument, the virtual network in development mode will run with the data stored in the gear/chains/dev directory.
Databaseâ€‹
The database keeps the blockchain state in the local node storage. It synchronizes with other nodes over a peer-to-peer protocol. One can choose the DB format using the --database argument. Possible options are:

rocksdb (default): use RocksDB as database engine, data is stored in <chain>/db/full subdirectory.
paritydb: use ParityDB as database engine, data is stored in <chain>/paritydb/full subdirectory.
paritydb-experimental: deprecated experimental mode of the ParityDB engine (will be removed in future releases), data is stored in <chain>/paritydb/full subdirectory.

Note that the database contents depends on the pruning mode of the node. By default the node keeps only the last 256 blocks. To keep all the blocks use the --pruning=archive argument when running the node.
The database can be deleted and synchronized from scratch at any time. Use the gear purge-chain command to completely delete the DB.
Network keyâ€‹
The network private key is used to calculate the unique peer identifier (started with 12D3KooW). This key is stored in <chain>/network/secret_ed25519 file. The key file is the binary file containing 32 bytes of the Ed25519 (by default) private key. You can use hexdump command to read the key:
hexdump -e '1/1 "%02x"' /root/.local/share/gear/chains/gear_staging_testnet_v7/network/secret_ed25519# 42bb2fdd46edfa4f41a5f0f9c1a5a1d407a39bafbce6f07456a2c8d9963c8f5c
You can override this key by running the node with the --node-key argument:
gear --node-key=42bb2fdd46edfa4f41a5f0f9c1a5a1d407a39bafbce6f07456a2c8d9963c8f5c# Discovered new external address for our node: /ip4/127.0.0.1/tcp/30333/ws/p2p/12D3KooWMRApe2S5QMdhHwmcDapDxZ7xf2Xa3z2HfCCYoHTmjiXV
If there is no --node-key argument, the node uses the key from the secret_ed25519 file. If it does not exist, it is created with a newly generated secret key.
The network key file cannot be recovered if lost. Therefore, you are to keep it (or the private key itself) to have the possibility to run the node with the same peer ID.
Moving the nodeâ€‹
To move the node to a new server you are to backup then restore the following (provided paths are for default Staging Testnet V7 node's parameters):


The network private key of the node:

Linux: $HOME/.local/share/gear/chains/gear_staging_testnet_v7/network/secret_ed25519
macOS: $HOME/Library/Application Support/gear/chains/gear_staging_testnet_v7/network/secret_ed25519
Windows: %USERPROFILE%\AppData\Local\gear.exe\chains\gear_staging_testnet_v7\network\secret_ed25519



(optional) The database:

Linux: $HOME/.local/share/gear/chains/gear_staging_testnet_v7/db/full
macOS: $HOME/Library/Application Support/gear/chains/gear_staging_testnet_v7/db/full
Windows: %USERPROFILE%\AppData\Local\gear.exe\chains\gear_staging_testnet_v7\db\full



(optional) The service configuration if you've configured the node as a service:

Linux: /etc/systemd/system/gear-node.service



If you don't backup the database, you can always synchronize it from scratch, but keep in mind that this process may take some time.
infoDon't forget to stop the node before backing up the database. Otherwise you can get a corrupted database.sudo systemctl stop gear-nodeEdit this pagePreviousNode MonitoringNextDev Net ModeData structureChainsDatabaseNetwork keyMoving the node








Running Gear node in Dev Net mode | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable ğŸš§StableEnglishEnglishç®€ä½“ä¸­æ–‡SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeSetting UpNode as a ServiceNode MonitoringBackup and RestoreDev Net ModeMulti-Node ModeNode FAQTroubleshootingDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksGear NodeDev Net ModeRunning Gear node in Dev Net mode
Dev net is helpful for the development and debugging of your smart contracts. You can upload your program directly to a local node, send messages to a program and validate the program's logic.
To run the Gear node in a dev net mode:


Compile or download nightly build for your operating system as described in setting-up.


Run the node in dev mode (we assume the executable is in /usr/bin directory):


gear --dev


Follow https://idea.gear-tech.io/ and connect to a local dev node. Click network selection via the left top button, choose Development -> Local node, and click the Switch button. Use the Idea portal for sending messages, reading the program's state, etc.


To purge any existing dev chain state, use:


gear purge-chain --dev

To start a dev chain with detailed logging, use:

RUST_LOG=debug RUST_BACKTRACE=1 gear -lruntime=debug --devEdit this pagePreviousBackup and RestoreNextMulti-Node Mode








Troubleshooting | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable ğŸš§StableEnglishEnglishç®€ä½“ä¸­æ–‡SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeSetting UpNode as a ServiceNode MonitoringBackup and RestoreDev Net ModeMulti-Node ModeNode FAQTroubleshootingDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksGear NodeTroubleshootingOn this pageTroubleshooting
Typical errors and solutions are described here.
Unavailable LOCK fileâ€‹


Error: IO error: While lock file /root/.local/share/gear/chains/gear_staging_testnet_v7/db/full/LOCK: Resource temporarily unavailable


Solution: You seem to be running several Gear node instances. Note that only one node instance is allowed to run. You likely have configured the node as a service and then ran the second instance from the command line. You should either stop the service or don't run the Gear node from the command line.
You can see the current node processes by running the command:
ps aux | grep gear
If you want to break all node processes you may run:
pkill -sigint gear
Note that the SystemD service can't be stopped by the command above. Run instead:
sudo systemctl stop gear-node


Unexpected argument when starting the node serviceâ€‹


Error: Found argument '\' which wasn't expected, or isn't valid in this context


Solution: The gear-node.service configuration file seems to be misconfigured. Some versions of SystemD do not accept the backslash character (\) as a line break. Therefore, it is better to write each of the config entry on one line.
Refer to https://wiki.gear-tech.io/node/node-as-service for properly configuring the node as a service.
Don't forget to restart the node after fixing the service configuration:
sudo systemctl daemon-reloadsudo systemctl restart gear-node


Corrupted data baseâ€‹


Error: Database version cannot be read from existing db_version file


Alternative error: Invalid argument: Column families not opened: ..., col2, col1, col0


Solution: The root of this problem is the lack of the disk free space. You may check the free space using the following command:
df -h
Also, you may check how many space is used by the blockchain DB:
du -h $HOME/.local/share/gear/chains/gear_staging_testnet_v7/db/full
Please refer to the System Requirements to see the minimum disk space required.
You need to free more space then purge the chain:
sudo systemctl stop gear-node# Provide more free space on the diskgear purge-chainsudo systemctl start gear-node


Node executable file obsolescenceâ€‹


Error: Verification failed for block <block-id> received from peer <peer-id>


Alternative error: runtime requires function imports which are not present on the host


Solution: Update the node binary to the latest version.


Masked serviceâ€‹


Error: Failed to start gear-node.service: Unit gear-node.service is masked.


Solution: Please check: https://askubuntu.com/questions/1017311/what-is-a-masked-service

Edit this pagePreviousNode FAQNextIntroductionUnavailable LOCK fileUnexpected argument when starting the node serviceCorrupted data baseNode executable file obsolescenceMasked service








Calculate gas | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable ğŸš§StableEnglishEnglishç®€ä½“ä¸­æ–‡SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGetting StartedKeyringCalculate GasUpload ProgramPay Program rentUpload CodeSend MessageRead StateVouchersMetadata & Type CreationMailboxEventsCookbookGear-JS toolsGeneral topicsGear-based NetworksGear-JSCalculate GasOn this pageCalculate gas
Gear nodes charge gas fees for all network operations, whether that be executing a programâ€™s code or processing a message. This gas is paid for by the initiator of these actions.
They guarantee successful message processing and to avoid errors like Gaslimit exceeded, you can simulate the execution in advance to calculate the exact amount of gas that will be consumed.
Calculate gas for messagesâ€‹
To find out the minimum gas amount required to send extrinsic, use api.program.calculateGas.[method]. Depending on the conditions, you can calculate gas for initializing a program or processing a message in handle() or reply().
infoGas calculation returns the GasInfo object, which contains 5 parameters:
min_limit - minimum gas limit required for the execution
reserved - gas amount that will be reserved for other on-chain interactions
burned - number of gas burned during message processing
may_be_returned - value that can be returned in some cases
waited - notifies that the message will be added to the waitlist

Init (for upload_program extrinsic)â€‹
const code = fs.readFileSync('demo_ping.opt.wasm');const gas = await api.program.calculateGas.initUpload(  '0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d', // source id  code,  '0x00', // payload  0,      // value  true,   // allow other panics);console.log(gas.toHuman());
Init (for create_program extrinsic)â€‹
const codeId = '0xâ€¦';const gas = await api.program.calculateGas.initCreate(  '0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d', // source id  codeId,  '0x00', // payload  0,      // value  true,   // allow other panics);console.log(gas.toHuman());
Handleâ€‹
import { getProgramMetadata } from '@gear-js/api';const metadata = await getProgramMetadata('0x' + fs.readFileSync('demo_new_meta.meta.txt'));const gas = await api.program.calculateGas.handle(  '0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d', // source id  '0xa178362715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d', // program id  {    id: {      decimal: 64,      hex: '0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d',    },  },      // payload  0,      // value  false,  // allow other panics  metadata,);console.log(gas.toHuman());
Reply to a messageâ€‹
import { getProgramMetadata } from '@gear-js/api';const metadata = await getProgramMetadata('0x' + fs.readFileSync('demo_async.meta.txt'));const gas = await api.program.calculateGas.reply(  '0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d', // source id  '0x518e6bc03d274aadb3454f566f634bc2b6aef9ae6faeb832c18ae8300fd72635', // message id  'PONG', // payload  0,      // value  true,   // allow other panics  metadata,);console.log(gas.toHuman());Edit this pagePreviousKeyringNextUpload ProgramCalculate gas for messagesInit (for upload_program extrinsic)Init (for create_program extrinsic)HandleReply to a message








program-rent | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable ğŸš§StableEnglishEnglishç®€ä½“ä¸­æ–‡SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGetting StartedKeyringCalculate GasUpload ProgramPay Program rentUpload CodeSend MessageRead StateVouchersMetadata & Type CreationMailboxEventsCookbookGear-JS toolsGeneral topicsGear-based NetworksGear-JSPay Program rentprogram-rentTo pay program rent, use the following JavaScript code:
// program.payRent has params:// programId// blockCount - number of blocks for which we want to extendconst tx = await api.program.payRent('0x...', 100_000);tx.signAndSend(account, (events) => {   events.forEach(({ event }) => console.log(event.toHuman()));});
You can calculate the current rent price using the following code:
const price = api.program.calculatePayRent(blockCount);
If a program was paused and its pages removed from storage, you can restore it using the api.program.resumeSession methods:

init: Start a new session to resume the program.
push: Push a bunch of program pages.
commit: Finish the resume session.

Here's how you can resume a paused program:
const program = await api.programStorage.getProgram(programId, oneBlockBeforePauseHash);const initTx = api.program.resumeSession.init({  programId,  allocations: program.allocations,  codeHash: program.codeHash.toHex(),});let sessionId;initTx.signAndSend(account, ({ events }) => {  events.forEach(({ event: { method, data } }) => {    if (method === 'ProgramResumeSessionStarted') {      sessionId = data.sessionId.toNumber();    }  });});const pages = await api.programStorage.getProgramPages(programId, program, oneBlockBeforePauseHash);for (const memPage of Object.entries(page)) {  const tx = api.program.resumeSession.push({ sessionId, memoryPages: [memPage] });  tx.signAndSend(account);}const tx = api.program.resumeSession.commit({ sessionId, blockCount: 20_000 });tx.signAndSend(account);Edit this pagePreviousUpload ProgramNextUpload Code








Send Message | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable ğŸš§StableEnglishEnglishç®€ä½“ä¸­æ–‡SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGetting StartedKeyringCalculate GasUpload ProgramPay Program rentUpload CodeSend MessageRead StateVouchersMetadata & Type CreationMailboxEventsCookbookGear-JS toolsGeneral topicsGear-based NetworksGear-JSSend MessageOn this pageSend Message
Use api.message.send method to send messages to the program:
try {  const message = {    destination: destination, // programId    payload: somePayload,    gasLimit: 10000000,    value: 1000,    // prepaid: true,    // account: accountId,    // if you send message with issued voucher  };  // In that case payload will be encoded using meta.types.handle.input type  let extrinsic = api.message.send(message, meta);  // So if you want to use another type you can specify it  extrinsic = api.message.send(message, meta, meta.types.other.input);} catch (error) {  console.error(`${error.name}: ${error.message}`);}try {  await extrinsic.signAndSend(keyring, (event) => {    console.log(event.toHuman());  });} catch (error) {  console.error(`${error.name}: ${error.message}`);}
noteIn real conditions to ensure successful message processing, the calculation of the required gas for processing the message should be performed by using api.program.calculateGas method.more info
Send reply messageâ€‹
When you need to reply to a message received from a program, use api.message.reply:
try {  const reply = {    replyToId: messageId,    payload: somePayload,    gasLimit: 10000000,    value: 1000,    // prepaid: true,    // account: accountId,    // if you send message with issued voucher  };  // In this case payload will be encoded using `meta.types.reply.input` type.  const extrinsic = api.message.sendReply(reply, meta);} catch (error) {  console.error(`${error.name}: ${error.message}`);}try {  await extrinsic(keyring, (events) => {    console.log(event.toHuman());  });} catch (error) {  console.error(`${error.name}: ${error.message}`);}Edit this pagePreviousUpload CodeNextRead StateSend reply message








Gear ä»‹ç» | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())è·³åˆ°ä¸»è¦å†…å®¹Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeä¸‹ä¸€é¡µUnstable ğŸš§ä¸‹ä¸€é¡µç®€ä½“ä¸­æ–‡Englishç®€ä½“ä¸­æ–‡æœç´¢æ¬¢è¿Intro to Gear Protocol5 åˆ†é’Ÿå¿«é€Ÿå…¥é—¨Gear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based Networksæ¬¢è¿æœ¬é¡µæ€»è§ˆGear ä»‹ç»æ¬¢è¿æ¥åˆ° Gear çš„æ–‡æ¡£é—¨æˆ·ã€‚è¿™æ˜¯ä¸€ä¸ªä¸­å¤®ä¿¡æ¯æºï¼Œä¾›æ¯ä¸ª äººå¯»æ‰¾å…³äº Gear çš„é‡è¦ä¿¡æ¯ã€æŒ‡å—å’Œå¼€å‘äººå‘˜çš„æ–‡æ¡£ã€‚
æˆ‘ä»¬çš„ Wiki æ¦‚è¿°äº†æ‰€éœ€çš„åŸºç¡€ä¿¡æ¯ã€ä¸€èˆ¬æŠ€æœ¯æ¦‚è¿°ã€Gear æŠ€æœ¯çš„ä¸»è¦ä¼˜åŠ¿ã€å¸®åŠ©å¼€å§‹è®¾ç½® Gear èŠ‚ç‚¹ã€å¦‚ä½•ä¸Šä¼ ä½ çš„æ™ºèƒ½åˆçº¦ï¼ŒåŒæ—¶è¿˜æä¾›å®Œæ•´çš„ API ç»†èŠ‚å’Œä¾‹å­ã€‚
æ‰€æœ‰çš„ä»£ç ã€åº“å’Œå·¥å…·éƒ½å¯ä»¥åœ¨ Github ä¸Šè·å¾—ï¼Œå¹¶é‡‡ç”¨ Apache-2.0 è®¸å¯è¯ã€‚æ¬¢è¿ä½¿ç”¨è¿™äº›å·¥å…·å’Œåº“ï¼Œè®°å½•ä½ å‘ç°çš„é—®é¢˜ï¼Œä¹Ÿå¯ä»¥ä¸ºä½ å‘ç°çš„ bug æˆ–å¢åŠ çš„åŠŸèƒ½åˆ›å»º PRã€‚
ç”±äºæˆ‘ä»¬çš„é¡¹ç›®æ­£åœ¨å‘å±•å’Œå£®å¤§ï¼Œæˆ‘ä»¬éå¸¸æ¬¢è¿ä½ çš„è´¡çŒ®ã€‚
ä»€ä¹ˆæ˜¯ Gear Protocolï¼Ÿâ€‹
Gear æ˜¯ä¸€ä¸ªåŸºäº Substrate çš„æ™ºèƒ½åˆçº¦å¹³å°ï¼Œä½¿ä»»ä½•äººéƒ½èƒ½åœ¨å‡ åˆ†é’Ÿå†…éƒ¨ç½²ä¸€ä¸ª dAppã€‚Gear æ˜¯è¿è¡Œæ™ºèƒ½åˆçº¦çš„æœ€å…·æˆæœ¬æ•ˆç›Šçš„æ–¹å¼ï¼Œè¿™äº›æ™ºèƒ½åˆçº¦æ˜¯ç”±è®¸å¤šæµè¡Œçš„ç¼–ç¨‹è¯­è¨€ï¼ˆå¦‚ Rustã€Cã€C++ ç­‰ï¼‰ç¼–è¯‘è€Œæˆã€‚å®ƒç¡®ä¿äº†éå¸¸ç®€çº¦ã€ç›´è§‚å’Œå……åˆ†çš„ APIï¼Œå¯ä»¥åœ¨å¤šä¸ªç½‘ç»œä¸Šè¿è¡Œæ–°å†™çš„å’Œç°æœ‰çš„ç¨‹åºï¼Œè€Œä¸å¿…é‡å†™ã€‚æ™ºèƒ½åˆçº¦å­˜å‚¨åœ¨åŒºå—é“¾çš„çŠ¶æ€ä¸­ï¼Œå¹¶è¢«è°ƒç”¨ï¼Œæ ¹æ®è¦æ±‚ä¿ç•™å…¶çŠ¶æ€ã€‚
Gear æ­£è®¡åˆ’æˆä¸º Polkadot å’Œ Kusama ç½‘ç»œä¸­çš„ä¸€ä¸ªå‡†æˆå‘˜ï¼Œåœ¨è¿™äº›å„è‡ªçš„ç½‘ç»œä¸­æ‰˜ç®¡æ™ºèƒ½åˆçº¦ã€‚è¿™å°†æ„å‘³ç€ï¼Œé€šè¿‡åœ¨ Gear ä¸Šçš„éƒ¨ç½²ï¼Œå¼€å‘è€…å°†èƒ½å¤Ÿä»¥æœ€å°çš„æˆæœ¬åˆ©ç”¨ Polkadot å’Œ Kusama çš„ç½‘ç»œåŠç”Ÿæ€ç³»ç»Ÿçš„æ‰€æœ‰å¥½å¤„ã€‚
Gear å°†é€šè¿‡ä½¿åˆ›æ–°çš„ dAppsã€å¾®æœåŠ¡ã€ä¸­é—´ä»¶å’Œå¼€æ”¾çš„ API  çš„è¿è¡Œï¼ŒååŠ©è¿‡æ¸¡åˆ°å¤§è§„æ¨¡ç”¨ Web3 æŠ€æœ¯ã€‚
What is Gear Network?â€‹
Gear Protocol provides the most cost-effective way to run smart contracts that have been compiled from many popular programming languages, such as Rust, C, C++ and many more.
Powered by Gear Protocol, Gear Networks imply a standalone L1 network as well as are planning on becoming a parachains in the Polkadot and Kusama networks to host smart contracts on these respective networks. This will mean that by deploying on Gear Network, developers would be able to take advantage of all the benefits of the Polkadot and Kusama networks and ecosystems at minimal cost.
å¦‚ä½•ä¸ Gear ç¤¾åŒºäº’åŠ¨â€‹
Githubâ€‹
æŠ€æœ¯è¯´æ˜å’Œå…¶ä»–å¼€å‘ç›¸å…³çš„å¯¹è¯å¯ä»¥åœ¨æˆ‘ä»¬çš„ Github ä¸­æ‰¾åˆ°ã€‚
Discordâ€‹
ç»¼åˆä¿¡æ¯å’ŒéæŠ€æœ¯ç›¸å…³çš„ä¿¡æ¯åŠå¯¹è¯å¯ä»¥åœ¨æˆ‘ä»¬çš„ Discord ä¸­æ‰¾åˆ°ã€‚
Twitterâ€‹
å…³æ³¨æˆ‘ä»¬çš„ Twitter ä»¥è·å–æœ€æ–°çš„æ¶ˆæ¯ã€‚
Telegramâ€‹
åŠ å…¥æˆ‘ä»¬çš„ç”µæŠ¥ç¾¤
å®˜æ–¹ç”µæŠ¥ç¾¤  ä¸­æ–‡ç”µæŠ¥ç¾¤
Mediumâ€‹
æˆ‘ä»¬å®šæœŸåœ¨æˆ‘ä»¬çš„ Medium é¢‘é“ ä¸Šå‘å¸ƒæ›´æ–°å’Œæ–‡ç« ã€‚ç¼–è¾‘æ­¤é¡µä¸‹ä¸€é¡µæœ¯è¯­è¡¨ä»€ä¹ˆæ˜¯ Gear Protocolï¼ŸWhat is Gear Network?å¦‚ä½•ä¸ Gear ç¤¾åŒºäº’åŠ¨GithubDiscordTwitterTelegramMedium








Read State | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable ğŸš§StableEnglishEnglishç®€ä½“ä¸­æ–‡SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGetting StartedKeyringCalculate GasUpload ProgramPay Program rentUpload CodeSend MessageRead StateVouchersMetadata & Type CreationMailboxEventsCookbookGear-JS toolsGeneral topicsGear-based NetworksGear-JSRead StateOn this pageRead State
There are two different ways to query the program State:

Query the full State of the program. To read the full State of the program, you need to have only the metadata of this program. You can call api.programState.read method to get the state.

import { GearApi } from '@gear-js/api';const api = await GearApi.create({  providerAddress: 'wss://testnet.vara-network.io',});await api.programState.read({ programId: '0xâ€¦' }, programMetadata);
Also, you can read the State of the program at some specific block specified by its hash:
await api.programState.read(  { programId: '0xâ€¦', at: '0xâ€¦' },  programMetadata,);

If you are using the custom functions to query only specific parts of the program State (see more), then you should call api.programState.readUsingWasm method:

// ...import { getStateMetadata } from '@gear-js/api';const stateWasm = readFileSync('path/to/state.meta.wasm');const metadata = await getStateMetadata(stateWasm);const state = await api.programState.readUsingWasm(  {    programId: '0xâ€¦',    fn_name: 'name_of_function_to_execute',    stateWasm,    argument: { input: 'payload' },  },  metadata,);
Cookbookâ€‹
To read state in JavaScript applications you can use fetch browser API to get buffer from meta.wasm:
// ...const res = await fetch(metaFile);const arrayBuffer = await res.arrayBuffer();const buffer = await Buffer.from(arrayBuffer);const metadata = await getStateMetadata(buffer);// get State only of the first walletconst firstState = await api.programState.readUsingWasm(  { programId: '0xâ€¦', fn_name: 'first_wallet', buffer },  metadata,);// get wallet State by idconst secondState = await api.programState.readUsingWasm(  { programId: '0xâ€¦', fn_name: 'wallet_by_id', buffer,  argument: { decimal: 1, hex: '0x01' } },  metadata,);Edit this pagePreviousSend MessageNextVouchersCookbook








Mailbox | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable ğŸš§StableEnglishEnglishç®€ä½“ä¸­æ–‡SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGetting StartedKeyringCalculate GasUpload ProgramPay Program rentUpload CodeSend MessageRead StateVouchersMetadata & Type CreationMailboxEventsCookbookGear-JS toolsGeneral topicsGear-based NetworksGear-JSMailboxOn this pageMailbox
The mailbox contains messages from the program that are waiting for user action.
Read messages from Mailboxâ€‹
const api = await GearApi.create();const mailbox = await api.mailbox.read(  '5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY',);console.log(mailbox);
Claim valueâ€‹
To claim value from a message in the mailbox use api.mailbox.claimValue.submit method.
const api = await GearApi.create();const submitted = await api.mailbox.claimValue.submit(messageId);await api.mailbox.claimValue.signAndSend(/* ... */);
Waitlistâ€‹
To read the program's waitlist use api.waitlist.read method.
const api = await GearApi.create();const programId = '0x1234â€¦';const waitlist = await api.waitlist.read(programId);console.log(waitlist);Edit this pagePreviousMetadata & Type CreationNextEventsRead messages from MailboxClaim valueWaitlist








Events | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable ğŸš§StableEnglishEnglishç®€ä½“ä¸­æ–‡SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGetting StartedKeyringCalculate GasUpload ProgramPay Program rentUpload CodeSend MessageRead StateVouchersMetadata & Type CreationMailboxEventsCookbookGear-JS toolsGeneral topicsGear-based NetworksGear-JSEventsOn this pageEvents
Events are generated for certain operations during execution. The following sections describe events that are part of the default Gear runtime.
To subscribe to all events:
const unsub = await api.query.system.events((events) => {  console.log(events.toHuman());});// Unsubscribeunsub();
Gear Events Typesâ€‹
MessageQueuedâ€‹
Summary: When a user successfully sends a message to a program and it gets added to the Gear message queue.
MessageQueued {    /// Generated id of the message.    id: MessageId,    /// Account id of the source of the message.    source: T::AccountId,    /// Program id, who is the message's destination.    destination: ProgramId,    /// Entry point for processing of the message.    /// On the sending stage, the processing function    /// of the program is always known.    entry: MessageEntry,}
UserMessageSentâ€‹
Summary: When someone has sent a message to the user.
UserMessageSent {    /// Message sent.    message: UserMessage,    /// Block number of expiration from `Mailbox`.    ///    /// Equals `Some(_)` with block number when message    /// will be removed from `Mailbox` due to some    /// reasons (see #642, #646 and #1010).    ///    /// Equals `None` if message wasn't inserted to    /// `Mailbox` and appears as only `Event`.    expiration: Option<T::BlockNumber>,}
UserMessageReadâ€‹
Summary: When a message has been marked as "read" and it has been removed from the Mailbox. This event only affects messages, which were already prior inserted into the Mailbox.
UserMessageRead {    /// Id of the message read.    id: MessageId,    /// The reason for the reading (removal from `Mailbox`).    ///    /// NOTE: See more docs about reasons at `gear_common::event`.    reason: UserMessageReadReason,}
MessagesDispatchedâ€‹
Summary: The result of when a message is processed within the block.
MessagesDispatched {    /// Total amount of messages removed from message queue.    total: MessengerCapacityOf<T>,    /// Execution statuses of the messages, which were already known    /// by `Event::MessageQueued` (sent from user to program).    statuses: BTreeMap<MessageId, DispatchStatus>,    /// Ids of programs, which state changed during queue processing.    state_changes: BTreeSet<ProgramId>,}
MessageWaitedâ€‹
Summary: When a message's execution has been delayed and it has been added to the Gear waitlist.
MessageWaited {    /// Id of the message waited.    id: MessageId,    /// Origin message id, which started messaging chain with programs,    /// where currently waited message was created.    ///    /// Used to identify by the user that this message associated    /// with him and the concrete initial message.    origin: Option<GasNodeId<MessageId, ReservationId>>,    /// The reason of the waiting (addition to `Waitlist`).    ///    /// NOTE: See more docs about reasons at `gear_common::event`.    reason: MessageWaitedReason,    /// Block number of expiration from `Waitlist`.    ///    /// Equals block number when message will be removed from `Waitlist`    /// due to some reasons (see #642, #646 and #1010).    expiration: T::BlockNumber,}
MessageWokenâ€‹
Summary: When a message is ready to continue its execution and has been removed from the Waitlist.
MessageWoken {    /// Id of the message woken.    id: MessageId,    /// The reason of the waking (removal from `Waitlist`).    ///    /// NOTE: See more docs about reasons at `gear_common::event`.    reason: MessageWokenReason,}
CodeChangedâ€‹
Summary: When a program's code has been altered.
CodeChanged {    /// Id of the code affected.    id: CodeId,    /// Change applied on code with current id.    ///    /// NOTE: See more docs about change kinds at `gear_common::event`.    change: CodeChangeKind<T::BlockNumber>,}
ProgramChangedâ€‹
Summary: Any data related to program changed.
ProgramChanged {    /// Id of the program affected.    id: ProgramId,    /// Change applied on program with current id.    ///    /// NOTE: See more docs about change kinds at `gear_common::event`.    change: ProgramChangeKind<T::BlockNumber>,}
ProgramResumeSessionStartedâ€‹
Summary: Program resume session has been started.
ProgramResumeSessionStarted {  /// Id of the session.  session_id: SessionId,  /// Owner of the session.  account_id: T::AccountId,  /// Id of the program affected.  program_id: ProgramId,  /// Block number when the session will be removed if not finished.  session_end_block: T::BlockNumber}        
Check what the event isâ€‹
api.query.system.events((events) => {  events    .filter(({ event }) => api.events.gear.MessageQueued.is(event))    .forEach(({ event: { data } }) => {      console.log(data.toHuman());    });  events    .filter(({ event }) => api.events.balances.Transfer.is(event))    .forEach(({ event: { data } }) => {      console.log(data.toHuman());    });});
Subscribe to specific gear eventsâ€‹
Subscribe to messages sent from a programâ€‹
const unsub = api.gearEvents.subscribeToGearEvent(  'UserMessageSent',  ({    data: {      message: { id, source, destination, payload, value, reply },    },  }) => {    console.log(`  messageId: ${id.toHex()}  source: ${source.toHex()}  payload: ${payload.toHuman()}  `);  },);// Unsubscribeunsub();
Subscribe to messages intended for a programâ€‹
const unsub = api.gearEvents.subscribeToGearEvent(  'MessageQueued',  ({ data: { id, source, destination, entry } }) => {    console.log({      messageId: id.toHex(),      programId: destination.toHex(),      userId: source.toHex(),      entry: entry.isInit        ? entry.asInit        : entry.isHandle        ? entry.asHandle        : entry.asReply,    });  },);// Unsubscribeunsub();
Subscribe to Transfer eventsâ€‹
const unsub = await api.gearEvents.subscribeToTransferEvents(  ({ data: { from, to, amount } }) => {    console.log(`    Transfer balance:    from: ${from.toHex()}    to: ${to.toHex()}    amount: ${+amount.toString()}    `);  },);// Unsubscribeunsub();
Subscribe to new blocksâ€‹
const unsub = await api.gearEvents.subscribeToNewBlocks((header) => {  console.log(    `New block with number: ${header.number.toNumber()} and hash: ${header.hash.toHex()}`,  );});// Unsubscribeunsub();Edit this pagePreviousMailboxNextCookbookGear Events TypesMessageQueuedUserMessageSentUserMessageReadMessagesDispatchedMessageWaitedMessageWokenCodeChangedProgramChangedProgramResumeSessionStartedCheck what the event isSubscribe to specific gear eventsSubscribe to messages sent from a programSubscribe to messages intended for a programSubscribe to Transfer eventsSubscribe to new blocks








Gear React application template | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable ğŸš§StableEnglishEnglishç®€ä½“ä¸­æ–‡SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGetting StartedKeyringCalculate GasUpload ProgramPay Program rentUpload CodeSend MessageRead StateVouchersMetadata & Type CreationMailboxEventsCookbookGear-JS toolsGear React application templateMeta CLIReact-hooksGeneral topicsGear-based NetworksGear-JSGear-JS toolsGear React application templateOn this pageGear React application template
Introducing Gear React Application Template: Accelerate Your Decentralized App Development
Are you looking to swiftly launch your decentralized application (dApp) on Gear-powered blockchains? Look no further! Gear React Application Template, also known as create-gear-app, is a pre-configured application template designed to streamline the development process. With its well-thought-out infrastructure and convenient features, it allows developers to quickly create and deploy their dApps on Gear-powered blockchains.
Gear React Application Template can be found on GitHub. This template is packed with a range of benefits and features that make it an ideal choice for developers seeking efficiency and simplicity in their dApp development workflow.
Featuresâ€‹
Let's delve into the key features that Gear React Application Template has to offer:


Gear API Connections: Integrating your dApp with Gear-powered blockchains is made seamless with pre-configured API connections, saving developers the hassle of manually setting up the necessary connections. By leveraging Gear's powerful infrastructure, developers can easily interact with the blockchain and access essential blockchain functionalities.


Login Interface: User authentication is a critical aspect of any application, and Gear React Application Template includes a pre-built login interface. This feature enables developers to quickly implement user authentication and securely manage user access to their dApps. With this functionality readily available, developers can focus on building the core features of their dApp without worrying about the authentication process.


Gear React-Hooks Support: Gear React Application Template is designed to take advantage of Gear's react-hooks library, providing developers with a smooth and intuitive development experience. The template includes all the necessary environments and configurations to seamlessly integrate react-hooks into your dApp.


Branded UI-Kit: User experience plays a crucial role in the success of any application. Gear React Application Template offers a branded UI-kit that ensures a visually appealing and consistent user interface. The UI-kit is designed to align with Gear's branding guidelines, providing developers with a head start in creating an attractive and professional-looking dApp. This feature allows developers to focus on developing the unique aspects of their application while maintaining a polished and cohesive design.


Gear React Application Template is an invaluable resource for various developers in the blockchain space. Whether you are a seasoned blockchain developer or just starting your journey, this template can significantly speed up your dApp development process. It simplifies the integration with Gear-powered blockchains, provides a robust login interface, offers support for Gear react-hooks, and includes a branded UI-kit for a visually appealing application.
Furthermore, Gear React Application Template is particularly beneficial for developers who prioritize efficiency and value a well-structured and standardized development workflow. By leveraging the template's pre-configured infrastructure, developers can save precious time and effort that would otherwise be spent on setting up and integrating the various components required for a blockchain application.
Installationâ€‹
Simply clone this repo to your local folder:
git clone https://github.com/gear-foundation/dapps-react-app.git d-appEdit this pagePreviousCookbookNextMeta CLIFeaturesInstallation








Gear Library | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable ğŸš§StableEnglishEnglishç®€ä½“ä¸­æ–‡SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsIntroductionGear LibraryMailboxState FunctionsMetadataData Encoding/DecodingAsynchronous ProgrammingCreate ProgramGas ReservationDelayed MessagesConsistency and ReliabilitySystem SignalsReply DepositUpload ProgramProgram RentProgram TestingTesting with gtestTesting with gclientSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksDeveloping Smart ContractsGear LibraryOn this pageGear Library
The Gear Protocolâ€™s library gstd provides all the necessary and sufficient functions and methods for developing smart-contracts.
Importing familiar types via preludeâ€‹
The gstd default prelude lists things that Rust automatically imports into every program. It re-imports default std modules and traits. std can be safely replaced with gstd in the Gear programs on Rust.
See more details here.
Message handlingâ€‹
The Gear Protocol allows users and programs to interact with other users and programs via messages. Messages can contain a payload that will be able to be processed during message execution. Interaction with messages is possible thanks to the module msg:
use gstd::msg;
Message processing is possible only inside the defined functions init(), handle(), hadle_reply(), and state(). They also define the context for processing such messages.

Get a payload of the message currently being processed and decode it:

#![no_std]use gstd::{msg, prelude::*};#[no_mangle]extern "C" fn handle() {    let payload_string: String = msg::load().expect("Unable to decode `String`");}

Reply to the message with payload:

#![no_std]use gstd::msg;#[no_mangle]extern "C" fn handle() {    msg::reply("PONG", 0).expect("Unable to reply");}

Send message to user:

#![no_std]use gstd::{msg, prelude::*};#[no_mangle]extern "C" fn handle() {    // ...    let id = msg::source();    let message_string = "Hello there".to_string();    msg::send(id, message_string, 0).expect("Unable to send message");}
You can see more cases of using the msg module in our documentation.
Execution infoâ€‹
A program can get some useful information about the current execution context by using the exec module:
use gstd::exec;

Send a reply after the block timestamp reaches the indicated date:

#![no_std]use gstd::{exec, msg};#[no_mangle]extern "C" fn handle() {    // Timestamp is in milliseconds since the Unix epoch    if exec::block_timestamp() >= 1672531200000 {        msg::reply(b"Current block has been generated after January 01, 2023", 0)            .expect("Unable to reply");    }}

Get self value balance of a program:

#![no_std]use gstd::exec;#[no_mangle]extern "C" fn handle() {    // Get self value balance in program    let my_balance = exec::value_available();}
You can read more about program syscalls here.
Logging inside the contractsâ€‹
Macro gstd::debug provides an ability to debug contract during program execution:
#![no_std]use gstd::{debug, msg, prelude::*};#[no_mangle]extern "C" fn handle() {    let payload_string: String = msg::load().expect("Unable to decode `String`");    debug!("Received message: {payload_string:?}");}
noteThe debug! macro is available only when the "debug" feature is enabled for the gstd crate.[dependencies]gstd = { git = "https://github.com/gear-tech/gear.git", tag = "v1.0.2", features = ["debug"] }Edit this pagePreviousIntroductionNextMailboxImporting familiar types via preludeMessage handlingExecution infoLogging inside the contracts








Store data | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable ğŸš§StableEnglishEnglishç®€ä½“ä¸­æ–‡SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsIntroductionGear LibraryMailboxState FunctionsMetadataData Encoding/DecodingAsynchronous ProgrammingCreate ProgramGas ReservationDelayed MessagesConsistency and ReliabilitySystem SignalsReply DepositUpload ProgramProgram RentProgram TestingTesting with gtestTesting with gclientSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksDeveloping Smart ContractsState FunctionsOn this pageStore data
Persistent data of the Gear smart contract is stored in the same way as in a classic program and does not require initialization of the external storage.
// Describe state structure#[derive(TypeInfo, Decode, Encode, Clone)]pub struct Wallet {    pub id: ActorId,    pub person: String,}// Declare and initialize the statestatic mut WALLETS: Vec<Wallet> = Vec::new();
If you're programming in Rust or other object-oriented languages, you should be familiar with most types. However, the ActorId type is something new when developing contracts via the Gear Protocol.
infoActorId is a special type that represents an 32 bytes array and defines any ID in Gear Protocol.
State functionsâ€‹
To display the contract state information, the state() function is used. It allows you to instantly read the contract status (for example, contract balance). Reading state is a free function and does not require gas costs.
Example of the returning all wallets defined above:
#[no_mangle]extern "C" fn state() {    msg::reply(unsafe { WALLETS.clone() }, 0).expect("Failed to share state");}
Additionally, you can handle incoming payload and return only the necessary part of the state. For example, you can return only the selected wallet:
#[no_mangle]extern "C" fn state() {    let index: usize = msg::load().expect("Unable to decode `usize`");    let wallets = unsafe { WALLETS.clone() };    if index < wallets.len() => {        msg::reply(wallets[index], 0).expect("Failed to share state");    } else {        panic!("Wallet index out of bounds");    }}
Custom program to read the stateâ€‹
Additionally, you can create your own program to read the state. This wrapper will allow you to implement custom functions for the client side, not depending on the main program.
This has a number of advantages, for example, you will always be able to read the state even if the program changes (as long as the incoming or outgoing types have not changed). Or you are creating a service based on an already existing program and you need some of your own functions to get your own chanks of data from the state.
To do this, we need to create an independent program and describe the necessary functions inside the metawasm trait. For example:
// ...use gmeta::metawasm;#[metawasm]pub mod metafns {    pub type State = Vec<Wallet>;    pub fn all_wallets(state: State) -> Vec<Wallet> {        state    }    pub fn first_wallet(state: State) -> Option<Wallet> {        state.first().cloned()    }    pub fn last_wallet(state: State) -> Option<Wallet> {        state.last().cloned()    }}
Or more complex example:
// ...use gmeta::metawasm;#[metawasm]pub mod metafns {    pub type State = Vec<Wallet>;    pub fn wallet_by_id(state: State, id: Id) -> Option<Wallet> {        state.into_iter().find(|w| w.id == id)    }    pub fn wallet_by_person(state: State, person: String) -> Option<Wallet> {        state.into_iter().find(|w| w.person == person)    }}
To build *.meta.wasm, the following build.rs file in the root of your project is required:
fn main() {    gear_wasm_builder::build_metawasm();}
Learn more how metadata works.Edit this pagePreviousMailboxNextMetadataState functionsCustom program to read the state








Data encoding/decoding | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable ğŸš§StableEnglishEnglishç®€ä½“ä¸­æ–‡SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsIntroductionGear LibraryMailboxState FunctionsMetadataData Encoding/DecodingAsynchronous ProgrammingCreate ProgramGas ReservationDelayed MessagesConsistency and ReliabilitySystem SignalsReply DepositUpload ProgramProgram RentProgram TestingTesting with gtestTesting with gclientSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksDeveloping Smart ContractsData Encoding/DecodingOn this pageData encoding/decoding
To optimize how data is sent and received over the network, Gear uses the parity-scale-codec - a Rust implementation of the SCALE Codec. This codec is used by the Substrate nodes' internal runtime. SCALE is a lightweight format that enables the serialization and deserialization of data. Encoding (and decoding) data using SCALE makes it highly suitable for resource-constrained execution environments like blockchain runtimes and low-power/low-memory devices.
To use SCALE codec in your program, you should add it in Cargo.toml:
[dependencies]// ...codec = { package = "parity-scale-codec", version = "3.6", default-features = false }
use codec::{Decode, Encode};#[derive(Encode, Decode)]enum MyType {    MyStruct { field: ... },    ...}
infoWe only need the Encode and Decode traits when using wrapped methods from gstd, such as: msg::load, msg::send, msg::reply, msg::send_for_reply etc.In methods like msg::load_bytes, msg::send_bytes, or msg::reply_bytes we operate with a set of bytes, so nothing needs to be decoded/encoded.
Learn more about SCALE Codec here.
scale-infoâ€‹
scale-info is a library to describe Rust types, intended for providing information about the structure of encodable SCALE types.
The definitions provide third party tools (e.g. a UI client) with information about how they are able to decode types agnostic of language. The interface that uses scale-info for Gear programs is called metadata. It defines incoming and outgoing types for all necessary entry points and allows contracts and the client part to understand each other.
infoLearn more how to use metadata in contract.
To use scale-info in your project:
[dependencies]// ...scale-info = { version = "2.9", default-features = false, features = ["derive"] }
Learn more about scale-info hereEdit this pagePreviousMetadataNextAsynchronous Programmingscale-info








Gas Reservation | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable ğŸš§StableEnglishEnglishç®€ä½“ä¸­æ–‡SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsIntroductionGear LibraryMailboxState FunctionsMetadataData Encoding/DecodingAsynchronous ProgrammingCreate ProgramGas ReservationDelayed MessagesConsistency and ReliabilitySystem SignalsReply DepositUpload ProgramProgram RentProgram TestingTesting with gtestTesting with gclientSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksDeveloping Smart ContractsGas ReservationGas Reservation
Gas reservation is the powerful feature of Gear Protocol that enables the new approach to smart-contract programming and modern use cases.
Briefly, a program can send a message using gas that was reserved before instead of using gas from the currently processing message.
One of the key advantage of this feature is an ability of sending messages delayed in time automatically to any actor in the network - a user or another smart contract as well as to itself. In fact, a program is able to execute itself unlimited number of blocks (provided that enough gas for execution is kept available).
A program developer can provide a special function in the program's code which takes some defined amount of gas from the amount available for this program and reserves it. A reservation gets a unique identifier that can be used by a program to get this reserved gas and use it later.
To reserve the amount of gas for further usage use the ReservationId::reserve function:
let reservation_id = ReservationId::reserve(RESERVATION_AMOUNT, TIME)    .expect("Reservation across executions");
You also have to indicate the block count within which the reserve must be used. Gas reservation is not free: the reservation for one block costs some gas. The reserve function returns ReservationId, which one can use for sending a message with that gas. To send a message using the reserved gas:
msg::send_from_reservation(reservation_id, program, payload, value)    .expect("Failed to send message from reservation");
If gas is not needed within the time specified during the reservation, it can be unreserved and the gas will be returned to the user who made the reservation.
id.unreserve().expect("Unreservation across executions");
Programs can have different executions, change state and evaluate somehow, but when it is necessary, a program can send a message with this reserved gas instead of using its own gas.
For example, let's consider the game that works completely on-chain. The players are smart contracts that compete with each other by implementing various playing strategies. Usually, in these types of games, there is a master contract that starts the game and controls the move order between the players.
To start the game, someone sends a message to the contract. The gas attached to this message is spent on the players' contracts, which in turn spend gas on their execution. Since the game can last quite a lot of rounds, the attached gas may not be enough to complete the game. You can send a message asking the program to continue the game, or you can use the gas reservation and make a fully automatic play.
Using gas reservation the contract will be able to hold the game without interruption.Edit this pagePreviousCreate ProgramNextDelayed Messages








Ensuring reliability in asynÑ programming | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable ğŸš§StableEnglishEnglishç®€ä½“ä¸­æ–‡SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsIntroductionGear LibraryMailboxState FunctionsMetadataData Encoding/DecodingAsynchronous ProgrammingCreate ProgramGas ReservationDelayed MessagesConsistency and ReliabilitySystem SignalsReply DepositUpload ProgramProgram RentProgram TestingTesting with gtestTesting with gclientSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksDeveloping Smart ContractsConsistency and ReliabilityOn this pageEnsuring reliability in asynÑ programming
One of the key features of the Gear Protocol is its use of the Actor model for message-passing communication. The Actor model framework enables asynchronous messaging and parallel computation, which  drastically improves the achievable speed and scalability of dApps. In the Actor model, programs do not share state and instead communicate with each other through messages. If a program sends an asynchronous message to another program, it has to wait for a reply from the other program before it can proceed with the next operation.
When a program interacts with another program, the transaction becomes "distributed." A distributed transaction is a set of operations performed across multiple databases or, in the case of the Gear Protocol, across multiple actors with their own states. Distributed transactions must possess these properties:

Atomicity - all data changes are treated as if they were a single operation. That is, either all of the modifications are made, or none of them are made;
Consistency - this property implies that when a transaction begins and ends, the state of data is consistent.

For example, transactions on the Ethereum blockchain are atomic, meaning that if a transaction fails due to an error, all of its effects on the global state are rolled back as if the transaction never occurred. Many blockchain applications rely on the atomicity of transactions, but this can be a problem when building asynchronous applications using the programming paradigm used on Ethereum, as you may encounter the problem of not being able to recover program state after a failed transaction.
Consider a simple token exchange where a user wants to swap tokens A for tokens B in a liquidity pool. The swap contract would send a message to the token A contract and a message to the token B contract. If one of these messages succeeds and the other fails for some reason, the state of the token A contract would be changed while the state of the token B contract would remain unchanged. This can cause inconsistencies in the state of the data and make it difficult to recover from failed transactions. As a result, it is important to consider different programming paradigms for implementing distributed transactions.
Let's look at different programming methods using the example of a token exchange.
Splitting a token swap transaction into 3 separate transactionsâ€‹
Consider the following situation: we have a liquidity pool of token A and token B, and also a user who wants to exchange his tokens A for tokens B.
Step 1 : A user sends a MakeOrder message to the swap contract. During that transaction the contract sends a message to the fungible token contract. The result of executing this message can be a success or a failure. The worst case scenario is having a lack of gas when processing a message in the token contract or in the subsequent execution of the swap contract. However, since the token contract supports idempotency, the user can simply restart the transaction and complete it.


Step 2:  A user sends an ExecuteOrder message to the swap contract. The swap contract just calculates the amount of tokens a user will receive and saves the new state of the liquidity poll.


Step 3:  A user sends a Withdraw message to the swap contract and receives tokens B. The situation here is the same as in the first step.


It is possible to execute a swap in one transaction. To resolve the problem of atomicity we can use the following patterns here:

2 PC - 2 Phase Commit protocol (And also its extension - 3 phase commit protocol);
Saga Pattern.

Two phase commit protocolâ€‹
Theory:
We have a coordinator that sends messages to participants. The two-phase commit protocol has two parts: the prepare phase and the commit phase.
Preparation phase:
During the preparation phase, the coordinator and participants perform the following dialog:

Coordinator:
The coordinator directs each participant database server to prepare to commit the transaction.
Participants:
Every participant notifies the coordinator whether it can commit to its transaction branch.
Coordinator:
The coordinator, based on the response from each participant, decides whether to commit or roll back the transaction. It decides to commit only if all participants indicate that they can commit to their transaction branches. If any participant indicates that it is not ready to commit to its transaction branch (or if it does not respond), the coordinator decides to end the global transaction.

Commit phase:
During the commit phase, the coordinator and participants perform the following dialog:

Coordinator:
The coordinator writes the commit record or rollback record to the coordinator's logical log and then directs each participant to either commit or roll back the transaction.
Participants:
If the coordinator issued a commit message, the participants commit the transaction by writing the commit record to the logical log and then sending a message to the coordinator acknowledging that the transaction was committed. If the coordinator issued a rollback message, the participants roll back the transaction but do not send an acknowledgment to the coordinator.
Coordinator:
If the coordinator issues a message to commit the transaction, it waits to receive acknowledgment from each participant before it ends the global transaction. If the coordinator issued a message to roll back the transaction, it does not wait for acknowledgments from the participants.

Let's see how it can be used in the example of a token swap contract. We consider the following situation: the account wants to exchange his tokens (letâ€™s call it tokenA) for other tokens (tokenB) using the liquidity pool in the swap contract.
In that case the swap contract is a coordinator contract and tokens contracts are participants.
The swap contract makes the following steps:
Prepare phase

Swap contract:
Swap contract sends the messages to token contracts to prepare transfer tokens (Messages can be sent in parallel). In fact, token contracts must lock funds at this stage.
Token contract:
Token contracts make all necessary checks, and in case of success, lock funds and reply to the swap contract that they are ready to make a transaction.
Swap contract:
Swap contract handles the messages from the token contracts and decides whether to commit or abort the global transaction.
receives tokens B. The situation here is the same as in the first step.



Commit phase

Swap contract:
If token contracts confirm their readiness to execute the transaction, the swap contract sends them a message to commit the state. Otherwise, the swap contract tells them to abort the transaction.
Token contract:
Token contracts finally change their state and send replies to the swap contract;
`Swap contracts:
Swap contract handles the messages from the token contracts and saves the result about transaction execution.



Of course, all that workflow handles the case when the gas runs out during the message execution.
Pros:

Messages can be sent in parallel;
If cases with a lack of gas are taken into account, then the data consistency is achieved.

Cons:

The participants have to wait for the message from the coordinator, they canâ€™t commit or abort themselves;
The coordinator plays an important role: if it fails to send the message then all participants go to the blocked state (in our example: the funds in token contracts are blocked).

Three phase commit protocol.â€‹
Theory: It is similar to two-phase commit protocol but it tries to solve the problems with blocking the state of participants and to give the participants the opportunity to recover their states themselves.
Prepare phase:
The same steps of two phase commit protocol are followed here:

Coordinator:
The coordinator sends a prepare message to all participants and waits for replies;
Participants:
If the participants are ready to commit a transaction they send the ready message, otherwise they send no message to the coordinator.
Coordinator:
Based on replies the coordinator decides either to go to the next state or not. If any of the participants respond with no message or if any of the participants fails to respond within a defined time, the coordinator sends an abort message to every participant.  It is important to highlight the differences from two phase commit protocol:

The coordinator limits the response time from the participant. We can implement this by sending a message with an indicated amount of gas or indicated number of blocks the coordinator is ready to wait;
If the coordinator fails at this state, then the participants are able to abort the transaction (i.e. unlock their state) using delayed messages. So, in that phase, the timeout cases abort.



Prepare-to-commit phase:

Coordinator:
The coordinator sends a prepare-to-commit message to all participants and gets acknowledgements from everyone;
Participants:
Receiving a prepare-to-commit message, a participant knows that the unanimous decision was to commit. As was already mentioned in the prepare phase, if a participant fails to receive this message in time, then it aborts. However, if a participant receives an abort message then it can immediately abort the transaction.
The possible problem: the coordinator fails during sending a prepare-to-commit to participants. So some participants are in phase 2, others are in phase 1. It's a disaster because the first group will commit, the second group will abort in case of timeout.
So we have to make sure that If one of the participants has received a precommit message, they can all commit. If the coordinator falls, any of the participants, being at the second stage, can become the coordinator itself and continue the transaction.
Coordinator:
Having received acknowledgements from all the participants, the coordinator goes to the next phase.

The three-phase commit protocol accomplishes two things:

Enables use of a recovery coordinator (it can be a coordinator itself that starts a new transaction, or a participant). If a coordinator died, a recovery coordinator can query a participant.

If the participant is found to be in phase 2, that means that every participant has completed phase 1 and voted on the outcome. The completion of phase 1 is guaranteed. It is possible that some participants may have received commit requests (phase 3). The recovery coordinator can safely resume at phase 2.
If the participant was in phase 1, that means NO participant has started commits or aborts. The protocol can start at the beginning.
If the participant was in phase 3, the coordinator can continue in phase 3 â€“ and make sure everyone gets the commit/abort request


Every phase can now time out â€“ there is no indefinite wait as in the two-phase commit protocol.

Phase 1:
Participant aborts if it doesnâ€™t hear from a coordinator in time;
Coordinator sends aborts to all if it doesnâ€™t hear from any participant.
Phase 2:
If a participant times out waiting for a coordinator, elect a new coordinator.



Letâ€™s get back to our swap contract.
Preparation phase:
The following cases are possible:

all token contracts receive the message;
the swap contract fails to wait for response from any token contract
the swap contract fails itself.

In the case of a fall, if a transaction isn't restarted, the swap contract will not move to the second phase and the token contracts will unlock their state using delayed messages.


Pre-Commit phase:
At this stage we can have a failure in the swap contract or in the token contract only due to the lack of gas.  To solve this problem we can use gas reservation as follows:

The swap contract receives the information about error in its handle_signal;
Using gas reservation (so, itâ€™s necessary to care about gas reservations before), the swap contract sends a message to itself to restart the transaction from the second phase. (The same logic can also be used in the preparation phase).



Commit phase:
As in the previous stage we can have a failure only due to the lack of gas. Here it is not so critical, since at this stage all participants can commit themselves.
Saga patternâ€‹
Theory:
A saga is a sequence of local transactions. Each local transaction updates the database and publishes a message or event to trigger the next local transaction in the saga. If a local transaction fails because it violates a business rule then the saga executes a series of compensating transactions that undo the changes that were made by the preceding local transactions. Thus, Saga consists of multiple steps whereas 2PC acts like a single request.
There are two ways of coordination sagas:

Choreography - each local transaction publishes domain events that trigger local transactions in other services;
Orchestration - an orchestrator (object) tells the participants what local transactions to execute.

We will consider the orchestration based Saga where there would be an orchestrator (swap contract) to manage the entire operation from one center.
The swap operation consists of the following steps:

Swap contract receives a message to exchange tokens in the liquidity pool. So, it must transfer tokens A from the account to its address and then transfer tokens B to the user.
It creates the first task: transfer tokens from the user to the swap contract. It also creates a compensating transaction for the first task: transfer tokens from the swap contract back to the user. The second task is to transfer tokens from the swap contract to the user.
It starts executing the first task. If the execution fails, it cancels the transaction. If itâ€™s successful, the swap contract executes the second task;
If the execution of the second task is successful, the transaction is completed. Otherwise, the swap contract executes the compensation transaction for the first task.



It is important to note that compensatory transactions should not fail due to any logical error. They can only fall due to lack of gas. If this happens, then you need to restart the transaction again or use the gas reservation. The idempotency of the token contract guarantees that the transaction will be completed to the end without any duplicate transactions.Edit this pagePreviousDelayed MessagesNextSystem SignalsSplitting a token swap transaction into 3 separate transactionsTwo phase commit protocolThree phase commit protocol.Saga pattern








System signals | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable ğŸš§StableEnglishEnglishç®€ä½“ä¸­æ–‡SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsIntroductionGear LibraryMailboxState FunctionsMetadataData Encoding/DecodingAsynchronous ProgrammingCreate ProgramGas ReservationDelayed MessagesConsistency and ReliabilitySystem SignalsReply DepositUpload ProgramProgram RentProgram TestingTesting with gtestTesting with gclientSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksDeveloping Smart ContractsSystem SignalsSystem signals
The Gear Protocol ensures system and program's state consistency via introducing special handling mechanisms for potential issues and corner cases.
Gear actors have three common entry points - init, handle, handle_reply. Another special system entry point introduced by the Gear Protocol is handle_signal. It allows the system to communicate with programs if it is necessary to notify (signal) that some event related to the program's messages has happened. Only the system (Gear node runtime) can send signal messages to a program.
First of all, it can be useful to free up resources occupied by the program. A custom async logic in Gear implies storing Futures in a program's memory. The execution context of Futures can occupy some significant amount of memory in the case of many futures. When a program sends a message and waits for a reply to be woken, the reply can not be received. So there might be the case that if the initial message in the waitlist runs out of gas or the gas amount is not enough to properly finish the execution, the programâ€™s state will be rolled back and Future will never be freed.
In this case, Futures remain in memory pages forever. Other messages are not aware of Futures associated with other messages. Over time, Futures accumulate in the program's memory so eventually a large amount of Futures limits the max amount of space the program can use.
In case a message has been removed from the waitlist due to gas constraints, the system sends a system message (signal) that is baked by an amount of reserved gas, which informs the program that itâ€™s message was removed from the waitlist. Based on this info, a program can clean up its used system resources (Futures).
The gstd library provides a separate exec::system_reserve_gas function for reserving gas specifically for system signal messages. It cannot be used for sending other regular cross-actor messages:
exec::system_reserve_gas(1_000_000_000).expect("Error during system gas reservation");
Even if this function hasn't been called, the system will reserve gas for system messages automatically with the default amount of 1_000_000_000.
If a signal message appears, it uses gas specifically reserved for such kinds of messages. If no gas has been reserved for system messages, they are just skipped and the program will not receive them.
If gas has been reserved but no system messages occur during the current execution, then this gas returns back from where it was taken. The same relates to gas reserved for non-system messages - gas returns back after a defined number of blocks or by the programâ€™s command.
handle_signal has a default implementation if the smart contract has async init or/and async main functions (see Asynchronous Programming for more details about async entry points). To define your own signal handler, you need to use the gstd::async_init/gstd::async_main macro with the specified handle_signal argument. For example:
#[gstd::async_main(handle_signal = my_handle_signal)]async fn main() {    // ...}fn my_handle_signal() {    // ...}
infoNote that the custom signal handler derives its default behavior.
Some useful functions that can be used in handle_signal:

msg::signal_from - returns an identifier of the message which caused the signal;
msg::signal_code - returns the reason code of the signal (see SignalCode enum for more details).

It can be useful for a developer when writing communication between programs. Developer can define my_handle_signal function and implement some logic there. For example, Program A sent a message to Program B. Program A is waiting for a reply from Program B but Program B runs out of gas. The current execution will be interrupted, but the system will send a signal to Program A and indicates the message identifier during which the execution was interrupted.
So, Program A sends a message and saves the message identifier:
exec::system_reserve_gas(2_000_000_000)    .expect("Error during system gas reservation");let result = msg::send_for_reply(address, payload, value, reply_deposit);let (msg_id, msg_future) = if let Ok(msg_future) = result {    (msg_future.waiting_reply_to, msg_future)} else {    // handle the error here};// save the `msg_id` in program stateunsafe { STATE.msg_id == msg::id() };let reply = msg_future.await;
The execution fails in Program B, and Program A receives a signal:
#[no_mangle]extern "C" fn my_handle_signal() {    if unsafe { STATE.msg_id == msg::signal_from() } {        // write logic here    }}
However, it is important to understand that the execution of my_handle_signal should not be long and should not consume a lot of gas. It can be used for tracking failures during the transaction. The program can use the information about failures the next time it is executed.
For programs written using the Gear Protocol's gstd library, such signals can be sent to programs automatically under the hood when applicable. If a smart contract developer implements a program using gcore or Gear's syscalls, then such signals should be considered in the program's code explicitly.Edit this pagePreviousConsistency and ReliabilityNextReply Deposit








Glossary | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable ğŸš§StableEnglishEnglishç®€ä½“ä¸­æ–‡SearchWelcome!Intro to Gear ProtocolWhy do we build Gear?Gear Distinctive FeaturesGear Protocol TechnologyGlossaryGetting StartedGear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksIntro to Gear ProtocolGlossaryOn this pageGlossary
Accountâ€‹
In cryptocurrency systems, a user is represented by an account that has an address(es) with specific balances associated with their address. Besides that, an account can contain additional details such as contact information, eligibility for rewards, and more.
Actorâ€‹
A computational entity that, in response to a message it receives, can concurrently: send a finite number of messages to other actors; create a finite number of new actors; designate the behavior to be used for the next message it receives.
Actor Modelâ€‹
The principle of the Actor model approach for communication is that programs never share any state and just exchange messages between each other.
Blockchainâ€‹
A blockchain is a decentralized and distributed system of recording information in ways that make it almost impossible to change, hack or manipulate.
Blockâ€‹
A data structure in the blockchain database, where transaction data in a cryptocurrency blockchain are permanently recorded. A block records some or all of the most recent transactions not yet validated by the network. Once the data is validated, the block is closed.
Block heightâ€‹
A number of blocks preceding it in the blockchain.
Block hashâ€‹
A unique hash of the block that is aimed to maintain the integrity of the data stored in the block.
Bridgesâ€‹
Bridges are ways for two economically sovereign blockchains to communicate with each other.
Collatorsâ€‹
Collators maintain parachains by collecting parachain transactions from users and producing state transition proofs for Relay Chain validators.
Decentralized Application (dApp)â€‹
A Decentralized Application, or dApp for short, is an application that can operate autonomously, typically through the use of smart contracts, that runs on a blockchain network.
Decentralized Autonomous Organization (DAO)â€‹
A Decentralized Autonomous Organization, or DAO for short, is an organization thatâ€™s represented by rules encoded in a smart contract that is transparent and controlled by the organization members instead of being influenced by central entities.
Decentralized Finance (DeFi)â€‹
Decentralized Finance, or DeFi for short, are financial services that are powered by decentralized applications and blockchain technology.
Layer-0 protocolâ€‹
The ground floor for all blockchain protocols. Examples of operating Layer 0 blockchains include Kusama and Polkadot.
Layer-1 blockchain protocolâ€‹
A term used to describe the underlying main blockchain architecture. Itâ€™s a set of solutions that improve the base protocol itself to make the overall system more scalable. The two approaches proposed for implementing Layer 1 solutions include the consensus protocol and sharding. Examples of operating Layer-1 blockchains include Bitcoin, Ethereum etc.
Layer-2 blockchain protocolâ€‹
A secondary framework or protocol that is built on top of an existing blockchain system. The main goal of these protocols is to solve the transaction speed and scaling difficulties that are being faced by the major cryptocurrency networks.
Ledgerâ€‹
A list of entries containing transactions signed by account owners. A blockchain is a type of distributed ledger.
Memory Parallelismâ€‹
Memory-level parallelism is a term in computer architecture referring to the ability to have pending multiple memory operations, in particular, cache misses or translation lookaside buffer misses, at the same time.
Nodeâ€‹
A computer device that runs on a blockchain network for message processing; it can also be a validator (block producer). Node makes the information available to everyone via a connected device.
Non-Fungible Tokens (NFTs)â€‹
A Non-Fungible Token is a unique unit of data thatâ€™s represented as a cryptographic token thatâ€™s stored on a blockchain.
Parachainâ€‹
Parachains are application specific data structures that are integrated into the Polkadot and Kusama networks by connecting to the main Relay Chain. They enable transactions to be spread out and processed in parallel over an ecosystem.
Polkadotâ€‹
Polkadot is an open-source blockchain network that is aiming to enable cross-chain communication between different blockchain networks.
Relay Chainâ€‹
The Relay Chain is the central chain of the Polkadot network. It is responsible for the networks' shared security, consensus and transaction settlements.
Rustâ€‹
A multi-paradigm, general-purpose programming language designed for performance and safety, especially safe concurrency. Rust is syntactically similar to C++.
Shardingâ€‹
Sharding is the process of dividing a blockchainâ€™s database into smaller â€œshardsâ€ to spread the transactional load to help make the network more scalable.
Smart Contractsâ€‹
A smart contract is a transactional computer program that can execute transactions automatically once certain conditions have been met, without any intervention.
Substrateâ€‹
Substrate is the modular framework for building customized blockchains and the foundation for the whole Polkadot ecosystem. Substrate allows developers to quickly build and launch a blockchain that will be capable of connecting to the Polkadot or Kusama networks.
Transactionâ€‹
A record in a digital ledger that represents an atomic event in a blockchain. In the case of Gear Protocol transactions can be of four types: create a program; send a message; dequeue messages; balance transfers.
Validatorâ€‹
A node that verifies transactions on a blockchain and produces blocks.
Walletâ€‹
A blockchain wallet is an application that allows users to store and manage their cryptocurrencies.
Web3â€‹
Web3 is the third evolution of the internet that is heavily supported by blockchain technology and decentralized applications.
WebAssembly (Wasm)â€‹
WebAssembly is a way to run applications in programming languages other than JavaScript as web pages. Essentially, Wasm is just a binary code format to be executed on a virtual machine that runs on all modern browsers. But whereas in the past you were required to use JavaScript to run code on a web page, Wasm makes it possible to run code in browsers written in programming languages other than JavaScript.
While the first implementations of Wasm virtual machines have landed in web browsers, there are also non-browser implementations for general-purpose use, including Wasmer, Wasmtime, etc.Edit this pagePreviousState TransitionNextGetting StartedAccountActorActor ModelBlockchainBlockBlock heightBlock hashBridgesCollatorsDecentralized Application (dApp)Decentralized Autonomous Organization (DAO)Decentralized Finance (DeFi)Layer-0 protocolLayer-1 blockchain protocolLayer-2 blockchain protocolLedgerMemory ParallelismNodeNon-Fungible Tokens (NFTs)ParachainPolkadotRelay ChainRustShardingSmart ContractsSubstrateTransactionValidatorWalletWeb3WebAssembly (Wasm)








Program Rent | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable ğŸš§StableEnglishEnglishç®€ä½“ä¸­æ–‡SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsIntroductionGear LibraryMailboxState FunctionsMetadataData Encoding/DecodingAsynchronous ProgrammingCreate ProgramGas ReservationDelayed MessagesConsistency and ReliabilitySystem SignalsReply DepositUpload ProgramProgram RentProgram TestingTesting with gtestTesting with gclientSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksDeveloping Smart ContractsProgram RentOn this pageProgram Rent
Gear Protocol utilizes a rent-based program management system. When developers upload a program (smart contract) to the network, its expiration date is assigned. The expiration period is measured in blocks.
After the expiration date, the program is automatically removed from storage, unless the owner chooses to extend its life by paying rent. The owner must indicate the number of additional blocks they can pay for, and they need to pay the rent in utility tokens to keep the program active beyond its initial expiration date.
infoCurrent initial rent period: 5,000,000 blocks (on Vara it will be around 173 days)
After uploading a program, you can observe a similar event:
gear.ProgramChanged
{    "id": "0xde76e4cf663ff825d94944d6f060204e83fbb5e24f8dfdbbdc25842df4f4135d",    "change": {        "Active": {            "expiration": "12,834,248"        }    }}
How to extend the rent of the program?â€‹
To extend the rent period of a program, simply call the special extrinsic gear.payProgramRent(programId, blockCount). See more
Can I restore a deleted program?â€‹
Yes. Since the blockchain stores all states for the entire history, you can restore the program's state to the previous block before it was deleted.
Why does Gear use the program rent system?â€‹

Optimization and efficient resource usage
Stimulating utility token usage
Edit this pagePreviousUpload ProgramNextProgram TestingHow to extend the rent of the program?Can I restore a deleted program?Why does Gear use the program rent system?








Testing with gtest | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable ğŸš§StableEnglishEnglishç®€ä½“ä¸­æ–‡SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsIntroductionGear LibraryMailboxState FunctionsMetadataData Encoding/DecodingAsynchronous ProgrammingCreate ProgramGas ReservationDelayed MessagesConsistency and ReliabilitySystem SignalsReply DepositUpload ProgramProgram RentProgram TestingTesting with gtestTesting with gclientSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksDeveloping Smart ContractsTesting with gtestOn this pageTesting with gtest
gtest simulates a real network by providing mockups of the user, program, balances, mailbox, etc. Since it does not include parts of the actual blockchain, it is fast and lightweight. But being a model of the blockchain network, gtest cannot be a complete reflection of the latter.
As we said earlier, gtest is excellent for unit and integration testing. It is also helpful for debugging Gear program logic. Nothing other than the Rust compiler is required for running tests based on gtest. It is predictable and robust when used in continuous integration.
Import gtest libâ€‹
To use the gtest library, you must import it into your Cargo.toml file in the [dev-dependencies] block to fetch and compile it for tests only:
[package]name = "first-gear-app"version = "0.1.0"authors = ["Your Name"]edition = "2021"[dependencies]gstd = { git = "https://github.com/gear-tech/gear.git", tag = "v1.0.2" }[build-dependencies]gear-wasm-builder = { git = "https://github.com/gear-tech/gear.git", tag = "v1.0.2" }[dev-dependencies]gtest = { git = "https://github.com/gear-tech/gear.git", tag = "v1.0.2" }
gtest capabilitiesâ€‹

Initialization of the common environment for running smart contracts:

    // This emulates node's and chain's behavior.    //    // By default, sets:    // - current block equals 0    // - current timestamp equals UNIX timestamp of your system.    // - minimal message id equal 0x010000..    // - minimal program id equal 0x010000..    let sys = System::new();

Program initialization:

    // Initialization of program structure from file.    //    // Takes as arguments reference to the related `System` and the path to wasm binary relatively    // the root of the crate where the test was written.    //    // Sets free program id from the related `System` to this program. For this case it equals 0x010000..    // Next program initialized without id specification will have id 0x020000.. and so on.    let _ = Program::from_file(        &sys,        "./target/wasm32-unknown-unknown/release/demo_ping.wasm",    );    // Also, you may use the `Program::current()` function to load the current program.    let _ = Program::current(&sys);    // We can check the id of the program by calling `id()` function.    //    // It returns `ProgramId` type value.    let ping_pong_id = ping_pong.id();    // There is also a `from_file_with_id` constructor to manually specify the id of the program.    //    // Every place in this lib, where you need to specify some ids,    // it requires generic type 'ID`, which implements `Into<ProgramIdWrapper>`.    //    // `ProgramIdWrapper` may be built from:    // - u64;    // - [u8; 32];    // - String;    // - &str;    // - ProgramId (from `gear_core` one's, not from `gstd`).    //    // String implementation means the input as hex (with or without "0x")    // Numeric    let _ = Program::from_file_with_id(        &sys,        105,        "./target/wasm32-unknown-unknown/release/demo_ping.wasm",    );    // Hex with "0x"    let _ = Program::from_file_with_id(        &sys,        "0xe659a7a1628cdd93febc04a4e0646ea20e9f5f0ce097d9a05290d4a9e054df4e",        "./target/wasm32-unknown-unknown/release/demo_ping.wasm",    );    // Hex without "0x"    let _ = Program::from_file_with_id(        &sys,        "e659a7a1628cdd93febc04a4e0646ea20e9f5f0ce097d9a05290d4a9e054df5e",        "./target/wasm32-unknown-unknown/release/demo_ping.wasm",    );    // Array [u8; 32] (e.g. filled with 5)    let _ = Program::from_file_with_id(        &sys,        [5; 32],        "./target/wasm32-unknown-unknown/release/demo_ping.wasm",    );    // If you initialize program not in this scope, in cycle, in other conditions,    // where you didn't save the structure, you may get the object from the system by id.    let _ = sys.get_program(105);

Getting the program from the system:

    // If you initialize program not in this scope, in cycle, in other conditions,    // where you didn't save the structure, you may get the object from the system by id.    let _ = sys.get_program(105);

Initialization of styled env_logger:

    // Initialization of styled `env_logger` to print logs (only from `gwasm` by default) into stdout.    //    // To specify printed logs, set the env variable `RUST_LOG`:    // `RUST_LOG="target_1=logging_level,target_2=logging_level" cargo test`    //    // Gear smart contracts use `gwasm` target with `debug` logging level    sys.init_logger();

Sending messages:

    To send message to the program need to call one of two program's functions:    // `send()` or `send_bytes()` (or `send_with_value` and `send_bytes_with_value` if you need to send a message with attached funds).    //    // Both of the methods require sender id as the first argument and the payload as second.    //    // The difference between them is pretty simple and similar to `gstd` functions    // `msg::send()` and `msg::send_bytes()`.    //    // The first one requires payload to be CODEC Encodable, while the second requires payload    // implement `AsRef<[u8]>`, that means to be able to represent as bytes.    //    // `send()` uses `send_bytes()` under the hood with bytes from payload.encode().    //    // First message to the initialized program structure is always the init message.    let res = program.send_bytes(100001, "INIT MESSAGE");

Processing the result of the program execution:

    // Any sending functions in the lib returns `RunResult` structure.    //    // It contains the final result of the processing message and others,    // which were created during the execution.    //    // It has 4 main functions.    // Returns the reference to the Vec produced to users messages.    // You may assert them as you wish, iterating through them.    assert!(res.log().is_empty());    // Returns bool which shows that there was panic during the execution    // of the main message.    assert!(!res.main_failed());    // Returns bool which shows that there was panic during the execution    // of the created messages during the main execution.    //    // Equals false if no others were called.    assert!(!res.others_failed());    // Returns bool which shows that logs contain a given log.    //    // Syntax sugar around `res.log().iter().any(|v| v == arg)`.    assert!(!res.contains(&Log::builder()));    // To build a log for assertion you need to use `Log` structure with its builders.    // All fields here are optional.    // Assertion with Logs from core are made on the Some(..) fields    // You will run into panic if you try to set the already specified field.    //    // Constructor for success log.    let _ = Log::builder();    // Constructor for error reply log.    //    // Note that error reply never contains payload.    // And its exit code equals 1, instead of 0 for success replies.    let _ = Log::error_builder();    // Letâ€™s send a new message after the program has been initialized.    // The initialized program expects to receive a byte string "PING" and replies with a byte string "PONG".    let res = ping_pong.send_bytes(100001, "PING");    // Other fields are set optionally by `dest()`, `source()`, `payload()`, `payload_bytes()`.    //    // The logic for `payload()` and `payload_bytes()` is the same as for `send()` and `send_bytes()`.    // First requires an encodable struct. The second requires bytes.    let log = Log::builder()        .source(ping_pong_id)        .dest(100001)        .payload_bytes("PONG");    assert!(res.contains(&log));    let wrong_log = Log::builder().source(100001);    assert!(!res.contains(&wrong_log));    // Log also has `From` implementations from (ID, T) and from (ID, ID, T),    // where ID: Into<ProgramIdWrapper>, T: AsRef<[u8]>    let x = Log::builder().dest(5).payload_bytes("A");    let x_from: Log = (5, "A").into();    assert_eq!(x, x_from);    let y = Log::builder().dest(5).source(15).payload_bytes("A");    let y_from: Log = (15, 5, "A").into();    assert_eq!(y, y_from);    assert!(!res.contains(&(ping_pong_id, ping_pong_id, "PONG")));    assert!(res.contains(&(1, 100001, "PONG")));

Spending blocks:

    // You may control time in the system by spending blocks.    //    // It adds the amount of blocks passed as arguments to the current block of the system.    // Same for the timestamp. Note, that for now 1 block in Gear network is 1 sec duration.    sys.spend_blocks(150);

Balance:

    // If you need to send a message with value you have to mint balance for the message sender:    let user_id = 42;    sys.mint_to(user_id, 5000);    assert_eq!(sys.balance_of(user_id), 5000);    // To give the balance to the program you should use `mint` method:    let prog = Program::current(&sys);    prog.mint(1000);    assert_eq!(prog.balance(), 1000);Edit this pagePreviousProgram TestingNextTesting with gclientImport gtest libgtest capabilities








Testing with gclient | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable ğŸš§StableEnglishEnglishç®€ä½“ä¸­æ–‡SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsIntroductionGear LibraryMailboxState FunctionsMetadataData Encoding/DecodingAsynchronous ProgrammingCreate ProgramGas ReservationDelayed MessagesConsistency and ReliabilitySystem SignalsReply DepositUpload ProgramProgram RentProgram TestingTesting with gtestTesting with gclientSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksDeveloping Smart ContractsTesting with gclientOn this pageTesting with gclient
gclient is intended to be used as a tool for testing Gear programs with a real blockchain network. It allows you to send extrinsics and RPCs by connecting to the network. We recommend using gclient for end-to-end testing to ensure the program works as expected in the real blockchain world.
It is essential to underline that testing with gclient requires the running node as the second part of the test suite. The gclient interacts with the node over the WebSocket protocol. Depending on the purpose of testing, gclient can communicate with either a local or a remote node. The best choice is to use the local node in developer mode for initial debugging and continuous integration.
Testing with gclient is slower than gtest and produces more build artifacts, so it is better suited as the last mile in quality control. However, gclient gives the most accurate test results.
Import gclient libâ€‹
To use the gclient library, you must import it into your Cargo.toml file in the [dev-dependencies] block. Also, you need to add some external crates that are used together with gclient:
[package]name = "first-gear-app"version = "0.1.0"authors = ["Your Name"]edition = "2021"[dependencies]gstd = { git = "https://github.com/gear-tech/gear.git", tag = "v1.0.2", features = ["debug"] }[build-dependencies]gear-wasm-builder = { git = "https://github.com/gear-tech/gear.git", tag = "v1.0.2" }[dev-dependencies]gclient = { git = "https://github.com/gear-tech/gear.git", tag = "v1.0.2" }tokio = { version = "1", features = ["full"] }
Running the nodeâ€‹
The best way is to download the latest node binary for your operating system from https://get.gear.rs. Then unpack the package and run the node. Here and below, we assume the node is running in developer mode.
Windows x64MacOS ARMMacOS x64Linux x64curl -O https://get.gear.rs/gear-nightly-x86_64-pc-windows-msvc.ziporWindows x64: gear-nightly-x86_64-pc-windows-msvc.zipUnzip the downloaded package, then run:gear.exe --devTerminal:wget https://get.gear.rs/gear-nightly-aarch64-apple-darwin.tar.xz && \tar xvf gear-nightly-aarch64-apple-darwin.tar.xz && \rm gear-nightly-aarch64-apple-darwin.tar.xzRun the node in development mode:./gear --devTerminal:wget https://get.gear.rs/gear-nightly-x86_64-apple-darwin.tar.xz && \tar xvf gear-nightly-x86_64-apple-darwin.tar.xz && \rm gear-nightly-x86_64-apple-darwin.tar.xzRun the node in development mode:./gear --devTerminal:wget https://get.gear.rs/gear-nightly-x86_64-unknown-linux-gnu.tar.xz && \tar xvf gear-nightly-x86_64-unknown-linux-gnu.tar.xz && \rm gear-nightly-x86_64-unknown-linux-gnu.tar.xzRun the node in development mode:./gear --dev
Open the second terminal window and run tests using cargo as it was described in the previous section.
Simple exampleâ€‹
Let's add an end-to-end test to our first-gear-app introduced in the Getting Started section.
Add the tests directory next to the src directory and create the end2end.rs file in it.
â””â”€â”€ first-gear-app    â”œâ”€â”€ Cargo.toml    â”œâ”€â”€ src    â”‚   â””â”€â”€ lib.rs    â””â”€â”€ tests        â””â”€â”€ end2end.rs
end2end.rs:
use gclient::{EventProcessor, GearApi, Result};const WASM_PATH: &str = "./target/wasm32-unknown-unknown/release/first_gear_app.opt.wasm";#[tokio::test]#[ignore]async fn test_example() -> Result<()> {    // Create API instance    let api = GearApi::dev().await?;    // Subscribe to events    let mut listener = api.subscribe().await?;    // Check that blocks are still running    assert!(listener.blocks_running().await?);    // Calculate gas amount needed for initialization    let gas_info = api        .calculate_upload_gas(            None,            gclient::code_from_os(WASM_PATH)?,            vec![],            0,            true,            None,        )        .await?;    // Upload and init the program    let (message_id, program_id, _hash) = api        .upload_program_bytes_by_path(            WASM_PATH,            gclient::now_micros().to_le_bytes(),            vec![],            gas_info.min_limit,            0,        )        .await?;    assert!(listener.message_processed(message_id).await?.succeed());    let payload = b"PING".to_vec();    // Calculate gas amount needed for handling the message    let gas_info = api        .calculate_handle_gas(None, program_id, payload.clone(), 0, true, None)        .await?;    // Send the PING message    let (message_id, _hash) = api        .send_message_bytes(program_id, payload, gas_info.min_limit, 0)        .await?;    assert!(listener.message_processed(message_id).await?.succeed());    Ok(())}
Run the following command and wait for all tests to be green:
cargo test --release -- --include-ignored
It's recommended to mark with the #[ignore] attribute tests with gclient to separate their slow execution from the rest. To execute ignored tests with Cargo, add the --include-ignored flag after a double dash (--) as shown above.
Let's explore what we've done in the test function above.
Firstly, we instantiate the API that allows interaction with the node by calling correspondent extrinsics. Then we create an event listener, as getting the feedback from the node is possible only by subscribing to events. We use the API instance both for invoking RPC calls (e.g., calculating the gas amount needed for processing) and sending extrinsics (e.g., uploading the program and sending a message). Events listener allows us to get the result of operation.
More details about gclientâ€‹
Please refer to the gclient docs for more information about its capabilities and use cases.Edit this pagePreviousTesting with gtestNextPrerequisitesImport gclient libRunning the nodeSimple exampleMore details about gclient








How to create an account | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable ğŸš§StableEnglishEnglishç®€ä½“ä¸­æ–‡SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAIDEA OverviewAccountCreate AccountSS58 account formatGear-JSGeneral topicsGear-based NetworksGear IDEAAccountCreate AccountOn this pageHow to create an account
Key information and securityâ€‹
Account represents an identity - typically a person or an organization, that is capable of making transactions or holding funds. Users can upload smart-contracts and interact with them through transactions in blockchain networks built on top of Gear Protocol. To make this happen, users need to connect a Substrate account. Gear Idea portal can work with Substrate accounts in any connected Gear-powered networks. Moreover this account can be used for holding funds and making transactions in any network of the Dotsama ecosystem and even more.
There are several ways to create a Substrate account, depending on whether you are using a desktop or a mobile device.
There are two main features that make up an account - an address and a key:

An address is the public aspect of the account. This is essentially a location that can be shared with others in order to send transactions to and from.
A key is the private part of the account. This is what enables you as an account owner to access the address. The only way to access your account is via your private key (using the mnemonic phrase, seed, or your account's JSON file and a password).

Storing your accountsâ€‹
tipSeed phraseYour seed or mnemonic phrase is the key to your account. If you lose seed you will lose access to your account. We recommend that you store your seed in secure places like encrypted hard drives, non-digital devices or ideally, paper. Never share your private key with anyone.
tipJSON fileJSON file is a backup of your account encrypted with a password. By using JSON, you can import/ restore your account in any wallet. Without a password, you will not be able to restore access to your account. If you use JSON, store the file and passwords in a safe place.
How to create accountâ€‹
Via Talisman Walletâ€‹
Talisman is a popular and user-friendly wallet for creating and managing Substrate accounts. Being connected to web3 applications across various networks, Talisman browser extension allows to store, send and receive assets.


Install Talisman extension for your browser here


Open the extension by clicking on the logo in the menu bar.


In the opened application, click "New wallet":




Enter a strong password:


And that's it. Your wallet has been created:

Via Subwalletâ€‹
Subwallet is another advanced wallet for managing Substrate as well as EVM accounts.


To install Subwallet follow this link


Open Subwallet by clicking on its logo in the browser menu bar.


Click "Create new account":




Select the type of account you want to create (Subwallet allows you to create Substrate-like and Ethereum accounts at once). Copy your seed phrase and keep it in the same place:



Provide your password in the next step. And click "Add the account with the generated seed"


Congratulations, your wallet has been successfully created!
Via Polkadot.js browser extensionâ€‹
The polkadot.js browser extension is the original application created by Parity Technologies for managing Substate accounts. This method involves installing the polkadot.js plugin and using it as a "virtual vault" that's separate from your browser to store your private keys and sign transactions.

You can install the extension via the following links.

Install on Chromium-based browser.
Install on FireFox.


Open the extension by clicking on the logo in the menu bar


Click the large plus button to create a new account. Alternatively, you can navigate to the smaller plus icon in the top right and select "Create New Account".


img alt

Save the seed phrase in a safe place using the security advices at the beginning of this article.



Specify the name of your account and a strong password for making transactions. Click "Add the account with the generated seed".


noteThe password that you choose here will be used to encrypt this account's information. You will need to re-enter it when attempting to process any kind of outgoing transaction, or when using it to cryptographically sign a message. This password is stored locally on the browser extension.
You've now successfully created a new account using the polkadot.js browser extension.
Via mobile appâ€‹
If you need access to your accounts on a mobile device, then you can use the following mobile wallets for the Polkadot/Kusama ecosystem:


All supported wallets you can check here.
Via consoleâ€‹
If you have Gear node installed, you can generate a new seed phrase using the command:
./gear key generate | grep phrase
And then import the generated seed phrase into any convenient wallet.
Frequently Asked Questionsâ€‹
Is this account portable?â€‹

Yes, you can access your account on a different device or wallet of your choice as long as you have the account's seed
phrase or JSON file associated with the account.

Can I transact directly in the polkadot.js browser extension?â€‹

There isn't functionality to make transactions directly in the polkadot.js browser extension.
To make transactions, you need to launch Gear Idea on your browser.
Before you can make any transactions, you have to allow Gear Idea to access your account.
The browser extension is what holds your account information. You choose which websites get to access this information.
Edit this pagePreviousIDEA OverviewNextSS58 account formatKey information and securityStoring your accountsHow to create accountVia Talisman WalletVia SubwalletVia Polkadot.js browser extensionVia mobile appVia consoleFrequently Asked Questions








What is DeFi? | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable ğŸš§StableEnglishEnglishç®€ä½“ä¸­æ–‡SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsWeb3dAppsSmart ContractsDeFiNFTDAOGear-based NetworksGeneral topicsDeFiWhat is DeFi?
Decentralized finance is a collection of financial services that are an alternative to the current financial system.
While the traditional financial sector is opaque, tightly controlled and outdated, DeFi empowers individuals by providing them with more personal control over their finances. DeFi applications enable individuals to borrow, save, invest and trade without having to rely on third parties like banks, exchanges or lending institutions. Itâ€™s able to do this because itâ€™s built on blockchain technology, making use of cryptocurrencies and smart contracts which can execute transactions automatically and instantaneously.
DeFi solves many problems within the traditional financial system. For a start, it makes financial services more accessible and inclusive. This is significant because it enables over 1.7 billion people, who were previously excluded, to have access to a safe and secure financial industry.
On top of that, DeFi is much faster and more efficient than traditional financial services because applications are powered by smart contracts. This removes the requirement for intermediaries, which removes a lot of the incurred costs associated with financial services.
DeFi applications can be accessed 24/7, anywhere in the world, meaning that individuals are not limited to operating on and at specific dates and times or in specific time zones.Edit this pagePreviousSmart ContractsNextNFT








What are NFTs? | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable ğŸš§StableEnglishEnglishç®€ä½“ä¸­æ–‡SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsWeb3dAppsSmart ContractsDeFiNFTDAOGear-based NetworksGeneral topicsNFTWhat are NFTs?
A Non-Fungible Token (NFT) is a unique type of cryptographic token that enables the tokenization of unique units of data to be stored on a blockchain.
NFTs can essentially represent anything that is unique, with their most common use case today being tokens that represent digital artwork.
However, contrary to many beliefs, NFTâ€™s use cases do not stop at verifying true authenticity and ownership of artwork alone.
NFTs can represent anything that is not fungible. This means that anything with unique properties now has a way to be cryptographically represented in order to be stored on a blockchain to benefit from its unique features.
NFTs can be used to represent anything from the deeds to a house to a receipt for a product or service.
In the future, itâ€™s likely that all unique units of data will be represented as NFTs in one way or another because theyâ€™re securer ways of storing valuable data and theyâ€™re extremely accessible, which makes traditionally illiquid assets much more liquid.Edit this pagePreviousDeFiNextDAO








Gear React-hooks | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable ğŸš§StableEnglishEnglishç®€ä½“ä¸­æ–‡SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGetting StartedKeyringCalculate GasUpload ProgramPay Program rentUpload CodeSend MessageRead StateVouchersMetadata & Type CreationMailboxEventsCookbookGear-JS toolsGear React application templateMeta CLIReact-hooksGeneral topicsGear-based NetworksGear-JSGear-JS toolsReact-hooksOn this pageGear React-hooks
Hooks allow functional components to have access to programs running on Gear networks and significantly simplify the development of front-end applications.
For example, refer to this article that demonstrates the creation of a React application that connects to an NFT smart contract running on the blockchain.
Installationâ€‹
npm install @gear-js/react-hooks
or
yarn add @gear-js/react-hooks
Getting startedâ€‹
Simple as it is, here's a quick example:
import { useReadFullState } from '@gear-js/react-hooks';import { useMetadata } from './use-metadata'import meta from 'assets/meta/meta.txt';function State() {  const programId = '0x01';  const { metadata } = useMetadata(meta);  const { state } = useReadFullState(programId, meta);  return <div>{JSON.stringify(state)}</div>;}export { State };
Cookbookâ€‹
infoIn order for these hooks to work, the application must be wrapped in the appropriate Providers. As it is presented in the example. If you use create-gear-app, then all the necessary environment has already been provided.
useApiâ€‹
useApi provides access to the Gear API connected to the selected RPC-node.
import { useApi } from '@gear-js/react-hooks';const { api, isApiReady } = useApi();
useAccountâ€‹
useAccount provides interaction with Polkadot-js extension API, allows to manage accounts from it (for example to sign transactions).
import { useAccount } from '@gear-js/react-hooks';const { account, isAccountReady } = useAccount();
useAlertâ€‹
useAlert shows any alert in the application context.
import { useAlert } from '@gear-js/react-hooks';const alert = useAlert();// type?: 'info' | 'error' | 'loading' | 'success';alert.success('success message')
useMetadataâ€‹
This hook is auxiliary and it is not pre-installed in the react-hook library. useMetadata allows converting the program's metadata (.txt file) into the required format.
import { useEffect, useState } from 'react';import {  getProgramMetadata,  ProgramMetadata} from '@gear-js/api';import { Buffer } from 'buffer';export const useMetadata = (source: RequestInfo | URL) => {  const [data, setData] = useState<ProgramMetadata>();  useEffect(() => {    fetch(source)      .then((res) => res.text())      .then((raw) => getProgramMetadata(`0x${raw}`))      .then((meta) => setData(meta));  }, [source]);  return { metadata: data };};
useWasmMetadataâ€‹
This hook is auxiliary and it is not pre-installed in the react-hook library. useWasmMetadata allows getting Buffer array from the program meta.wasm. Buffer is required always when using custom functions to query specific parts of the program State.
import { useEffect, useState } from 'react';import { Buffer } from 'buffer';export const useWasmMetadata = (source: RequestInfo | URL) => {  const [data, setData] = useState<Buffer>();  useEffect(() => {    if (source) {      fetch(source)        .then((response) => response.arrayBuffer())        .then((array) => Buffer.from(array))        .then((buffer) => setData(buffer))        .catch(({ message }: Error) => console.error(`Fetch error: ${message}`));    }    // eslint-disable-next-line react-hooks/exhaustive-deps  }, [source]);  return { buffer: data };};
useSendMessageâ€‹
useSendMessage allows sending messages to the program.
import { useSendMessage } from '@gear-js/react-hooks';import { useMetadata } from './useMetadata';import meta from 'assets/meta/meta.txt';function sendMessage() {  const programId = '0x01';  const { metadata } = useMetadata(meta);  return useSendMessage(programId, metadata);}
useReadFullStateâ€‹
useReadFullState allows reading full program State.
import { useReadFullState } from '@gear-js/react-hooks';import { useMetadata } from './useMetadata';import meta from 'assets/meta/meta.txt';function readFullState() {  const programId = '0x01';  const { metadata } = useMetadata(meta);  const { state } = useReadFullState(programId, metadata);  return state;}
useReadWasmStateâ€‹
useReadWasmState allows reading program State using specific functions.
import { useReadWasmState } from '@gear-js/react-hooks';import { useWasmMetadata } from './useMetadata';import stateMetaWasm from 'assets/wasm/state.meta.wasm';function useProgramState<T>(functionName: string, payload?: any) {  const programId = '0x01';  const { buffer } = useWasmMetadata(stateMetaWasm);  return useReadWasmState<T>(    programId,    buffer,    functionName,    payload,  );}function firstState() {  const payload = 'some_payload'  const { state } = useProgramState('foo_1', payload);  return state;}function secondState() {  // if program state function doesn't have initial payload  const { state } = useProgramState('foo_2', null);  return state;}
useCreateHandlerâ€‹
useCreateHandler provides a tool for uploading the Gear program to the chain.
import { useCreateHandler } from '@gear-js/react-hooks';import meta from 'assets/meta/meta.txt';import { useMetadata } from './useMetadata';export function useCreateProgram(onSuccess: (programId: Hex) => void) {  const codeHash = '0x01';  const { metadata } = useMetadata(meta);  const createProgram = useCreateHandler(codeHash, meta);  return (payload) => createProgram(payload, { onSuccess });}Edit this pagePreviousMeta CLINextWeb3InstallationGetting startedCookbookuseApiuseAccountuseAlertuseMetadatauseWasmMetadatauseSendMessageuseReadFullStateuseReadWasmStateuseCreateHandler








Actor æ¨¡å‹ | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())è·³åˆ°ä¸»è¦å†…å®¹Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeä¸‹ä¸€é¡µUnstable ğŸš§ä¸‹ä¸€é¡µç®€ä½“ä¸­æ–‡Englishç®€ä½“ä¸­æ–‡æœç´¢æ¬¢è¿Intro to Gear Protocolæœ¯è¯­è¡¨æˆ‘ä»¬ä¸ºä»€ä¹ˆåˆ›å»º Gearï¼ŸGear çš„ç‹¬ç‰¹æ€§Gear Protocol TechnologyActor æ¨¡å‹SubstrateWebAssembly (Wasm)æŒä¹…åŒ–å†…å­˜Gear ç½‘ç»œçŠ¶æ€çŠ¶æ€è½¬ç§»5 åˆ†é’Ÿå¿«é€Ÿå…¥é—¨Gear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksIntro to Gear ProtocolGear Protocol TechnologyActor æ¨¡å‹æœ¬é¡µæ€»è§ˆActor æ¨¡å‹
åœ¨å¹¶è¡Œè®¡ç®—ç³»ç»Ÿä¸­ï¼Œâ€œæ¶ˆæ¯é€šä¿¡â€æ–¹æ³•æ„å‘³ç€ç¨‹åºé€šè¿‡æ¶ˆæ¯äº¤æ¢è¿›è¡Œé€šä¿¡ã€‚å®ƒæ¯”â€œå…±äº«å†…å­˜é€šä¿¡â€æ›´å…·æœ‰ä¼˜åŠ¿ã€‚æ¶ˆæ¯ä¼ é€’å¹¶å‘æ¯”å…±äº«å†…å­˜å¹¶å‘æ›´å®¹æ˜“ç†è§£ã€‚å®ƒé€šå¸¸è¢«è®¤ä¸ºæ›´å¥å£®ï¼Œæ¯”å…±äº«å†…å­˜å…·æœ‰æ›´å¥½çš„æ€§èƒ½ã€‚
å¯¹äºè¿›ç¨‹é—´é€šä¿¡ï¼ŒGear ä½¿ç”¨ Actor æ¨¡å‹æ–¹æ¡ˆã€‚Actor æ¨¡å‹çš„åŸåˆ™æ˜¯ï¼Œç¨‹åºä»ä¸å…±äº«ä»»ä½•çŠ¶æ€ï¼Œåªæ˜¯åœ¨å½¼æ­¤ä¹‹é—´äº¤æ¢ä¿¡æ¯ã€‚
é€šè¿‡ Actor æ¨¡å‹ï¼Œç³»ç»Ÿç”±åŒæ—¶è¿ä½œçš„å¯¹è±¡ç»„æˆï¼Œè¿™äº›å¯¹è±¡ä¹‹é—´å®Œå…¨é€šè¿‡æ¶ˆæ¯ä¼ é€’è¿›è¡Œäº¤æµã€‚è™½ç„¶æ™®é€šçš„ Actor æ¨¡å‹ä¸ä¿è¯æ¶ˆæ¯çš„é¡ºåºï¼Œä½† Gear æä¾›äº†ä¸€äº›é¢å¤–çš„ä¿è¯ï¼Œå³ä¸¤ä¸ªç‰¹å®šç¨‹åºä¹‹é—´çš„æ¶ˆæ¯çš„é¡ºåºè¢«ä¿ç•™ä¸‹æ¥ã€‚
åœ¨ Actor æ¨¡å‹ä¸­ï¼Œä¸€ä¸ªç³»ç»Ÿç”±åŒæ—¶è¿ä½œçš„åŠŸèƒ½å¯¹è±¡ç»„æˆï¼Œè¿™äº›å¯¹è±¡ä¹‹é—´å®Œå…¨é€šè¿‡æ¶ˆæ¯ä¼ é€’è¿›è¡Œé€šä¿¡ã€‚è™½ç„¶ä¸€èˆ¬ Actor æ¨¡å‹å¹¶ä¸ä¿è¯æ¶ˆæ¯çš„é¡ºåºï¼Œä½† Gear æä¾›äº†ä¸€äº›é¢å¤–çš„ä¿è¯ï¼Œå³ä¸¤ä¸ªç‰¹å®šç¨‹åºä¹‹é—´çš„æ¶ˆæ¯é¡ºåºè¢«ä¿å­˜ä¸‹æ¥ã€‚
Actor æ¨¡å‹ä¿éšœäº†é«˜å¯æ‰©å±•æ€§å’Œé«˜å®¹é”™æ€§ã€‚
Actorâ€‹
Actor æ¨¡å‹ä¸­çš„ Actor æ˜¯å¯ä»¥å‘é€å’Œæ¥æ”¶æ¶ˆæ¯çš„åŸå­è®¡ç®—å•å…ƒã€‚åœ¨ Gear ä¸­ï¼ŒActor æ˜¯ä¸€ä¸ªç¨‹åº (æ™ºèƒ½åˆçº¦) æˆ–å‘ç¨‹åºå‘é€æ¶ˆæ¯çš„ç”¨æˆ·ã€‚æ¯ä¸ª Actor éƒ½æœ‰ä¸€ä¸ªå†…éƒ¨ç§æœ‰çŠ¶æ€å’Œä¸€ä¸ªä¿¡ç®±ã€‚é€šä¿¡æ˜¯å¼‚æ­¥çš„ï¼Œæ¶ˆæ¯ä»ä¿¡ç®±ä¸­å¼¹å‡ºå¹¶åˆ†é…ç»™æ¶ˆæ¯å¤„ç†æµï¼Œåœ¨é‚£é‡ŒæŒ‰å‘¨æœŸå¤„ç†ã€‚
å½“ä¸€ä¸ª Actor æ”¶åˆ°å¹¶å¤„ç†ä¸€ä¸ªæ¶ˆæ¯æ—¶ï¼Œå¯ä»¥å“åº”ä»¥ä¸‹å†…å®¹ï¼š

å‘å¦ä¸€ä¸ª Actor å‘é€æ¶ˆæ¯
åˆ›å»ºå¦ä¸€ä¸ª Actor
æ”¹å˜è‡ªå·±çš„å†…éƒ¨çŠ¶æ€

Actor æ˜¯ç‹¬ç«‹çš„ï¼Œå®ƒä»¬ä»ä¸åˆ†äº«ä»»ä½•çŠ¶æ€ï¼Œåªæ˜¯ç›¸äº’äº¤æ¢ä¿¡æ¯ã€‚
ä½¿ç”¨ Actor æ¨¡å‹æ–¹æ¡ˆæä¾›äº†ä¸€ç§åœ¨ç¨‹åºï¼ˆæ™ºèƒ½åˆçº¦ï¼‰é€»è¾‘ä¸­å®ç°åŸºäº Actor çš„å¹¶å‘æ€§çš„æ–¹æ³•ã€‚å®ƒå¯ä»¥åˆ©ç”¨å„ç§è¯­è¨€æ„é€ è¿›è¡Œå¼‚æ­¥ç¼–ç¨‹ï¼ˆRust ä¸­çš„ Futures å’Œ async-awaitï¼‰ã€‚
Async/await æ”¯æŒâ€‹
ä¸ç±»ä¸åŒï¼Œactor ä¸€æ¬¡åªå…è®¸ä¸€ä¸ªä»»åŠ¡è®¿é—®å®ƒä»¬çš„å¯å˜çŠ¶æ€ï¼Œè¿™ä½¿å¾—å¤šä¸ªä»»åŠ¡ä¸­çš„ä»£ç å¯ä»¥å®‰å…¨åœ°ä¸åŒä¸€ä¸ª actor å®ä¾‹äº¤äº’ã€‚
å¼‚æ­¥å‡½æ•°å¤§å¤§ç®€åŒ–äº†å¹¶å‘ç®¡ç†ï¼Œä½†å®ƒä»¬æ— æ³•å¤„ç†æ­»é”æˆ–çŠ¶æ€æŸåçš„æƒ…å†µã€‚ä¸ºäº†é¿å…æ­»é”æˆ–çŠ¶æ€æŸåï¼Œå¼‚æ­¥å‡½æ•°åº”è¯¥é¿å…è°ƒç”¨å¯èƒ½é˜»å¡å…¶çº¿ç¨‹çš„å‡½æ•°ã€‚ä¸ºäº†å®ç°è¿™ä¸€ç‚¹ï¼Œä»–ä»¬é€‰æ‹©ä½¿ç”¨ await è¡¨è¾¾å¼ã€‚
ç›®å‰ï¼Œå…¸å‹çš„æ™ºèƒ½åˆçº¦ä»£ç ä¸­ç¼ºä¹å¯¹ async/await æ¨¡å¼çš„æ”¯æŒï¼Œè¿™ç»™æ™ºèƒ½åˆçº¦å¼€å‘äººå‘˜å¸¦æ¥äº†å¾ˆå¤šé—®é¢˜ã€‚å®é™…ä¸Šï¼Œé€šè¿‡æ‰‹å·¥æ·»åŠ å‡½æ•°ï¼ˆåœ¨ Solidity æ™ºèƒ½åˆçº¦ä¸­ï¼‰ï¼Œä»¥åœ¨æ™ºèƒ½åˆçº¦ç¨‹åºæµä¸­å®ç°æ›´å¥½çš„æ§åˆ¶çš„æ–¹å¼ï¼Œæˆ–å¤šæˆ–å°‘æ˜¯å¯è¡Œçš„ã€‚ä½†æ˜¯é—®é¢˜åœ¨äºï¼Œä¸€äº›åˆçº¦ä¸­çš„å‡½æ•°ä¼šè®©äººä»¬å¾ˆå®¹æ˜“æ··æ·†åœ¨åˆçº¦ç”Ÿå‘½å‘¨æœŸä¸­çš„å“ªä¸ªé˜¶æ®µå¯ä»¥è°ƒç”¨å“ªä¸ªå‡½æ•°ã€‚
Gear ä¸ºç¨‹åºæä¾›äº†é€šç”¨çš„ async/await è¯­æ³•ã€‚å®ƒæå¤§åœ°ç®€åŒ–äº†å¼€å‘å’Œæµ‹è¯•ï¼Œå¹¶å‡å°‘äº†æ™ºèƒ½åˆçº¦å¼€å‘ä¸­å‡ºé”™çš„å¯èƒ½æ€§ã€‚å¦‚æœç¨‹åºé€»è¾‘éœ€è¦ï¼ŒGear API ä¹Ÿå…è®¸é€šè¿‡ç®€å•åœ°ä¸ä½¿ç”¨ await è¡¨è¾¾å¼æ¥ä½¿ç”¨åŒæ­¥æ¶ˆæ¯ã€‚ç¼–è¾‘æ­¤é¡µä¸Šä¸€é¡µGear çš„ç‹¬ç‰¹æ€§ä¸‹ä¸€é¡µSubstrateActorAsync/await æ”¯æŒ








å°†èŠ‚ç‚¹ç¨‹åºé…ç½®æˆ Linux æœåŠ¡ | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())è·³åˆ°ä¸»è¦å†…å®¹Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeä¸‹ä¸€é¡µUnstable ğŸš§ä¸‹ä¸€é¡µç®€ä½“ä¸­æ–‡Englishç®€ä½“ä¸­æ–‡æœç´¢æ¬¢è¿Intro to Gear Protocol5 åˆ†é’Ÿå¿«é€Ÿå…¥é—¨Gear Nodeé…ç½®èŠ‚ç‚¹å°†èŠ‚ç‚¹ç¨‹åºé…ç½®æˆæœåŠ¡èŠ‚ç‚¹ç›‘æ§å¤‡ä»½å’Œæ¢å¤å¼€å‘ç½‘ç»œå¤šèŠ‚ç‚¹æ¨¡å¼å¸¸è§é—®é¢˜å¸¸è§é”™è¯¯Developing Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksGear Nodeå°†èŠ‚ç‚¹ç¨‹åºé…ç½®æˆæœåŠ¡æœ¬é¡µæ€»è§ˆå°†èŠ‚ç‚¹ç¨‹åºé…ç½®æˆ Linux æœåŠ¡
å‰æœŸå‡†å¤‡â€‹
ä½ éœ€è¦ä¾æ®è‡ªå·±çš„æ“ä½œç³»ç»Ÿä¸‹è½½æˆ–è€…è‡ªè¡Œç¼–è¯‘ gear-node å¯æ‰§è¡Œæ–‡ä»¶ã€‚æ›´å¤šä¿¡æ¯ã€‚
é…ç½®æœåŠ¡â€‹
ä¸ºäº†å°† Gear èŠ‚ç‚¹ç¨‹åºä½œä¸º Linux çš„æœåŠ¡ï¼Œä½ éœ€è¦å‚ç…§ä»¥ä¸‹æ–¹å¼æ¥é…ç½® systemd æ–‡ä»¶ï¼š
ä» root ç›®å½•å¼€å§‹ï¼š
cd /etc/systemd/systemsudo nano gear-node.service
é…ç½®å¹¶ä¿å­˜ï¼š
[Unit]Description=Gear NodeAfter=network.target[Service]Type=simpleUser=rootWorkingDirectory=/root/ExecStart=/usr/bin/gear --name "NODE_NAME" --telemetry-url "wss://telemetry.rs/submit 0"Restart=alwaysRestartSec=3LimitNOFILE=10000[Install]WantedBy=multi-user.target
å¤‡æ³¨ExecStart æŒ‡å‘ gear äºŒè¿›åˆ¶æ–‡ä»¶æ‰€åœ¨çš„ä½ç½®ã€‚åœ¨ç¤ºä¾‹ä¸­æ˜¯åœ¨ /usr/bin ç›®å½•ã€‚
ä½¿ç”¨ -- å¼•å…¥é¢å¤–çš„å¯åŠ¨å‚æ•°ï¼Œä½†è¿™äº›å‚æ•°å¹¶ä¸æ˜¯å¿…é¡»çš„ã€‚
è¿è¡ŒèŠ‚ç‚¹â€‹
åˆ°è¿™é‡Œæˆ‘ä»¬å°±å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤æ¥å¯åŠ¨æœåŠ¡ï¼š
sudo systemctl start gear-node
ä½¿å…¶èƒ½å¤Ÿéšç³»ç»Ÿè‡ªåŠ¨å¯åŠ¨ï¼š
sudo systemctl enable gear-node
æ£€æŸ¥ gear-node æœåŠ¡çŠ¶æ€ï¼š
sudo systemctl status gear-node
æ£€æŸ¥æ—¥å¿—â€‹
è¿è¡Œä»¥ä¸‹å‘½ä»¤å¯ä»¥æŸ¥çœ‹æœåŠ¡æ—¥å¿—ï¼š
journalctl -u gear-node
ä½¿ç”¨å¯¼èˆªé”®æµè§ˆæ—¥å¿—ï¼Œä½¿ç”¨qé”®é€€å‡ºã€‚
ä½ å¯ä»¥é€šè¿‡æ·»åŠ å‚æ•°-n 50æ¥æŸ¥çœ‹æœ€å 50 è¡Œæ—¥å¿—ï¼š
journalctl -u gear-node -n 50
æ·»åŠ -få‚æ•°ï¼Œåœ¨è¿ç»­æ¨¡å¼ä¸‹æŸ¥çœ‹æ—¥å¿—çš„æœ€åä¸€è¡Œ (æŒ‰ Ctrl+C é€€å‡º)ï¼š
journalctl -u gear-node -fn 50
æ›´æ–°èŠ‚ç‚¹ç‰ˆæœ¬â€‹
ä½ åªéœ€è¦æŠŠèŠ‚ç‚¹çš„å¯æ‰§è¡Œæ–‡ä»¶ï¼ˆgearï¼‰æ›¿æ¢æˆæœ€æ–°ç‰ˆæœ¬ï¼Œç„¶åé‡æ–°å¯åŠ¨æ‰§è¡Œã€‚
ä¾‹å¦‚ï¼Œå¦‚æœä½ çš„ Linux å¯æ‰§è¡Œæ–‡ä»¶ä½äº/usr/binï¼ˆå¦‚æˆ‘ä»¬ä¸Šé¢çš„é…ç½®ï¼‰ï¼Œä½ è¦è¿è¡Œï¼š
wget https://get.gear.rs/gear-nightly-x86_64-unknown-linux-gnu.tar.xzsudo tar -xvf gear-nightly-x86_64-unknown-linux-gnu.tar.xz -C /usr/binrm gear-nightly-x86_64-unknown-linux-gnu.tar.xzsudo systemctl restart gear-node
åˆ é™¤èŠ‚ç‚¹â€‹
è¿è¡Œä»¥ä¸‹å‘½ä»¤ï¼Œåˆ é™¤èŠ‚ç‚¹çš„å­˜å‚¨ã€æœåŠ¡é…ç½®å’Œå¯æ‰§è¡Œæ–‡ä»¶ï¼š
sudo systemctl stop gear-nodesudo systemctl disable gear-nodesudo rm -rf /root/.local/share/gearsudo rm /etc/systemd/system/gear-node.servicesudo rm /usr/bin/gearç¼–è¾‘æ­¤é¡µä¸Šä¸€é¡µé…ç½®èŠ‚ç‚¹ä¸‹ä¸€é¡µèŠ‚ç‚¹ç›‘æ§å‰æœŸå‡†å¤‡é…ç½®æœåŠ¡è¿è¡ŒèŠ‚ç‚¹æ£€æŸ¥æ—¥å¿—æ›´æ–°èŠ‚ç‚¹ç‰ˆæœ¬åˆ é™¤èŠ‚ç‚¹








è¿è¡Œä¸€ä¸ª Gear å¼€å‘èŠ‚ç‚¹ | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())è·³åˆ°ä¸»è¦å†…å®¹Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeä¸‹ä¸€é¡µUnstable ğŸš§ä¸‹ä¸€é¡µç®€ä½“ä¸­æ–‡Englishç®€ä½“ä¸­æ–‡æœç´¢æ¬¢è¿Intro to Gear Protocol5 åˆ†é’Ÿå¿«é€Ÿå…¥é—¨Gear Nodeé…ç½®èŠ‚ç‚¹å°†èŠ‚ç‚¹ç¨‹åºé…ç½®æˆæœåŠ¡èŠ‚ç‚¹ç›‘æ§å¤‡ä»½å’Œæ¢å¤å¼€å‘ç½‘ç»œå¤šèŠ‚ç‚¹æ¨¡å¼å¸¸è§é—®é¢˜å¸¸è§é”™è¯¯Developing Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksGear Nodeå¼€å‘ç½‘ç»œè¿è¡Œä¸€ä¸ª Gear å¼€å‘èŠ‚ç‚¹
å¼€å‘èŠ‚ç‚¹å¯¹äºå¼€å‘å’Œè°ƒè¯•æ™ºèƒ½åˆçº¦éå¸¸æœ‰ç”¨ã€‚ä½ å¯ä»¥ç›´æ¥ä¸Šä¼ ç¨‹åºåˆ°æœ¬åœ°èŠ‚ç‚¹ï¼Œå‘ç¨‹åºå‘é€æ¶ˆæ¯ï¼Œå¹¶éªŒè¯ç¨‹åºçš„é€»è¾‘ã€‚
ä½¿ç”¨å¼€å‘æ¨¡å¼è¿è¡Œ Gear èŠ‚ç‚¹ï¼š


æŒ‰ç…§ https://wiki.gear-tech.io/zh-cn/node/setting-up/ ä¸­çš„æè¿°ï¼Œä¸ºä½ çš„æ“ä½œç³»ç»Ÿç¼–è¯‘æˆ–ä¸‹è½½æœ€æ–°æ„å»ºç‰ˆæœ¬ã€‚


ä½¿ç”¨å¼€å‘æ¨¡å¼è¿è¡ŒèŠ‚ç‚¹ï¼š


./gear --dev


è®¿é—® https://idea.gear-tech.io/ å¹¶è¿æ¥åˆ°æœ¬åœ°å¼€å‘èŠ‚ç‚¹ã€‚é€šè¿‡å·¦ä¸Šæ–¹çš„æŒ‰é’®ç‚¹å‡»ç½‘ç»œåˆ‡æ¢ï¼Œé€‰æ‹© Development -> Local nodeï¼Œç„¶åç‚¹å‡»åˆ‡æ¢æŒ‰é’®ã€‚ä½¿ç”¨ Idea å‘é€æ¶ˆæ¯ï¼Œè¯»å–ç¨‹åºçŠ¶æ€ç­‰ã€‚


è¦æ¸…é™¤å¼€å‘é“¾çš„èŠ‚ç‚¹æ•°æ®ï¼Œè¯·ä½¿ç”¨ï¼š


./gear purge-chain --dev

è¦è¿è¡Œä¸€ä¸ªæœ‰è¯¦ç»†æ—¥å¿—çš„å¼€å‘é“¾ï¼Œè¯·ä½¿ç”¨ï¼š

RUST_LOG=debug RUST_BACKTRACE=1 ./gear -lruntime=debug --devç¼–è¾‘æ­¤é¡µä¸Šä¸€é¡µå¤‡ä»½å’Œæ¢å¤ä¸‹ä¸€é¡µå¤šèŠ‚ç‚¹æ¨¡å¼








Getting started | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable ğŸš§StableEnglishEnglishç®€ä½“ä¸­æ–‡SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGetting StartedKeyringCalculate GasUpload ProgramPay Program rentUpload CodeSend MessageRead StateVouchersMetadata & Type CreationMailboxEventsCookbookGear-JS toolsGeneral topicsGear-based NetworksGear-JSGetting StartedOn this pageGetting started
Gear-JS APIâ€‹
The Gear-JS API provides a set of utilities, libraries and tools that enable JavaScript applications to interact with smart contracts running in the Gear network via queries to a Gear node.
Sections below describe tools that you can use in your JS application to implement basic functions such as managing your key pair (account), calculating gas required for network operations, uploading program in the network, sending a message to a program, reading program's state, getting messages from the user's mailbox, working with metadata and more. Some useful code snippets are provided in the Cookbook section.
The basic API is implemented on the Substrate layer and is the same for all Substrate-based networks. The Gear-JS API code is available on GitHub. Complete API overview can be found on the Polkadot documentation portal.
noteSince Vara and Vara Testnet can have different runtime versions, they may have different extrinsic signatures. If your application is operating on the Vara Network, it is more convenient to use the VaraApi class instead of GearApi and VaraTestnetApi for the Vara Testnet Network.
Installationâ€‹
npm install @gear-js/api
or
yarn add @gear-js/api
Getting startedâ€‹
Start the API connection to the local running RPC node:
import { GearApi } from '@gear-js/api';const gearApi = await GearApi.create();
You can also connect to a different node:
const gearApi = await GearApi.create({  providerAddress: 'ws[s]://someIP[:somePort]',});
noteBelow are a few entry points for interact with Gear RPC Node.For connection to local node use:ws://127.0.0.1:9944For connection to Vara Network Testnet use:wss://testnet.vara-network.io
Getting node info
const chain = await gearApi.chain();const nodeName = await gearApi.nodeName();const nodeVersion = await gearApi.nodeVersion();const genesis = gearApi.genesisHash.toHex();
Exampleâ€‹
This simple example describes how to subscribe to a new blocks and get chain spec:
async function connect() {  const gearApi = await GearApi.create({    providerAddress: 'wss://testnet.vara-network.io',  });  const [chain, nodeName, nodeVersion] = await Promise.all([    gearApi.chain(),    gearApi.nodeName(),    gearApi.nodeVersion(),  ]);  console.log(    `You are connected to chain ${chain} using ${nodeName} v${nodeVersion}`,  );  const unsub = await gearApi.gearEvents.subscribeToNewBlocks((header) => {    console.log(      `New block with number: ${header.number.toNumber()} and hash: ${header.hash.toHex()}`,    );  });}connect().catch(console.error);
Also, refer to the article that demonstrates the creation of a React application that connects to an NFT smart contract running on the blockchain.Edit this pagePreviousSS58 account formatNextKeyringGear-JS APIInstallationGetting startedExample








åˆ›å»ºä¸€ä¸ªå¤šèŠ‚ç‚¹æœ¬åœ°æµ‹è¯•ç½‘ç»œ | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())è·³åˆ°ä¸»è¦å†…å®¹Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeä¸‹ä¸€é¡µUnstable ğŸš§ä¸‹ä¸€é¡µç®€ä½“ä¸­æ–‡Englishç®€ä½“ä¸­æ–‡æœç´¢æ¬¢è¿Intro to Gear Protocol5 åˆ†é’Ÿå¿«é€Ÿå…¥é—¨Gear Nodeé…ç½®èŠ‚ç‚¹å°†èŠ‚ç‚¹ç¨‹åºé…ç½®æˆæœåŠ¡èŠ‚ç‚¹ç›‘æ§å¤‡ä»½å’Œæ¢å¤å¼€å‘ç½‘ç»œå¤šèŠ‚ç‚¹æ¨¡å¼å¸¸è§é—®é¢˜å¸¸è§é”™è¯¯Developing Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksGear Nodeå¤šèŠ‚ç‚¹æ¨¡å¼åˆ›å»ºä¸€ä¸ªå¤šèŠ‚ç‚¹æœ¬åœ°æµ‹è¯•ç½‘ç»œ
å¯¹äºæ›´é«˜çº§çš„æ™ºèƒ½åˆçº¦è°ƒè¯•å’Œæµ‹è¯•ï¼Œæ›´æ¥è¿‘çœŸå®çš„ç½‘ç»œç¯å¢ƒï¼Œä½ å¯ä»¥å»ºç«‹æœ¬åœ°æµ‹è¯•ç½‘ï¼Œç”±å‡ ä¸ªäº’è¿çš„èŠ‚ç‚¹ç»„æˆã€‚è¿™ç§æ¨¡å¼å¯ä»¥çœ‹åˆ°å¤šèŠ‚ç‚¹å…±è¯†ç®—æ³•çš„è¿è¡Œæƒ…å†µã€‚
è¿è¡Œå…·æœ‰ä¸¤ä¸ªéªŒè¯èŠ‚ç‚¹çš„æœ¬åœ°æµ‹è¯•ç½‘ï¼Œåˆ†åˆ«ä¸º Alice å’Œ Bobï¼Œå®ƒä»¬æ‹¥æœ‰localæµ‹è¯•ç½‘çš„åˆå§‹æƒé™ï¼Œå¹¶è¢«èµ‹äºˆæµ‹è¯•ç½‘å•å…ƒï¼Œæ›´å¤šç»†èŠ‚è¯·çœ‹é…ç½®ã€‚
æ³¨æ„ï¼šè¿™å°†éœ€è¦ä¸¤ä¸ªç»ˆç«¯ (æ¯ä¸ªèŠ‚ç‚¹ä¸€ä¸ª)ã€‚

é¦–å…ˆè¿è¡Œ Alice èŠ‚ç‚¹ã€‚ä¸‹é¢çš„å‘½ä»¤ä½¿ç”¨é»˜è®¤çš„ TCP ç«¯å£ (30333)ï¼Œå¹¶æŒ‡å®š/tmp/alice ä½œä¸ºé“¾æ•°æ®åº“ä½ç½®ã€‚
Alice çš„èŠ‚ç‚¹ ID æ˜¯12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEpï¼ˆä¼ ç»Ÿè¡¨ç¤ºä¸ºï¼šQmRpheLN4JWdAnY7HGJfWFNbfkQCb6tFf4vA6hgjMZKrRï¼‰ï¼›è¿™ç”± node-key å†³å®šã€‚

./gear \  --base-path /tmp/alice \  --chain=local \  --alice \  --node-key 0000000000000000000000000000000000000000000000000000000000000001 \  --telemetry-url "wss://telemetry.rs/submit 0"
Alice èŠ‚ç‚¹å°†åœ¨ å—#0 ä»¥ç©ºé—²æ¨¡å¼è¿è¡Œï¼Œç­‰å¾…ç¬¬äºŒä¸ªéªŒè¯èŠ‚ç‚¹ã€‚
  Gear Node  âœŒï¸ version 0.1.0-6dc8d24edd9  â¤ï¸ by Gear Technologies, 2021-2022  ğŸ“‹ Chain specification: Gear Local Testnet  ğŸ· Node name: Alice  ğŸ‘¤ Role: AUTHORITY  ğŸ’¾ Database: RocksDb at /tmp/alice/chains/gear_local_testnet/db/full  â›“ Native runtime: gear-610 (gear-1.tx1.au1)  ğŸ‘¶ Creating empty BABE epoch changes on what appears to be first startup.  Using default protocol ID "sup" because none is configured in the chain specs  ğŸ· Local node identity is: 12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp  ğŸ’» Operating system: macos  ğŸ’» CPU architecture: aarch64  ğŸ“¦ Highest known block at #0  ã€½ï¸ Prometheus exporter started at 127.0.0.1:9615  Running JSON-RPC HTTP server: addr=127.0.0.1:9933, allowed origins=Some(["http://localhost:*", "http://127.0.0.1:*", "https://localhost:*", "https://127.0.0.1:*", "https://polkadot.js.org"])  Running JSON-RPC WS server: addr=127.0.0.1:9944, allowed origins=Some(["http://localhost:*", "http://127.0.0.1:*", "https://localhost:*", "https://127.0.0.1:*", "https://polkadot.js.org"])  ğŸ CPU score: 1020MB/s  ğŸ Memory score: 37732MB/s  ğŸ Disk score (seq. writes): 1496MB/s  ğŸ Disk score (rand. writes): 421MB/s  ğŸ‘¶ Starting BABE Authorship worker  ğŸ’¤ Idle (0 peers), best: #0 (0x22c7â€¦6847), finalized #0 (0x22c7â€¦6847), â¬‡ 0 â¬† 0  ğŸ’¤ Idle (0 peers), best: #0 (0x22c7â€¦6847), finalized #0 (0x22c7â€¦6847), â¬‡ 0 â¬† 0  ğŸ’¤ Idle (0 peers), best: #0 (0x22c7â€¦6847), finalized #0 (0x22c7â€¦6847), â¬‡ 0 â¬† 0  ğŸ’¤ Idle (0 peers), best: #0 (0x22c7â€¦6847), finalized #0 (0x22c7â€¦6847), â¬‡ 0 â¬† 0
å¦å¤–ï¼Œä½ å¯ä»¥åœ¨ç›‘æµ‹ç½‘ç«™ï¼ˆhttps://telemetry.rsï¼‰çš„ Gear Local Testnet æ ‡ç­¾ä¸‹æ‰¾åˆ° Alice èŠ‚ç‚¹åç§°ã€‚

åœ¨å¦ä¸€ä¸ªç»ˆç«¯ï¼Œä½¿ç”¨ä¸‹é¢çš„å‘½ä»¤ï¼Œåœ¨ä¸åŒçš„ TCP ç«¯å£ï¼ˆ30334ï¼‰ä¸Šå¯åŠ¨ Bob çš„èŠ‚ç‚¹ï¼Œé“¾æ•°æ®åº“ä½ç½®åœ¨ /tmp/bobã€‚--bootnodes é€‰é¡¹å°†ä½¿ Bob èŠ‚ç‚¹ä¸ Alice èŠ‚ç‚¹åœ¨ TCP 30333 ç«¯å£è¿æ¥ã€‚

  ./gear \    --base-path /tmp/bob \    --bootnodes /ip4/127.0.0.1/tcp/30333/p2p/12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp \    --chain=local \    --bob \    --port 30334 \    --ws-port 9945 \    --telemetry-url "wss://telemetry.rs/submit 0"
è¿è¡Œç¬¬äºŒä¸ªéªŒè¯è€…èŠ‚ç‚¹åï¼Œç½‘ç»œå¼€å§‹äº§ç”Ÿæ–°çš„åŒºå—ã€‚
  Gear Node  âœŒï¸ version 0.1.0-6dc8d24edd9  â¤ï¸ by Gear Technologies, 2021-2022  ğŸ“‹ Chain specification: Gear Local Testnet  ğŸ· Node name: Bob  ğŸ‘¤ Role: AUTHORITY  ğŸ’¾ Database: RocksDb at /tmp/bob/chains/gear_local_testnet/db/full  â›“ Native runtime: gear-610 (gear-1.tx1.au1)  ğŸ”¨ Initializing Genesis block/state (state: 0xf470â€¦d2dc, header-hash: 0x22c7â€¦6847)  ğŸ‘´ Loading GRANDPA authority set from genesis on what appears to be first startup.  ğŸ‘¶ Creating empty BABE epoch changes on what appears to be first startup.  Using default protocol ID "sup" because none is configured in the chain specs  ğŸ· Local node identity is: 12D3KooWHpsf9Gp59ct6t6d1MmKHxbmZRvSWcUej7cUNmWNBdvZE  ğŸ’» Operating system: macos  ğŸ’» CPU architecture: aarch64  ğŸ“¦ Highest known block at #0  Running JSON-RPC HTTP server: addr=127.0.0.1:61429, allowed origins=Some(["http://localhost:*", "http://127.0.0.1:*", "https://localhost:*", "https://127.0.0.1:*", "https://polkadot.js.org"])  Running JSON-RPC WS server: addr=127.0.0.1:9945, allowed origins=Some(["http://localhost:*", "http://127.0.0.1:*", "https://localhost:*", "https://127.0.0.1:*", "https://polkadot.js.org"])  ğŸ CPU score: 875MB/s  ğŸ Memory score: 38353MB/s  ğŸ Disk score (seq. writes): 1497MB/s  ğŸ Disk score (rand. writes): 421MB/s  ğŸ‘¶ Starting BABE Authorship worker  discovered: 12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp /ip4/192.168.1.4/tcp/30333  discovered: 12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp /ip6/::1/tcp/30333  discovered: 12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp /ip4/127.0.0.1/tcp/30333  ğŸ™Œ Starting consensus session on top of parent 0x22c70bb6baf611e5c9a6b1886b307dfa25cf1972b3400e70eb15d624c8b96847  ğŸ Prepared block for proposing at 1 (0 ms) [hash: 0x1f55c4a9daf8c35d4388313ad67deec4ff5e472659e2fec310bd3032bcbdfe71; parent_hash: 0x22c7â€¦6847; extrinsics (2): [0x8bbdâ€¦2a85, 0x7d5câ€¦0b86]]  ğŸ”– Pre-sealed block for proposal at 1. Hash now 0xe46f6031bb73710e239665d0da4212fbdcca77d57f9504d357c078f3b315389e, previously 0x1f55c4a9daf8c35d4388313ad67deec4ff5e472659e2fec310bd3032bcbdfe71.  ğŸ‘¶ New epoch 0 launching at block 0xe46fâ€¦389e (block slot 1667197557 >= start slot 1667197557).  ğŸ‘¶ Next epoch starts at slot 1667198157  âœ¨ Imported #1 (0xe46fâ€¦389e)  ğŸ™Œ Starting consensus session on top of parent 0xe46f6031bb73710e239665d0da4212fbdcca77d57f9504d357c078f3b315389e  ğŸ Prepared block for proposing at 2 (0 ms) [hash: 0x66281c25f34157c713876cda6f39324a0da6a9a50c0c32310683bca875c1ab4c; parent_hash: 0xe46fâ€¦389e; extrinsics (2): [0xcb81â€¦f7c3, 0x7d5câ€¦0b86]]  ğŸ”– Pre-sealed block for proposal at 2. Hash now 0x2ab179fe98969cab0970df085b86e03dbee33daed527f6595bcdbeffebc64175, previously 0x66281c25f34157c713876cda6f39324a0da6a9a50c0c32310683bca875c1ab4c.  âœ¨ Imported #2 (0x2ab1â€¦4175)  ğŸ™Œ Starting consensus session on top of parent 0x2ab179fe98969cab0970df085b86e03dbee33daed527f6595bcdbeffebc64175  ğŸ Prepared block for proposing at 3 (0 ms) [hash: 0xb5b9be01adb191671e0421f4673f8bee0751481aaac7ea453d806161e3b46dd7; parent_hash: 0x2ab1â€¦4175; extrinsics (2): [0x7771â€¦de48, 0x7d5câ€¦0b86]]  ğŸ”– Pre-sealed block for proposal at 3. Hash now 0xf2ed128d41d96da623281745555a0fe00a033630aacf57ac02acc31ced267db0, previously 0xb5b9be01adb191671e0421f4673f8bee0751481aaac7ea453d806161e3b46dd7.  âœ¨ Imported #3 (0xf2edâ€¦7db0)

ç½‘ç»œå·²ç»å¯åŠ¨ï¼å¦‚æœæƒ³åœæ­¢ç½‘ç»œï¼Œåªéœ€åœ¨ä¸¤ä¸ªè¿è¡Œä¼šè¯ä¸­æŒ‰ä¸‹ Ctrl + Cå³å¯ã€‚
ç¼–è¾‘æ­¤é¡µä¸Šä¸€é¡µå¼€å‘ç½‘ç»œä¸‹ä¸€é¡µå¸¸è§é—®é¢˜








å¸¸è§é”™è¯¯ | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())è·³åˆ°ä¸»è¦å†…å®¹Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeä¸‹ä¸€é¡µUnstable ğŸš§ä¸‹ä¸€é¡µç®€ä½“ä¸­æ–‡Englishç®€ä½“ä¸­æ–‡æœç´¢æ¬¢è¿Intro to Gear Protocol5 åˆ†é’Ÿå¿«é€Ÿå…¥é—¨Gear Nodeé…ç½®èŠ‚ç‚¹å°†èŠ‚ç‚¹ç¨‹åºé…ç½®æˆæœåŠ¡èŠ‚ç‚¹ç›‘æ§å¤‡ä»½å’Œæ¢å¤å¼€å‘ç½‘ç»œå¤šèŠ‚ç‚¹æ¨¡å¼å¸¸è§é—®é¢˜å¸¸è§é”™è¯¯Developing Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksGear Nodeå¸¸è§é”™è¯¯æœ¬é¡µæ€»è§ˆå¸¸è§é”™è¯¯
è¿™é‡Œä»‹ç»äº†å¸¸è§çš„é”™è¯¯å’Œè§£å†³æ–¹æ¡ˆã€‚
LOCK æ–‡ä»¶ä¸å¯ç”¨â€‹


é”™è¯¯ï¼š IO é”™è¯¯ï¼šWhile lock file /root/.local/share/gear/chains/gear_staging_testnet_v7/db/full/LOCK: Resource temporarily unavailable


è§£å†³æ–¹å¼ï¼š  ä½ ä¼¼ä¹åœ¨è¿è¡Œå‡ ä¸ª Gear èŠ‚ç‚¹å®ä¾‹ã€‚æ³¨æ„ï¼Œåªå…è®¸è¿è¡Œä¸€ä¸ªèŠ‚ç‚¹å®ä¾‹ã€‚ä½ å¾ˆå¯èƒ½æŠŠèŠ‚ç‚¹é…ç½®ä¸ºä¸€ä¸ªæœåŠ¡ï¼Œç„¶åä»å‘½ä»¤è¡Œè¿è¡Œç¬¬äºŒä¸ªå®ä¾‹ã€‚ä½ åº”è¯¥åœæ­¢è¯¥æœåŠ¡ï¼Œæˆ–è€…ä¸è¦ä»å‘½ä»¤è¡Œè¿è¡Œ Gear èŠ‚ç‚¹ã€‚


ä½ å¯ä»¥é€šè¿‡è¿è¡Œå‘½ä»¤æŸ¥çœ‹å½“å‰çš„èŠ‚ç‚¹è¿›ç¨‹ï¼š
ps aux | grep gear
å¦‚æœä½ æƒ³åœæ­¢æ‰€æœ‰çš„èŠ‚ç‚¹è¿›ç¨‹ï¼Œå¯ä»¥è¿è¡Œï¼š
pkill -sigint gear
æ³¨æ„ï¼ŒSystemD æœåŠ¡ä¸èƒ½é€šè¿‡ä¸Šè¿°å‘½ä»¤åœæ­¢ã€‚æ”¹ä¸ºè¿è¡Œï¼š
sudo systemctl stop gear-node
å¯åŠ¨èŠ‚ç‚¹æœåŠ¡æ—¶å‡ºç°æ„å¤–å‚æ•°â€‹


é”™è¯¯ï¼š Found argument '\' which wasn't expected, or isn't valid in this context


è§£å†³æ–¹å¼ï¼š gear-node.service é…ç½®æ–‡ä»¶ä¼¼ä¹æœ‰é”™è¯¯ã€‚æŸäº›ç‰ˆæœ¬çš„ SystemD ä¸æ¥å—åæ–œçº¿å­—ç¬¦ (\) ä½œä¸ºåˆ†è¡Œç¬¦ã€‚å› æ­¤ï¼Œæœ€å¥½å°†æ¯ä¸ªé…ç½®é¡¹å†™åœ¨ä¸€è¡Œã€‚
è¯·å‚è€ƒ https://wiki.gear-tech.io/node/node-as-serviceï¼Œå°†èŠ‚ç‚¹æ­£ç¡®é…ç½®ä¸ºæœåŠ¡ã€‚
ä¸è¦å¿˜è®°åœ¨ä¿®å¤æœåŠ¡é…ç½®åé‡æ–°å¯åŠ¨èŠ‚ç‚¹ï¼š
sudo systemctl daemon-reloadsudo systemctl restart gear-node


æŸåçš„æ•°æ®åº“â€‹


é”™è¯¯ï¼š Database version cannot be read from existing db_version file


æ›¿ä»£é”™è¯¯ï¼š Invalid argument: Column families not opened: ..., col2, col1, col0


è§£å†³æ–¹å¼ï¼š è¿™ä¸ªé—®é¢˜çš„æ ¹æºæ˜¯ç£ç›˜ç©ºé—´ä¸è¶³ã€‚ä½ å¯ä»¥ç”¨ä»¥ä¸‹å‘½ä»¤æ£€æŸ¥å¯ç”¨ç©ºé—´ã€‚
df -h
æ­¤å¤–ï¼Œä½ å¯ä»¥æ£€æŸ¥åŒºå—é“¾æ•°æ®åº“ä½¿ç”¨äº†å¤šå°‘ç©ºé—´ã€‚
du -h $HOME/.local/share/gear/chains/gear_staging_testnet_v7/db/full
è¯·å‚è€ƒ ç³»ç»Ÿè¦æ±‚ï¼ŒæŸ¥çœ‹æ‰€éœ€çš„æœ€å°ç£ç›˜ç©ºé—´ã€‚
ä½ éœ€è¦é‡Šæ”¾æ›´å¤šçš„ç©ºé—´ï¼Œç„¶åè£å‰ªé“¾ï¼š
sudo systemctl stop gear-node# Provide more free space on the diskgear purge-chainsudo systemctl start gear-node


èŠ‚ç‚¹å¯æ‰§è¡Œæ–‡ä»¶è¿‡æœŸâ€‹


é”™è¯¯ï¼š Verification failed for block <block-id> received from peer <peer-id>


æ›¿ä»£é”™è¯¯ï¼š runtime requires function imports which are not present on the host


è§£å†³æ–¹å¼ï¼š æ›´æ–°   node åˆ°æœ€æ–°ç‰ˆæœ¬ã€‚


æœåŠ¡è¢«é”å®šâ€‹


é”™è¯¯ï¼š Failed to start gear-node.service: Unit gear-node.service is masked.


è§£å†³æ–¹å¼ï¼š è¯·æ£€æŸ¥æ­¤é“¾æ¥ï¼šhttps://askubuntu.com/questions/1017311/what-is-a-masked-service

ç¼–è¾‘æ­¤é¡µä¸Šä¸€é¡µå¸¸è§é—®é¢˜ä¸‹ä¸€é¡µå¯æ‰§è¡Œå‡½æ•°LOCK æ–‡ä»¶ä¸å¯ç”¨å¯åŠ¨èŠ‚ç‚¹æœåŠ¡æ—¶å‡ºç°æ„å¤–å‚æ•°æŸåçš„æ•°æ®åº“èŠ‚ç‚¹å¯æ‰§è¡Œæ–‡ä»¶è¿‡æœŸæœåŠ¡è¢«é”å®š








ä¸Šä¼ ç¨‹åº | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())è·³åˆ°ä¸»è¦å†…å®¹Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeä¸‹ä¸€é¡µUnstable ğŸš§ä¸‹ä¸€é¡µç®€ä½“ä¸­æ–‡Englishç®€ä½“ä¸­æ–‡æœç´¢æ¬¢è¿Intro to Gear Protocol5 åˆ†é’Ÿå¿«é€Ÿå…¥é—¨Gear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSå¼€å§‹Keyringè®¡ç®— Gasä¸Šä¼ ç¨‹åºPay Program rentæäº¤ä»£ç å‘é€æ¶ˆæ¯è¯»å–çŠ¶æ€Voucherså…ƒæ•°æ® ä¸ Type CreationMailboxEventsç¤ºä¾‹Gear-JS toolsGeneral topicsGear-based NetworksGear-JSä¸Šä¼ ç¨‹åºä¸Šä¼ ç¨‹åº
ç¼–è¯‘ä¸º Wasm çš„æ™ºèƒ½åˆçº¦å¯ä»¥ä½œä¸ºç¨‹åºä¸Šä¼ åˆ° Gear ç½‘ç»œã€‚åœ¨ä¸Šä¼ æœŸé—´ï¼Œå®ƒåœ¨ç½‘ç»œä¸­è¢«åˆå§‹åŒ–ï¼Œä»¥ä¾¿èƒ½å¤Ÿä¸ç½‘ç»œä¸­çš„å…¶ä»–å‚ä¸è€…ï¼ˆç¨‹åºå’Œç”¨æˆ·ï¼‰å‘é€å’Œæ¥æ”¶æ¶ˆæ¯ã€‚
const code = fs.readFileSync('path/to/program.wasm');const program = {  code,  gasLimit: 1000000,  value: 1000,  initPayload: somePayload,};try {  const { programId, salt, submitted } = await gearApi.program.upload(    uploadProgram,    meta,  );} catch (error) {  console.error(`${error.name}: ${error.message}`);}try {  await gearApi.program.signAndSend(keyring, (event) => {    console.log(event.toHuman());  });} catch (error) {  console.error(`${error.name}: ${error.message}`);}
å¤‡æ³¨å¯¹äºè®¡ç®—initä¿¡æ¯å¤„ç†æ‰€éœ€çš„ gasï¼Œåº”è¯¥ä½¿ç”¨GearApi.program.calculateGas.initUpload()ã€‚è¯·çœ‹æ›´å¤šç›¸å…³ä¿¡æ¯ç¼–è¾‘æ­¤é¡µä¸Šä¸€é¡µè®¡ç®— Gasä¸‹ä¸€é¡µPay Program rent








program-rent | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())è·³åˆ°ä¸»è¦å†…å®¹Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeä¸‹ä¸€é¡µUnstable ğŸš§ä¸‹ä¸€é¡µç®€ä½“ä¸­æ–‡Englishç®€ä½“ä¸­æ–‡æœç´¢æ¬¢è¿Intro to Gear Protocol5 åˆ†é’Ÿå¿«é€Ÿå…¥é—¨Gear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSå¼€å§‹Keyringè®¡ç®— Gasä¸Šä¼ ç¨‹åºPay Program rentæäº¤ä»£ç å‘é€æ¶ˆæ¯è¯»å–çŠ¶æ€Voucherså…ƒæ•°æ® ä¸ Type CreationMailboxEventsç¤ºä¾‹Gear-JS toolsGeneral topicsGear-based NetworksGear-JSPay Program rentprogram-rentTo pay program rent, use the following JavaScript code:
// program.payRent has params:// programId// blockCount - number of blocks for which we want to extendconst tx = await api.program.payRent('0x...', 100_000);tx.signAndSend(account, (events) => {   events.forEach(({ event }) => console.log(event.toHuman()));});
You can calculate the current rent price using the following code:
const price = api.program.calculatePayRent(blockCount);
If a program was paused and its pages removed from storage, you can restore it using the api.program.resumeSession methods:

init: Start a new session to resume the program.
push: Push a bunch of program pages.
commit: Finish the resume session.

Here's how you can resume a paused program:
const program = await api.programStorage.getProgram(programId, oneBlockBeforePauseHash);const initTx = api.program.resumeSession.init({  programId,  allocations: program.allocations,  codeHash: program.codeHash.toHex(),});let sessionId;initTx.signAndSend(account, ({ events }) => {  events.forEach(({ event: { method, data } }) => {    if (method === 'ProgramResumeSessionStarted') {      sessionId = data.sessionId.toNumber();    }  });});const pages = await api.programStorage.getProgramPages(programId, program, oneBlockBeforePauseHash);for (const memPage of Object.entries(page)) {  const tx = api.program.resumeSession.push({ sessionId, memoryPages: [memPage] });  tx.signAndSend(account);}const tx = api.program.resumeSession.commit({ sessionId, blockCount: 20_000 });tx.signAndSend(account);ç¼–è¾‘æ­¤é¡µä¸Šä¸€é¡µä¸Šä¼ ç¨‹åºä¸‹ä¸€é¡µæäº¤ä»£ç 








å‘é€æ¶ˆæ¯ | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())è·³åˆ°ä¸»è¦å†…å®¹Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeä¸‹ä¸€é¡µUnstable ğŸš§ä¸‹ä¸€é¡µç®€ä½“ä¸­æ–‡Englishç®€ä½“ä¸­æ–‡æœç´¢æ¬¢è¿Intro to Gear Protocol5 åˆ†é’Ÿå¿«é€Ÿå…¥é—¨Gear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSå¼€å§‹Keyringè®¡ç®— Gasä¸Šä¼ ç¨‹åºPay Program rentæäº¤ä»£ç å‘é€æ¶ˆæ¯è¯»å–çŠ¶æ€Voucherså…ƒæ•°æ® ä¸ Type CreationMailboxEventsç¤ºä¾‹Gear-JS toolsGeneral topicsGear-based NetworksGear-JSå‘é€æ¶ˆæ¯æœ¬é¡µæ€»è§ˆå‘é€æ¶ˆæ¯
å‘ç¨‹åºå‘é€æ¶ˆæ¯ï¼š
try {  const message = {    destination: destination, // programId    payload: somePayload,    gasLimit: 100_000_000,    value: 1000,  };  // By default, the payload will be encoded using meta.handle_input type  const submitted = await gearApi.message.submit(message, meta);  // If you need to specify a different handler  // For example  await gearApi.message.submit(message, meta, meta.async_handle_input);} catch (error) {  console.error(`${error.name}: ${error.message}`);}try {  await gearApi.message.signAndSend(keyring, (event) => {    console.log(event.toHuman());  });} catch (error) {  console.error(`${error.name}: ${error.message}`);}
å¤‡æ³¨åœ¨å®é™…æƒ…å†µä¸‹ï¼Œä¸ºç¡®ä¿æˆåŠŸå¤„ç†ä¿¡æ¯ï¼Œåº”é€šè¿‡ä½¿ç”¨api.program.calculateGasæ–¹æ³•æ¥è®¡ç®—å¤„ç†ä¿¡æ¯æ‰€éœ€çš„ gasã€‚è¯·çœ‹æ›´å¤šç›¸å…³ä¿¡æ¯
å‘é€å›å¤ä¿¡æ¯â€‹
å½“ä½ éœ€è¦å›å¤ä»ä¸€ä¸ªç¨‹åºæ”¶åˆ°çš„ä¿¡æ¯æ—¶ï¼Œè¯·ä½¿ç”¨è¿™ä¸ªä¾‹å­ï¼š
try {  const reply = {    replyToId: messageId,    payload: somePayload,    gasLimit: 10000000,    value: 1000,  };  // In that case, the payload will be encoded using meta.async_handle_input type if it exists, if not it will be used meta.async_init_input  const submitted = await gearApi.reply.submit(reply, meta);  // If you need to specify a handler mannualy  // For example  await gearApi.reply.submit(reply, meta, meta.async_init_input);} catch (error) {  console.error(`${error.name}: ${error.message}`);}try {  await gearApi.reply.signAndSend(keyring, (events) => {    console.log(event.toHuman());  });} catch (error) {  console.error(`${error.name}: ${error.message}`);}ç¼–è¾‘æ­¤é¡µä¸Šä¸€é¡µæäº¤ä»£ç ä¸‹ä¸€é¡µè¯»å–çŠ¶æ€å‘é€å›å¤ä¿¡æ¯








Basics & Metadata / Type creation | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())è·³åˆ°ä¸»è¦å†…å®¹Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeä¸‹ä¸€é¡µUnstable ğŸš§ä¸‹ä¸€é¡µç®€ä½“ä¸­æ–‡Englishç®€ä½“ä¸­æ–‡æœç´¢æ¬¢è¿Intro to Gear Protocol5 åˆ†é’Ÿå¿«é€Ÿå…¥é—¨Gear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSå¼€å§‹Keyringè®¡ç®— Gasä¸Šä¼ ç¨‹åºPay Program rentæäº¤ä»£ç å‘é€æ¶ˆæ¯è¯»å–çŠ¶æ€Voucherså…ƒæ•°æ® ä¸ Type CreationMailboxEventsç¤ºä¾‹Gear-JS toolsGeneral topicsGear-based NetworksGear-JSå…ƒæ•°æ® ä¸ Type Creationæœ¬é¡µæ€»è§ˆBasics & Metadata / Type creation
å…ƒæ•°æ®å®ç°äº†å®¢æˆ·ç«¯ï¼ˆJavaScript åº”ç”¨ç¨‹åºï¼‰å’Œæ™ºèƒ½åˆçº¦ï¼ˆRust ç¨‹åºï¼‰ä¹‹é—´çš„äº¤äº’ã€‚å…ƒæ•°æ®æ˜¯ä¸€ç§æ¥å£æ˜ å°„ï¼Œå¯ä»¥å°†ä¸€ç»„å­—èŠ‚ç è¯†åˆ«ä¸ºå¯ç†è§£çš„ç»“æ„ï¼Œå¹¶å°†å…¶æ’åºï¼Œå¹¶å±•ç¤ºå‡ºå®ƒæ‰€è¦å®ç°çš„åŠŸèƒ½ã€‚
å…ƒæ•°æ®æœ‰ä¸¤ç§ç±»å‹ã€‚
ProgramMetadataâ€‹
ProgramMetadata ç”¨äºç¼–ç /è§£ç è¿›å‡ºç¨‹åºçš„ä¿¡æ¯ï¼Œå¹¶è¯»å–æ•´ä¸ªç¨‹åºçš„ Stateã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå…ƒæ•°æ®çœ‹èµ·æ¥åƒä¸€ä¸ªåå…­è¿›åˆ¶å­—ç¬¦ä¸²ï¼Œå¹¶åœ¨ Gear ç¨‹åºç¼–è¯‘æ—¶è‡ªåŠ¨ç”Ÿæˆã€‚
è¦è·å–ç¨‹åºçš„å…ƒæ•°æ®ï¼Œè¯·ä½¿ç”¨ getProgramMetadata æ–¹æ³•ï¼š
import { getProgramMetadata } from '@gear-js/api';const metadata = getProgramMetadata('0xâ€¦');// å‡½æ•° getProgramMetadata() ä»¥åå…­è¿›åˆ¶æ ¼å¼è·å–ç¨‹åºçš„å…ƒæ•°æ®// å®ƒè¿”å›ä¸€ä¸ª `ProgramMetadata` ç±»çš„å¯¹è±¡ï¼Œå…¶å±æ€§ `types` åŒ…å«æ‰€æœ‰ç¨‹åºç±»å‹metadata.types.init.input; // ç¨‹åºåˆå§‹åŒ–çš„è¾“å…¥ä¿¡æ¯metadata.types.init.output; // ç¨‹åºåˆå§‹åŒ–çš„è¾“å‡ºä¿¡æ¯ // input/output å¯ç”¨äºç¨‹åºçš„æ‰€æœ‰å…¥å£å¤„metadata.types.state; // contains type for decoding state output
StateMetadataâ€‹
è¿™æ˜¯å¤„ç†å…ƒæ•°æ®æœ€æ–¹ä¾¿çš„æ–¹å¼ã€‚å®ƒå¯ä»¥åˆ›å»ºä»»ä½•è‡ªå®šä¹‰å‡½æ•°ï¼ŒåªæŸ¥è¯¢ç¨‹åºçŠ¶æ€çš„ç‰¹å®šéƒ¨åˆ†ï¼Œè€Œä¸æ˜¯è¯»å–æ•´ä¸ªç¨‹åºçš„çŠ¶æ€ã€‚è¿™å¯¹äºå…·æœ‰å¤§çŠ¶æ€çš„å¤§å‹ç¨‹åºæ¥è¯´æ˜¯ç‰¹åˆ«æœ‰ç”¨çš„ã€‚
ä¸ºäº†è¯»å–ç¨‹åº State çš„è‡ªå®šä¹‰å®ç°ï¼Œå¯ä»¥è°ƒç”¨StateMetadata å‡½æ•°æ¥è·å–å…ƒæ•°æ®ã€‚è¯¥å‡½æ•°å°† meta.wasm ä½œä¸º Buffer æ¥è¯»å– Stateã€‚å®ƒè¿”å› StateMetadata ç±»çš„å¯¹è±¡ï¼Œè¯¥ç±»å…·æœ‰æŸ¥è¯¢ç¨‹åº State çš„åŠŸèƒ½ã€‚
import { getStateMetadata } from '@gear-js/api';const fileBuffer = fs.readFileSync('path/to/state.meta.wasm');const metadata = await getStateMetadata(fileBuffer);metadata.functions; //  æ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œå…¶é”®æ˜¯å‡½æ•°åç§°ï¼Œå€¼æ˜¯è¾“å…¥/è¾“å‡ºç±»å‹çš„å¯¹è±¡
å…ƒæ•°æ®ç±»æ–¹æ³•â€‹
ProgramMetadata å’Œ StateMetadata ç±»éƒ½æœ‰ä¸€äº›æ–¹æ³•ï¼Œå¯ä»¥å¸®åŠ©äº†è§£ä¸€ä¸ªæˆ–å¦ä¸€ä¸ªç±»å‹æ˜¯ä»€ä¹ˆï¼Œä»¥åŠè·å¾—ç±»å‹çš„åç§°ï¼ˆå› ä¸ºç±»å‹åœ¨æ³¨å†Œè¡¨ä¸­ä»¥æ•°å­—è¡¨ç¤ºï¼‰ã€‚æ­¤å¤–ï¼Œè¿˜æœ‰ä¸€äº›ç¼–ç å’Œè§£ç æ•°æ®çš„æ–¹æ³•ã€‚
import { ProgramMetadata } from '@gear-js/api`;const metadata = getProgramMetadata('0xâ€¦');// è¿”å›å…·æœ‰æ­¤ç´¢å¼•çš„ç±»å‹çš„åç§°metadata.getTypeName(4);// è¿”å›è¯¥ç±»å‹çš„ç»“æ„metadata.getTypeDef(4);// å¦‚æœéœ€è¦å¾—åˆ°ä¸€ä¸ªå¸¦æœ‰é¢å¤–å­—æ®µï¼ˆnameï¼Œtypeï¼Œkindï¼Œlenï¼‰çš„ç±»å‹ç»“æ„ï¼Œå¿…é¡»ä¼ é€’ç¬¬äºŒä¸ªå‚æ•°metadata.getTypeDef(4, true);// è¿”å›æ‰€æœ‰å­˜åœ¨äºç¨‹åºæ³¨å†Œè¡¨ä¸­çš„è‡ªå®šä¹‰ç±»å‹metadata.getAllTypes();// ä½¿ç”¨æŒ‡å®šç±»å‹ç¼–ç æˆ–è§£ç  payloadmetadata.createType(4, { value: 'value' });
Type creationâ€‹
å…³äºåŸºæœ¬ç±»å‹å’Œæ–¹æ³•çš„æ›´å¤šä¿¡æ¯å¯ä»¥åœ¨ Polkadot çš„æ–‡æ¡£ä¸­æ‰¾åˆ°ã€‚
å¦‚æœå‡ºäºæŸç§åŸå› ï¼Œä½ éœ€è¦â€œæ‰‹åŠ¨â€åˆ›å»ºä¸€ä¸ªç±»å‹æ¥å¯¹ä»»ä½•æ¶ˆæ¯ä½“è¿›è¡Œç¼–ç /è§£ç ã€‚
import { CreateType } from '@gear-js/api';// å¦‚æœ "TypeName" å·²ç»æ³¨å†Œï¼Œå¯ä»¥ä½¿ ç”¨ä»¥ä¸‹æ–¹å¼ã€‚æ›´å¤šå†…å®¹è¯·çœ‹ https://polkadot.js.org/docs/api/start/types.create#choosing-how-to-createconst result = CreateType.create('TypeName', somePayload);// Otherwise need to add metadata containing TypeName and all required types // å¦åˆ™éœ€è¦æ·»åŠ åŒ…å« TypeName å’Œæ‰€æœ‰å¿…è¦ç±»å‹çš„å…ƒæ•°æ®const result = CreateType.create('TypeName', somePayload, metadata);
è¿™ä¸ªå‡½æ•°çš„ç»“æœæ˜¯ Codec ç±»å‹çš„æ•°æ®ï¼Œå®ƒæœ‰ä»¥ä¸‹æ–¹æ³•ï¼š
result.toHex(); // - returns a hex represetation of the valueresult.toHuman(); // - returns human-friendly object representation of the valueresult.toString(); //  - returns a string representation of the valueresult.toU8a(); // - encodes the value as a Unit8Arrayresult.toJSON(); // - converts the value to JSONç¼–è¾‘æ­¤é¡µä¸Šä¸€é¡µVouchersä¸‹ä¸€é¡µMailboxProgramMetadataStateMetadataå…ƒæ•°æ®ç±»æ–¹æ³•Type creation








ç¤ºä¾‹ | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())è·³åˆ°ä¸»è¦å†…å®¹Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeä¸‹ä¸€é¡µUnstable ğŸš§ä¸‹ä¸€é¡µç®€ä½“ä¸­æ–‡Englishç®€ä½“ä¸­æ–‡æœç´¢æ¬¢è¿Intro to Gear Protocol5 åˆ†é’Ÿå¿«é€Ÿå…¥é—¨Gear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSå¼€å§‹Keyringè®¡ç®— Gasä¸Šä¼ ç¨‹åºPay Program rentæäº¤ä»£ç å‘é€æ¶ˆæ¯è¯»å–çŠ¶æ€Voucherså…ƒæ•°æ® ä¸ Type CreationMailboxEventsç¤ºä¾‹Gear-JS toolsGeneral topicsGear-based NetworksGear-JSç¤ºä¾‹æœ¬é¡µæ€»è§ˆç¤ºä¾‹
è¿™é‡Œæ”¶é›†äº†ä¸€ç»„ä»¥é—®ç­”å½¢å¼å‡ºç°çš„æœ‰ç”¨çš„ä»£ç ç‰‡æ®µã€‚
è®¢é˜…æ–°å—â€‹
const unsub = await gearApi.gearEvents.subscribeToNewBlocks((header) => {  console.log(`New block with number: ${header.number.toNumber()} and hash: ${header.hash.toHex()}`);});// Unsubscribeunsub();
è·å–å—æ•°æ®â€‹
const data = await gearApi.blocks.get(blockNumberOrBlockHash);console.log(data.toHuman());
è·å–å—æ—¶é—´æˆ³â€‹
const ts = await gearApi.blocks.getBlockTimestamp(blockNumberOrBlockHash);console.log(ts.toNumber());
é€šè¿‡å—é«˜åº¦å¾—åˆ° blockHashâ€‹
const hash = await gearApi.blocks.getBlockHash(blockNumber);console.log(hash.toHex());
é€šè¿‡ blockHash å¾—åˆ°å—é«˜åº¦â€‹
const hash = await gearApi.blocks.getBlockNumber(blockHash);console.log(hash.toNumber());
è·å–æ‰€æœ‰å—çš„äº‹ä»¶â€‹
const events = await gearApi.blocks.getEvents(blockHash);events.forEach((event) => {  console.log(event.toHuman());});
è·å–æ‰€æœ‰å—çš„ extrinsicsâ€‹
const extrinsics = await gearApi.blocks.getExtrinsics(blockHash);extrinsics.forEach((extrinsic) => {  console.log(extrinsic.toHuman());});
Get transaction fee è·å–â€‹
const gearApi = await GearApi.create();api.program.submit({ code, gasLimit });// same for gearApi.message, gearApi.reply and othersconst paymentInfo = await gearApi.program.paymentInfo(alice);const transactionFee = paymentInfo.partialFee.toNumber();consolg.log(transactionFee);ç¼–è¾‘æ­¤é¡µä¸Šä¸€é¡µEventsä¸‹ä¸€é¡µåˆ›å»º Gear Appè®¢é˜…æ–°å—è·å–å—æ•°æ®è·å–å—æ—¶é—´æˆ³é€šè¿‡å—é«˜åº¦å¾—åˆ° blockHashé€šè¿‡ blockHash å¾—åˆ°å—é«˜åº¦è·å–æ‰€æœ‰å—çš„äº‹ä»¶è·å–æ‰€æœ‰å—çš„ extrinsicsGet transaction fee è·å–








Events | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())è·³åˆ°ä¸»è¦å†…å®¹Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeä¸‹ä¸€é¡µUnstable ğŸš§ä¸‹ä¸€é¡µç®€ä½“ä¸­æ–‡Englishç®€ä½“ä¸­æ–‡æœç´¢æ¬¢è¿Intro to Gear Protocol5 åˆ†é’Ÿå¿«é€Ÿå…¥é—¨Gear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSå¼€å§‹Keyringè®¡ç®— Gasä¸Šä¼ ç¨‹åºPay Program rentæäº¤ä»£ç å‘é€æ¶ˆæ¯è¯»å–çŠ¶æ€Voucherså…ƒæ•°æ® ä¸ Type CreationMailboxEventsç¤ºä¾‹Gear-JS toolsGeneral topicsGear-based NetworksGear-JSEventsæœ¬é¡µæ€»è§ˆEvents
Events are generated for certain operations during execution. The following sections describe events that are part of the default Gear runtime.
To subscribe to all events:
const unsub = await api.query.system.events((events) => {  console.log(events.toHuman());});// Unsubscribeunsub();
Gear Events Typesâ€‹
MessageQueuedâ€‹
Summary: When a user successfully sends a message to a program and it gets added to the Gear message queue.
MessageQueued {    /// Generated id of the message.    id: MessageId,    /// Account id of the source of the message.    source: T::AccountId,    /// Program id, who is the message's destination.    destination: ProgramId,    /// Entry point for processing of the message.    /// On the sending stage, the processing function    /// of the program is always known.    entry: MessageEntry,}
UserMessageSentâ€‹
Summary: When someone has sent a message to the user.
UserMessageSent {    /// Message sent.    message: UserMessage,    /// Block number of expiration from `Mailbox`.    ///    /// Equals `Some(_)` with block number when message    /// will be removed from `Mailbox` due to some    /// reasons (see #642, #646 and #1010).    ///    /// Equals `None` if message wasn't inserted to    /// `Mailbox` and appears as only `Event`.    expiration: Option<T::BlockNumber>,}
UserMessageReadâ€‹
Summary: When a message has been marked as "read" and it has been removed from the Mailbox. This event only affects messages, which were already prior inserted into the Mailbox.
UserMessageRead {    /// Id of the message read.    id: MessageId,    /// The reason for the reading (removal from `Mailbox`).    ///    /// NOTE: See more docs about reasons at `gear_common::event`.    reason: UserMessageReadReason,}
MessagesDispatchedâ€‹
Summary: The result of when a message is processed within the block.
MessagesDispatched {    /// Total amount of messages removed from message queue.    total: MessengerCapacityOf<T>,    /// Execution statuses of the messages, which were already known    /// by `Event::MessageQueued` (sent from user to program).    statuses: BTreeMap<MessageId, DispatchStatus>,    /// Ids of programs, which state changed during queue processing.    state_changes: BTreeSet<ProgramId>,}
MessageWaitedâ€‹
Summary: When a message's execution has been delayed and it has been added to the Gear waitlist.
MessageWaited {    /// Id of the message waited.    id: MessageId,    /// Origin message id, which started messaging chain with programs,    /// where currently waited message was created.    ///    /// Used to identify by the user that this message associated    /// with him and the concrete initial message.    origin: Option<GasNodeId<MessageId, ReservationId>>,    /// The reason of the waiting (addition to `Waitlist`).    ///    /// NOTE: See more docs about reasons at `gear_common::event`.    reason: MessageWaitedReason,    /// Block number of expiration from `Waitlist`.    ///    /// Equals block number when message will be removed from `Waitlist`    /// due to some reasons (see #642, #646 and #1010).    expiration: T::BlockNumber,}
MessageWokenâ€‹
Summary: When a message is ready to continue its execution and has been removed from the Waitlist.
MessageWoken {    /// Id of the message woken.    id: MessageId,    /// The reason of the waking (removal from `Waitlist`).    ///    /// NOTE: See more docs about reasons at `gear_common::event`.    reason: MessageWokenReason,}
CodeChangedâ€‹
Summary: When a program's code has been altered.
CodeChanged {    /// Id of the code affected.    id: CodeId,    /// Change applied on code with current id.    ///    /// NOTE: See more docs about change kinds at `gear_common::event`.    change: CodeChangeKind<T::BlockNumber>,}
ProgramChangedâ€‹
Summary: Any data related to program changed.
ProgramChanged {    /// Id of the program affected.    id: ProgramId,    /// Change applied on program with current id.    ///    /// NOTE: See more docs about change kinds at `gear_common::event`.    change: ProgramChangeKind<T::BlockNumber>,}
ProgramResumeSessionStartedâ€‹
Summary: Program resume session has been started.
ProgramResumeSessionStarted {  /// Id of the session.  session_id: SessionId,  /// Owner of the session.  account_id: T::AccountId,  /// Id of the program affected.  program_id: ProgramId,  /// Block number when the session will be removed if not finished.  session_end_block: T::BlockNumber}        
Check what the event isâ€‹
api.query.system.events((events) => {  events    .filter(({ event }) => api.events.gear.MessageQueued.is(event))    .forEach(({ event: { data } }) => {      console.log(data.toHuman());    });  events    .filter(({ event }) => api.events.balances.Transfer.is(event))    .forEach(({ event: { data } }) => {      console.log(data.toHuman());    });});
Subscribe to specific gear eventsâ€‹
Subscribe to messages sent from a programâ€‹
const unsub = api.gearEvents.subscribeToGearEvent(  'UserMessageSent',  ({    data: {      message: { id, source, destination, payload, value, reply },    },  }) => {    console.log(`  messageId: ${id.toHex()}  source: ${source.toHex()}  payload: ${payload.toHuman()}  `);  },);// Unsubscribeunsub();
Subscribe to messages intended for a programâ€‹
const unsub = api.gearEvents.subscribeToGearEvent(  'MessageQueued',  ({ data: { id, source, destination, entry } }) => {    console.log({      messageId: id.toHex(),      programId: destination.toHex(),      userId: source.toHex(),      entry: entry.isInit        ? entry.asInit        : entry.isHandle        ? entry.asHandle        : entry.asReply,    });  },);// Unsubscribeunsub();
Subscribe to Transfer eventsâ€‹
const unsub = await api.gearEvents.subscribeToTransferEvents(  ({ data: { from, to, amount } }) => {    console.log(`    Transfer balance:    from: ${from.toHex()}    to: ${to.toHex()}    amount: ${+amount.toString()}    `);  },);// Unsubscribeunsub();
Subscribe to new blocksâ€‹
const unsub = await api.gearEvents.subscribeToNewBlocks((header) => {  console.log(    `New block with number: ${header.number.toNumber()} and hash: ${header.hash.toHex()}`,  );});// Unsubscribeunsub();ç¼–è¾‘æ­¤é¡µä¸Šä¸€é¡µMailboxä¸‹ä¸€é¡µç¤ºä¾‹Gear Events TypesMessageQueuedUserMessageSentUserMessageReadMessagesDispatchedMessageWaitedMessageWokenCodeChangedProgramChangedProgramResumeSessionStartedCheck what the event isSubscribe to specific gear eventsSubscribe to messages sent from a programSubscribe to messages intended for a programSubscribe to Transfer eventsSubscribe to new blocks








Gear åº“ | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())è·³åˆ°ä¸»è¦å†…å®¹Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeä¸‹ä¸€é¡µUnstable ğŸš§ä¸‹ä¸€é¡µç®€ä½“ä¸­æ–‡Englishç®€ä½“ä¸­æ–‡æœç´¢æ¬¢è¿Intro to Gear Protocol5 åˆ†é’Ÿå¿«é€Ÿå…¥é—¨Gear NodeDeveloping Smart Contractså¯æ‰§è¡Œå‡½æ•°Gear åº“MailboxState å‡½æ•°å…ƒæ•°æ®æ•°æ®åºåˆ—åŒ–/ååºåˆ—åŒ–å¼‚æ­¥åˆçº¦åˆ›å»ºåˆçº¦Gas é¢„ç•™å»¶è¿Ÿæ¶ˆæ¯ä¸€è‡´æ€§å’Œå¯é æ€§System Signalséƒ¨ç½²åˆçº¦Reply DepositProgram Rentåˆçº¦æµ‹è¯•Testing with gtestTesting with gclientSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksDeveloping Smart ContractsGear åº“æœ¬é¡µæ€»è§ˆGear åº“
Gear Protocol çš„åº“gstdä¸ºå¼€å‘æ™ºèƒ½åˆçº¦æä¾›äº†æ‰€æœ‰å¿…è¦å’Œå®Œå–„çš„åŠŸèƒ½å’Œæ–¹æ³•ã€‚
é€šè¿‡ prelude å¯¼å…¥ç›¸ä¼¼çš„ç±»å‹â€‹
gstdçš„é»˜è®¤ prelude æ¨¡å—åˆ—å‡ºäº† Rust è‡ªåŠ¨å¯¼å…¥æ¯ä¸ªç¨‹åºä¸­çš„ä¸œè¥¿ã€‚å®ƒé‡æ–°å¯¼å…¥äº†é»˜è®¤çš„ std æ¨¡å—å’Œ traitsã€‚åœ¨ Rust çš„ Gear ç¨‹åºä¸­ï¼Œstd å¯ä»¥å®‰å…¨åœ°æ›¿æ¢ä¸º gstdã€‚
æ›´å¤šè¯¦ç»†å†…å®¹è¯·çœ‹ https://docs.gear.rs/gstd/prelude/index.html
æ¶ˆæ¯å¤„ç†â€‹
Gear Protocol å…è®¸ç”¨æˆ·å’Œç¨‹åºé€šè¿‡æ¶ˆæ¯ä¸å…¶ä»–ç”¨æˆ·å’Œç¨‹åºè¿›è¡Œäº¤äº’ã€‚æ¶ˆæ¯å¯ä»¥åŒ…å«åœ¨payloadï¼Œå®ƒèƒ½å¤Ÿåœ¨æ¶ˆæ¯æ‰§è¡ŒæœŸé—´å¤„ç†ã€‚é€šè¿‡æ¨¡å— msgï¼Œæˆ‘ä»¬å¯ä»¥ä¸æ¶ˆæ¯äº¤äº’ï¼š
use gstd::msg;
æ¶ˆæ¯å¤„ç†åªèƒ½åœ¨å®šä¹‰çš„å‡½æ•° init()ã€handle() å’Œ hadle_reply() å†…è¿›è¡Œã€‚å®ƒä»¬è¿˜å®šä¹‰äº†å¤„ç†æ­¤ç±»æ¶ˆæ¯çš„ä¸Šä¸‹æ–‡ã€‚

è·å–å½“å‰æ­£åœ¨å¤„ç†çš„æ¶ˆæ¯çš„ payload å¹¶å¯¹å…¶è¿›è¡Œè§£ç ï¼š

#![no_std]use gstd::{msg, prelude::*};#[no_mangle]extern "C" fn handle() {    let payload_string: String = msg::load().expect("Unable to decode `String`");}

ä½¿ç”¨payloadå›å¤æ¶ˆæ¯ï¼š

#![no_std]use gstd::msg;#[no_mangle]extern "C" fn handle() {    msg::reply("PONG", 0).expect("Unable to reply");}

å‘ç”¨æˆ·å‘é€æ¶ˆæ¯ï¼š

#![no_std]use gstd::{msg, prelude::*};#[no_mangle]extern "C" fn handle() {    // ...    let id = msg::source();    let message_string = "Hello there".to_string();    msg::send(id, message_string, 0).expect("Unable to send message");}
å…³äº msg çš„æ›´å¤šç”¨æ³•ï¼Œè¯·çœ‹ https://docs.gear.rs/gstd/msg/index.html
æ‰§è¡Œä¿¡æ¯â€‹
ç¨‹åºå¯ä»¥é€šè¿‡ä½¿ç”¨ exec æ¨¡å—è·å–æœ‰å…³å½“å‰æ‰§è¡Œä¸Šä¸‹æ–‡çš„ä¸€äº›æœ‰ç”¨ä¿¡æ¯ï¼š
use gstd::exec;

åœ¨åŒºå—æ—¶é—´æˆ³åˆ°è¾¾æŒ‡å®šæ—¥æœŸåå‘é€å›å¤æ¶ˆæ¯ï¼š

#![no_std]use gstd::{exec, msg};#[no_mangle]extern "C" fn handle() {    // Timestamp is in milliseconds since the Unix epoch    if exec::block_timestamp() >= 1672531200000 {        msg::reply(b"Current block has been generated after January 01, 2023", 0)            .expect("Unable to reply");    }}

è·å¾—ä¸€ä¸ªç¨‹åºçš„ä½™é¢ï¼š

#![no_std]use gstd::exec;#[no_mangle]extern "C" fn handle() {    // Get self value balance in program    let my_balance = exec::value_available();}
å…³äº syscalls çš„æ›´å¤šç”¨æ³•ï¼Œè¯·çœ‹ https://docs.gear.rs/gstd/exec/index.html
åœ¨åˆçº¦å†…éƒ¨è¿›è¡Œè°ƒè¯•â€‹
å® gstd::debug æä¾›åœ¨ç¨‹åºæ‰§è¡ŒæœŸé—´è°ƒè¯•åˆçº¦çš„èƒ½åŠ›ï¼š
#![no_std]use gstd::{debug, msg, prelude::*};#[no_mangle]extern "C" fn handle() {    let payload_string: String = msg::load().expect("Unable to decode `String`");    debug!("Received message: {payload_string:?}");}ç¼–è¾‘æ­¤é¡µä¸Šä¸€é¡µå¯æ‰§è¡Œå‡½æ•°ä¸‹ä¸€é¡µMailboxé€šè¿‡ prelude å¯¼å…¥ç›¸  ä¼¼çš„ç±»å‹æ¶ˆæ¯å¤„ç†æ‰§è¡Œä¿¡æ¯åœ¨åˆçº¦å†…éƒ¨è¿›è¡Œè°ƒè¯•








å­˜å‚¨æ•°æ® | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())è·³åˆ°ä¸»è¦å†…å®¹Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeä¸‹ä¸€é¡µUnstable ğŸš§ä¸‹ä¸€é¡µç®€ä½“ä¸­æ–‡Englishç®€ä½“ä¸­æ–‡æœç´¢æ¬¢è¿Intro to Gear Protocol5 åˆ†é’Ÿå¿«é€Ÿå…¥é—¨Gear NodeDeveloping Smart Contractså¯æ‰§è¡Œå‡½æ•°Gear åº“MailboxState å‡½æ•°å…ƒæ•°æ®æ•°æ®åºåˆ—åŒ–/ååºåˆ—åŒ–å¼‚æ­¥åˆçº¦åˆ›å»ºåˆçº¦Gas é¢„ç•™å»¶è¿Ÿæ¶ˆæ¯ä¸€è‡´æ€§å’Œå¯é æ€§System Signalséƒ¨ç½²åˆçº¦Reply DepositProgram Rentåˆçº¦æµ‹è¯•Testing with gtestTesting with gclientSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksDeveloping Smart ContractsState å‡½æ•°æœ¬é¡µæ€»è§ˆå­˜å‚¨æ•°æ®
Gear æ™ºèƒ½åˆçº¦çš„æŒä¹…åŒ–æ•°æ®çš„å­˜å‚¨æ–¹å¼ä¸ä¼ ç»Ÿç¨‹åºç›¸åŒï¼Œä¸éœ€è¦åˆå§‹åŒ–å¤–éƒ¨å­˜å‚¨ã€‚
// ...// describe state structure#[derive(TypeInfo, Decode, Encode, Clone)]pub struct Wallet {    pub id: ActorId,    pub person: String,}// declare and initialize the statestatic mut WALLETS: Vec<Wallet> = Vec::new();
å¦‚æœç”¨ Rust æˆ–å…¶ä»–é¢å‘å¯¹è±¡çš„è¯­è¨€ç¼–ç¨‹ï¼Œä½ åº”è¯¥å¯¹å¤§å¤šæ•°ç±»å‹éƒ½å¾ˆç†Ÿæ‚‰ã€‚ç„¶è€Œï¼Œåœ¨ Gear ä¸Šå¼€å‘åˆçº¦æ—¶ï¼ŒActorId ç±»å‹æ˜¯ä¸€ä¸ªæ–°å†…å®¹ã€‚
ä¿¡æ¯ActorId æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„ç±»å‹ï¼Œä»£è¡¨ä¸€ä¸ª 32 å­—èŠ‚çš„æ•°ç»„ï¼Œå¹¶å®šä¹‰äº† Gear Protocol ä¸­æ‰€æœ‰çš„ IDã€‚
State å‡½æ•°â€‹
ä¸ºäº†æ˜¾ç¤ºåˆçº¦çŠ¶æ€ä¿¡æ¯ï¼ˆç±»ä¼¼äºviewå‡½æ•°ï¼‰ï¼Œä½¿ç”¨ state() å‡½æ•°ã€‚å®ƒå¯ä»¥ç«‹å³è¯»å–åˆçº¦çŠ¶æ€ï¼ˆä¾‹å¦‚ï¼Œä½™é¢ï¼‰ã€‚è¯»å–çŠ¶æ€æ˜¯ä¸€ä¸ªå…è´¹å‡½æ•°ï¼Œä¸éœ€è¦æ¶ˆè€—ä»»ä½• gasã€‚
è¦è¿”å› State ä½¿ç”¨ï¼š
#[no_mangle]extern "C" fn state() {    msg::reply(unsafe { WALLETS.clone() }, 0).expect("Failed to share state");}
é»˜è®¤æƒ…å†µä¸‹ï¼Œstate() å‡½æ•°è¿”åˆçº¦çš„æ•´ä½“çŠ¶æ€ã€‚
è‡ªå®šä¹‰ç¨‹åºè¯»å–çŠ¶æ€â€‹
æ­¤å¤–ï¼Œä½ å¯ä»¥åˆ›å»ºè‡ªå·±çš„ç¨‹åºæ¥è¯»å–çŠ¶æ€ã€‚è¿™ä¸ªåŒ…è£…å™¨å°†å…è®¸ä½ ä¸ºå®¢æˆ·ç«¯å®ç°è‡ªå®šä¹‰å‡½æ•°ï¼Œè€Œä¸ä¾èµ–äº  ä¸»ç¨‹åºã€‚
è¿™æœ‰å¾ˆå¤šä¼˜ç‚¹ï¼Œä¾‹å¦‚ï¼Œå³ä½¿ç¨‹åºæ”¹å˜äº†ï¼Œä¹Ÿå§‹ç»ˆèƒ½å¤Ÿè¯»å–çŠ¶æ€ï¼ˆåªè¦è¾“å…¥æˆ–è¾“å‡ºçš„ç±»å‹æ²¡æœ‰æ”¹å˜ï¼‰ã€‚æˆ–è€…ä½ æ­£åœ¨åŸºäºä¸€ä¸ªå·²ç»å­˜åœ¨çš„ç¨‹åºåˆ›å»ºæœåŠ¡ï¼Œä½ éœ€è¦ä¸€äº›è‡ªå·±çš„å‡½æ•°æ¥ä»çŠ¶æ€ä¸­è·å¾—ä½ è‡ªå·±çš„æ•°æ®å—ã€‚
ä¸ºæ­¤ï¼Œæˆ‘ä»¬éœ€è¦åˆ›å»ºä¸€ä¸ªç‹¬ç«‹çš„ç¨‹åºå¹¶åœ¨ metawasm ç‰¹å¾ä¸­æè¿°å¿…è¦çš„åŠŸèƒ½ã€‚ä¾‹å¦‚ï¼š
// ...use gmeta::metawasm;#[metawasm]pub trait Metawasm {    type State = Vec<Wallet>;    fn all_wallets(state: Self::State) -> Vec<Wallet> {        state    }    fn first_wallet(state: Self::State) -> Option<Wallet> {        state.first().cloned()    }    fn last_wallet(state: Self::State) -> Option<Wallet> {        state.last().cloned()    }}
æ›´å¤šå¤æ‚çš„ä¾‹å­ï¼š
// ...use gmeta::metawasm;#[metawasm]pub trait Metawasm {    type State = Vec<Wallet>;    fn wallet_by_id(id: Id, state: Self::State) -> Option<Wallet> {        state.into_iter().find(|w| w.id == id)    }    fn wallet_by_person(person: String, state: Self::State) -> Option<Wallet> {        state.into_iter().find(|w| w.person == person)    }}
è¦æ„å»º meta.wasmï¼Œéœ€è¦åœ¨é¡¹ç›®æ ¹ç›®å½•ä¸‹è®¾ç½® build.rs æ–‡ä»¶ï¼š
fn main() {    gear_wasm_builder::build_metawasm();}
è¯·çœ‹æ›´å¤šå…³äº metadataçš„å†…å®¹ã€‚ç¼–è¾‘æ­¤é¡µä¸Šä¸€é¡µMailboxä¸‹ä¸€é¡µå…ƒæ•°æ®State å‡½æ•°è‡ªå®šä¹‰ç¨‹åºè¯»å–çŠ¶æ€








Attention developers! | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable ğŸš§StableEnglishEnglishç®€ä½“ä¸­æ–‡SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsIntroductionGear LibraryMailboxState FunctionsMetadataData Encoding/DecodingAsynchronous ProgrammingCreate ProgramGas ReservationDelayed MessagesConsistency and ReliabilitySystem SignalsReply DepositUpload ProgramProgram RentProgram TestingTesting with gtestTesting with gclientSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksDeveloping Smart ContractsIntroductionOn this pageAttention developers!
importantWant to take your blockchain development skills to the next level? Join Gear Academy's free course, "Gear Smart Contract Developer." In this comprehensive course, you'll learn the ins and outs of developing on the Gear Protocol, from deploying programs onto the blockchain and interacting with them, to testing your programs on the Gear Network. You'll also gain hands-on experience navigating the @gear-js library for interacting with contracts on the client side and developing real-world applications, including contracts and frontends. Don't miss this opportunity to become a pro Gear blockchain developer. Enroll now in Gear Academy's "Gear Smart Contract Developer" course!
What is a Gear smart contract?â€‹
Gear smart contract a just a program that runs on the Gear Protocol. It is a piece of code compiled to Wasm that is deployed to the blockchain and can be executed by anyone who sends a message to it. The program can store data, receive and send messages, and perform any other actions that are allowed by the Gear Protocol.
Every program should have a set of exported functions that can be called by the Gear Protocol. These functions are called entry points. The Gear Protocol has a set of predefined entry points that are used to initialize the program, handle incoming messages, and process replies to previously sent messages.
But we can't implement any business logic without using imported functions that form the API for the program. The Gear Protocol has a set of predefined API functions that can be used by any program. There are low-level functions that allow us to load incoming message's payload, send messages, and perform other actions. And there are higher-level libraries that allow us to interact with the Gear Protocol in a more convenient way.
Predefined entry points (exported functions)â€‹
The central exported function of the Gear smart contract is handle(). It is called every time the program receives an incoming message. Below is the Rust example code:
#[no_mangle]extern "C" fn handle() {    // Execute this code during explicitly incoming message}
This function is obligatory to be defined in the program.
In this function, we are to define the main business logic of our program. For example, we can check the incoming message and perform some actions depending on the message type. Also, we can send a message to another program. Finally, we can send a reply to the message that was received by the program.
As with any other program intended to be executed in some environment, Gear smart contract has its own lifecycle. It is initialized, receives messages, and can be terminated. We are to define the optional init() function if we want to perform some actions during the initialization of the program. For example, we can store some data in the program's memory. The init() function is called only once during the program initialization.
#[no_mangle]extern "C" fn init() {    // Execute this code during contract initialization}
If there is no init() function in the program, the program will be initialized without any custom actions.
And the third most important function is handle_reply(). It is called when the program receives a reply to the message that was sent by the program. For example, we can check the reply and perform some actions depending on the reply type.
#[no_mangle]extern "C" fn handle_reply() {    // Execute this code during handling reply on the previously sent message}
There is no need to define the handle_reply() function if the program doesn't intend to receive replies. In this case, the program will ignore all incoming replies.
The reply message is similar to the ordinary message, but it has some differences:

The reply message is sent to the user or program that has sent the original message. We can't set the destination of the reply message explicitly.
We can send only one reply message per execution. We get an error if we try to send more than one reply message.
Even if the program execution is failed (for example, panic is called or the gas limit is exceeded), the reply message will be sent anyway.
The reply message is processed in handle_reply() function instead of handle() function for the ordinary message. We have mentioned this above but it is worth to underline it again.

API functions (imported functions)â€‹
There are a lot of imported functions that can be used by the Gear smart contract. They are called API functions. These functions are provided by the runtime that executes the Gear smart contract. The most convenient way to use these functions is to use the Gear standard library called gstd. It is a set of high-level functions that are implemented on top of the low-level API functions.
More details about the Gear standard library can be found in the Gear Library section.
Basic stages of the Gear smart contract lifecycleâ€‹
Let's explore the typical lifecycle of a Gear smart contract. We will use the Rust programming language for the examples, but the same principles are applied to any other language that can be compiled into Wasm.
Step 1. Write the program code.
You can find the minimal example in the Getting Started section. It is a simple program that stores the counter, can increment and decrement it, and return the current value of the counter.
More advanced examples can be found in the Gear Fooundation organization on GitHub: https://github.com/gear-foundation
Step 2. Test the program.
We recommend using the gtest crate for testing Gear smart contracts. It allows us to write unit tests for the program and run them in the local environment.
The more advanced way to test the program is to use the gclient crate that allows you to run the program in the blockchain network. It is useful when you need to test the program in a real environment.
You can find more details about testing in the Program Testing section.
Step 3. Compile the program into Wasm.
We recommend using the gear-wasm-builder crate in a custom build script build.rs.
Add it to the [build-dependencies] section in the Cargo.toml file:
[build-dependencies]gear-wasm-builder = { git = "https://github.com/gear-tech/gear.git", tag = "v1.0.2", features = ["wasm-opt"] }
And add the following code to the build.rs file:
fn main() {    gear_wasm_builder::build();}
You can find built Wasm files in the target/wasm32-unknown-unknown/release directory.
Step 4. Deploy the program to the blockchain.
Program deployment is a process of storing the program's Wasm code on the blockchain and its initialization. The user pays a fee for the deployment transaction. The program is deployed to the blockchain only once. After that, it can be executed by anyone by sending a message to it.
If initialization fails (for example, the program panics in the init() function), the program is not deployed and the user gets an error.
Also, it is important to underline that someone should pay rent for keeping the program in the blockchain after a free period that is equal to 5 million blocks (it is about 2 months for networks with 1 block per second production). It is possible to add funds for rent using the pay_program_rent extrinsic (by the user) or with the gstd::exec::pay_program_rent API function (by the program). If the rent is not paid, the program state changes to pause, its persistent memory is removed from the storage, and the program can't be executed. The program can be resumed by uploading its memory pages to the blockchain and paying the rent.
You can find more details about program deployment in the Upload Program section.
Step 5. Execute the program.
The program can be executed by sending a message to it. The message can be sent by the user or by another program. The user pays a fee for the message execution. The program can send a reply to the message. The reply is sent to the user or program that has sent the original message.
Step 6. Terminate the program.
The program can be terminated by calling the gstd::exec::exit function. Also, the program is paused if the rent is not paid.
The program can't be executed after termination.
Smart contract key featuresâ€‹
Gear smart contracts have a lot of features that make them unique. Let's explore the most important of them.
State functionâ€‹
Gear smart contracts can store the state in persistent memory. Anyone can read this memory from the blockchain.
To make state reading more convenient, Gear smart contracts can define the state() function.
#[no_mangle]extern "C" fn state() {    msg::reply(any_encodable_data, 0).expect("Failed to share state");}
This function is stored in the blockchain in the same Wasm blob with handle() and init() functions. But unlike them, it is not executed using extrinsic and doesn't affect the blockchain state. It can be executed for free by any node with a fully synchronized blockchain state. There is a dedicated read_state RPC call for this.
The data returned by the state() function can be converted to any convenient representation by using a state-conversion program. This is a separate program compiled into Wasm and dedicated to being executed on the off-chain runner. It should contain a set of meta-functions that accept the data returned by the state() function and return the data in a convenient format. There is a dedicated read_state_using_wasm RPC call for reading the program state using the state-conversion program.
More details about state functions can be found in the State Functions section.
Asynchronous programmingâ€‹
In some cases, it is more convenient to express some concepts in an asynchronous programming style. For example, when you need to wait for a reply from another program or wait for a certain time.
Under the hood, the async/await syntax is a kind of syntactic sugar that generates a state machine around gstd::exec::wait and gstd::exec::wake functions. The state machine is stored in the program's persistent memory.
Note that in case of using async functions, you are to declare the async main() function with #[async_main] attribute instead of the handle() function:
#[gstd::async_main]async fn main() {    // Async code here}
The initialization function can also be declared as an async function:
#[gstd::async_init]async fn init() {    // Async init code here}
You can find more details about asynchronous programming in the Asynchronous Programming section.
Creating programs from programsâ€‹
Both users and programs are actors in terms of the Gear smart contract model. Therefore, any actor can create a new program and deploy it to the blockchain.
The only pre-requisite is that the code of the program should be stored in the blockchain. This can be done by using the upload_code extrinsic that returns an identifier of the uploaded code. The code can be uploaded only once, then it can be used for creating multiple programs.
There are several helper functions for creating programs from programs in the gstd::prog module.
More details about creating programs from programs can be found in the Create Program section.
Gas reservationâ€‹
Gear smart contracts use gas for measuring the complexity of the program execution. The user pays a fee for the gas used by the program. Some part of the gas limit may be reserved during the current execution to be spent later. This gas reserving mechanism can be used to shift the burden of paying for program execution from one user to another. Also, it makes it possible to run some deferred actions using delayed messages described below.
You can find more details about gas reservation in the Gas Reservation section.
Delayed messagesâ€‹
Gear smart contracts can send messages to other actors not only during the current execution but also after some time. This mechanism can be used to implement deferred actions.
Use functions with *_delayed suffix from gstd::msg module to send a delayed message to a program or user. The message will be sent after the specified number of blocks.
More details about delayed messages can be found in the Delayed Messages section.
System signalsâ€‹
Sometimes the system that executes the program should communicate with it in some manner. For example, the program should be notified when the rent is not paid. This can be done by using system signals.
The handle_signal() function should be declared in the program to handle system signals. It is executed when the program receives a system signal.
 #[no_mangle]extern "C" fn handle_signal() {    // Handle system signal here}
You can find more details about system signals in the System Signals section.
Reply depositâ€‹
Usually the reply sender pays a gas fee for the reply message execution. But sometimes it is more convenient to shift this burden to the program that receives the reply. This can be done by using the reply deposit mechanism.
The reply deposit is a part of the gas limit reserved during the current execution to be spent later. The reserved gas can be used to pay for the reply message execution. To do this, the program should call the gstd::exec::reply_deposit function. This function provides a gas deposit from the current message to handle the reply message on the given message ID. This message ID should be sent within the execution. Once the destination actor or system sends a reply to it, the gas limit ignores it; if the program gives a deposit, only it will be used for the execution of handle_reply.
You can find more details about reply deposit in the Reply Deposit section.Edit this pagePreviousTroubleshootingNextGear LibraryWhat is a Gear smart contract?Predefined entry points (exported functions)API functions (imported functions)Basic stages of the Gear smart contract lifecycleSmart contract key featuresState functionAsynchronous programmingCreating programs from programsGas reservationDelayed messagesSystem signalsReply deposit








æ•°æ®åºåˆ—åŒ–/ååºåˆ—åŒ– | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())è·³åˆ°ä¸»è¦å†…å®¹Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeä¸‹ä¸€é¡µUnstable ğŸš§ä¸‹ä¸€é¡µç®€ä½“ä¸­æ–‡Englishç®€ä½“ä¸­æ–‡æœç´¢æ¬¢è¿Intro to Gear Protocol5 åˆ†é’Ÿå¿«é€Ÿå…¥é—¨Gear NodeDeveloping Smart Contractså¯æ‰§è¡Œå‡½æ•°Gear åº“MailboxState å‡½æ•°å…ƒæ•°æ®æ•°æ®åºåˆ—åŒ–/ååºåˆ—åŒ–å¼‚æ­¥åˆçº¦åˆ›å»ºåˆçº¦Gas é¢„ç•™å»¶è¿Ÿæ¶ˆæ¯ä¸€è‡´æ€§å’Œå¯é æ€§System Signalséƒ¨ç½²åˆçº¦Reply DepositProgram Rentåˆçº¦æµ‹è¯•Testing with gtestTesting with gclientSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksDeveloping Smart Contractsæ•°æ®åºåˆ—åŒ–/ååºåˆ—åŒ–æœ¬é¡µæ€»è§ˆæ•°æ®åºåˆ—åŒ–/ååºåˆ—åŒ–
ä¸ºäº†ä¼˜åŒ–æ•°æ®åœ¨ç½‘ç»œä¸Šçš„å‘é€å’Œæ¥æ”¶æ–¹å¼ï¼ŒGear ä½¿ç”¨parity-scale-codecï¼Œè¿™æ˜¯ SCALE ç¼–è§£ç å™¨çš„ Rust å®ç°ã€‚è¿™ä¸ªç¼–è§£ç å™¨è¢« Substrate èŠ‚ç‚¹çš„å†…éƒ¨ runtime æ‰€ä½¿ç”¨ã€‚SCALE æ˜¯ä¸€ç§è½»é‡çº§çš„ç¼–ç æ ¼å¼ï¼Œèƒ½å¤Ÿå®ç°æ•°æ®çš„åºåˆ—åŒ–å’Œ  ååºåˆ—åŒ–ã€‚ä½¿ç”¨ SCALE å¯¹æ•°æ®è¿›è¡Œç¼–ç ï¼ˆå’Œè§£ç ï¼‰ï¼Œå®ƒéå¸¸é€‚ç”¨äºèµ„æºå—é™çš„æ‰§è¡Œç¯å¢ƒï¼Œå¦‚åŒºå—é“¾è¿è¡Œæ—¶é—´å’Œä½åŠŸè€—ã€ä½å†…å­˜è®¾å¤‡ã€‚
åœ¨ç¨‹åºä¸­ä½¿ç”¨ SCALE codecï¼ŒCargo.toml éœ€è¦æ·»åŠ ä»¥ä¸‹å†…å®¹ï¼š
[dependencies]// ...codec = { package = "parity-scale-codec", version = "3.1.2", default-features = false }
use codec::{Decode, Encode};#[derive(Encode, Decode)]enum MyType {    MyStruct { field: ... },    ...}
ä¿¡æ¯æˆ‘ä»¬åªéœ€è¦åœ¨ä½¿ç”¨ gstd çš„åŒ…è£…æ–¹æ³•æ—¶ä½¿ç”¨ Encode å’Œ Decode ç‰¹æ€§ï¼Œä¾‹å¦‚ msg::sendï¼Œmsg::replyï¼Œsend_for_reply ç­‰ã€‚åƒ send_byte æˆ–reply_bytes è¿™æ ·çš„æ–¹æ³•ï¼Œæˆ‘ä»¬æ“ä½œçš„æ˜¯å­—èŠ‚æ•°ç»„ï¼Œæ‰€ä»¥ä¸éœ€è¦è¿›è¡Œè§£ç /ç¼–ç ã€‚
æ›´å¤šçš„å†…å®¹è¯·çœ‹ SCALE Codecã€‚
scale-infoâ€‹
scale-info æ˜¯ä¸€ä¸ªæè¿° Rust ç±»å‹çš„åº“ï¼Œ æä¾›æœ‰å…³å¯ç¼–ç  SCALE ç±»å‹ç»“æ„çš„ä¿¡æ¯ã€‚
è¿™äº›ç¬¬ä¸‰æ–¹å·¥å…· (ä¾‹å¦‚ UI å®¢æˆ·ç«¯) æä¾›äº†å…³äºå®ƒä»¬å¦‚ä½•èƒ½å¤Ÿè§£ç ä¸å—è¯­è¨€å½±å“çš„ç±»å‹çš„ä¿¡æ¯ã€‚Gear ç¨‹åºä½¿ç”¨ scale-info çš„æ¥å£ç§°ä¸º metadataã€‚å®ƒä¸ºæ‰€æœ‰å¿…è¦çš„å…¥å£ç‚¹å®šä¹‰äº†è¾“å…¥å’Œè¾“å‡ºç±»å‹ï¼Œå¹¶å…è®¸åˆçº¦å’Œå®¢æˆ·ç«¯ç›¸äº’ç†è§£ã€‚
ä¿¡æ¯å¦‚ä½•åœ¨åˆçº¦ä¸­ä½¿ç”¨ metadataï¼Œè¯·çœ‹é“¾æ¥
åœ¨é¡¹ç›®ä¸­ä½¿ç”¨ scale-infoï¼š
[dependencies]// ...scale-info = { version = "2.1.1", default-features = false, features = ["derive"] }
æ›´å¤šçš„å†…å®¹è¯·çœ‹ scale-infoã€‚ç¼–è¾‘æ­¤é¡µä¸Šä¸€é¡µå…ƒæ•°æ®ä¸‹ä¸€é¡µå¼‚æ­¥åˆçº¦scale-info








å¼‚æ­¥åˆçº¦ | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())è·³åˆ°ä¸»è¦å†…å®¹Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeä¸‹ä¸€é¡µUnstable ğŸš§ä¸‹ä¸€é¡µç®€ä½“ä¸­æ–‡Englishç®€ä½“ä¸­æ–‡æœç´¢æ¬¢è¿Intro to Gear Protocol5 åˆ†é’Ÿå¿«é€Ÿå…¥é—¨Gear NodeDeveloping Smart Contractså¯æ‰§è¡Œå‡½æ•°Gear åº“MailboxState å‡½æ•°å…ƒæ•°æ®æ•°æ®åºåˆ—åŒ–/ååºåˆ—åŒ–å¼‚æ­¥åˆçº¦åˆ›å»ºåˆçº¦Gas é¢„ç•™å»¶è¿Ÿæ¶ˆæ¯ä¸€è‡´æ€§å’Œå¯é æ€§System Signalséƒ¨ç½²åˆçº¦Reply DepositProgram Rentåˆçº¦æµ‹è¯•Testing with gtestTesting with gclientSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksDeveloping Smart Contractså¼‚æ­¥åˆçº¦æœ¬é¡µæ€»è§ˆå¼‚æ­¥åˆçº¦
Gear ç¨‹åºä¹‹é—´çš„å¼‚æ­¥äº¤äº’ä¸é€šå¸¸çš„å¼‚æ­¥è¯·æ±‚ç±»ä¼¼ï¼Œåœ¨ä½¿ç”¨awaitå¹¶é€šè¿‡å‘é€æ¶ˆæ¯æ¥å®ç°ã€‚
ç¨‹åºå…¥å£â€‹
å¦‚æœä¸€ä¸ªç¨‹åºä½¿ç”¨å¼‚æ­¥ä¿¡æ¯ï¼Œå®ƒçš„ä¸»è¦å¯æ‰§è¡Œå‡½æ•°å°±ä¼šæ”¹å˜ã€‚
async_init()â€‹
å¦‚æœåœ¨ç¨‹åºåˆå§‹åŒ–ä¸­å­˜åœ¨å¼‚æ­¥è°ƒç”¨ï¼Œé‚£ä¹ˆæˆ‘ä»¬åº”è¯¥ä½¿ç”¨ async_init() è€Œä¸æ˜¯ init()ã€‚
#[gstd::async_init]async fn init() {    gstd::debug!("Hello world!");}
main()â€‹
å¯¹äºå¼‚æ­¥ä¿¡æ¯ä¹Ÿæ˜¯å¦‚æ­¤ï¼Œæˆ‘ä»¬ç”¨ main ä»£æ›¿ handle ã€handle_replyã€‚
#[gstd::async_main]async fn main() {    gstd::debug!("Hello world!");}
ä¿¡æ¯async_init å¯ä»¥å’Œ async_main ä¸€èµ·ä½¿ç”¨ã€‚ä½†å¦‚æœä½¿ç”¨è¿™ä¸ªå®ï¼Œå°±ä¸èƒ½æŒ‡å®š init å’Œ handle_reply å‡½æ•°ã€‚
è·¨ç¨‹åºæ¶ˆæ¯é€šè®¯
è¦å‘ Gear ç¨‹åºå‘é€æ¶ˆæ¯ï¼Œä½¿ç”¨å‡½æ•° send_for_reply(program, payload, value)ï¼Œåœ¨è¿™ä¸ªå‡½æ•°ä¸­ï¼š

program - å‘é€æ¶ˆæ¯çš„ç¨‹åºçš„åœ°å€
payload - ç¨‹åºçš„æ¶ˆæ¯
value - é™„åœ¨æ¶ˆæ¯ä¸Šçš„èµ„é‡‘
reply_deposit - ç”¨äºä¸ºæœªæ¥çš„å›å¤å¤„ç†æä¾› gasï¼ˆå¦‚æœä¸ºé›¶åˆ™è·³è¿‡ï¼‰

  pub fn send_for_reply_as<E: Encode, D: Decode>(    program: ActorId,    payload: E,    value: u128,    reply_deposit: u64) -> Result<CodecMessageFuture<D>>ç¼–è¾‘æ­¤é¡µä¸Šä¸€é¡µæ•°æ®åºåˆ—åŒ–/ååºåˆ—åŒ–ä¸‹ä¸€é¡µåˆ›å»ºåˆçº¦ç¨‹åºå…¥å£async_init()main()








æ™ºèƒ½åˆçº¦è‡ªåŠ¨åŒ–å»¶è¿Ÿæ¶ˆæ¯ | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())è·³åˆ°ä¸»è¦å†…å®¹Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeä¸‹ä¸€é¡µUnstable ğŸš§ä¸‹ä¸€é¡µç®€ä½“ä¸­æ–‡Englishç®€ä½“ä¸­æ–‡æœç´¢æ¬¢è¿Intro to Gear Protocol5 åˆ†é’Ÿå¿«é€Ÿå…¥é—¨Gear NodeDeveloping Smart Contractså¯æ‰§è¡Œå‡½æ•°Gear åº“MailboxState å‡½æ•°å…ƒæ•°æ®æ•°æ®åºåˆ—åŒ–/ååºåˆ—åŒ–å¼‚æ­¥åˆçº¦åˆ›å»ºåˆçº¦Gas é¢„ç•™å»¶è¿Ÿæ¶ˆæ¯ä¸€è‡´æ€§å’Œå¯é æ€§System Signalséƒ¨ç½²åˆçº¦Reply DepositProgram Rentåˆçº¦æµ‹è¯•Testing with gtestTesting with gclientSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksDeveloping Smart Contractså»¶è¿Ÿæ¶ˆæ¯æ™ºèƒ½åˆçº¦è‡ªåŠ¨åŒ–å»¶è¿Ÿæ¶ˆæ¯
æ™ºèƒ½åˆçº¦åœ¨å…¶ä»–åŒºå—é“¾ä¸Šç»§ç»­è¿è¡Œçš„é€šå¸¸æ–¹å¼æ˜¯ä¾é å¤–éƒ¨çš„ã€ä¸­å¿ƒåŒ–çš„èµ„æºã€‚è¿™æ„å‘³ç€åœ¨è¢«é“¾ä¸Šäº¤æ˜“è§¦å‘ä¹‹å‰ï¼Œè¿™äº›åˆçº¦çš„ä»£ç ä¸ä¼šè¿è¡Œå¹¶å¯¹åŒºå—é“¾çš„çŠ¶æ€è¿›è¡Œæ›´æ”¹ã€‚
å¤–éƒ¨äº¤æ˜“ä½œä¸ºä¸€ä¸ªâ€œæˆ³â€æ¥æ¿€æ´»æ™ºèƒ½åˆçº¦å¹¶å¯åŠ¨å…¶é€»è¾‘ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡å‘æ‹å–åˆçº¦å‘é€ä¸€ä¸ªæ¶ˆæ¯æ¥å¯åŠ¨æ‹å–ã€‚å½“æ‹å–æ—¶é—´è¿‡å»åï¼Œåˆçº¦å°†éœ€è¦å¤„ç†æ‹å–ç»“æœã€‚ç„¶è€Œï¼Œè¿™å°†ä¸  ä¼šå‘ç”Ÿï¼Œç›´åˆ°æœ‰äººå‘åˆåŒå‘é€é€‚å½“çš„æ¶ˆæ¯æ¥è§¦å‘è¿™ä¸€è¡ŒåŠ¨ã€‚
Gear Protocol é€šè¿‡å¼•å…¥å»¶è¿Ÿæ¶ˆæ¯ä¼ é€’åŠŸèƒ½è§£å†³äº†è¿™ä¸ªé—®é¢˜ã€‚Gear ç½‘ç»œä¸­çš„æ™ºèƒ½åˆçº¦èƒ½å¤Ÿæ‰§è¡Œæ— é™æ•°é‡çš„åŒºå—ï¼Œåªè¦æœ‰è¶³å¤Ÿçš„ gas æ¥æ‰§è¡Œã€‚gas é¢„ç•™å¯ä»¥ä¿è¯è¿™ä¸€ç‚¹ã€‚å› æ­¤ï¼Œåœ¨ dApp ä¸­åŒ…å«ä¸­å¿ƒåŒ–ç»„ä»¶çš„éœ€æ±‚è¢«æ¶ˆé™¤äº†ï¼Œå…è®¸å®ƒä»¬å®Œå…¨åœ¨é“¾ä¸Šè¿è¡Œã€‚
msg::send_delayed(program, payload, value, delay)msg::send_bytes_delayed(program, payload, value, delay)
å»¶è¿Ÿæ¶ˆæ¯å°†åœ¨æŒ‡å®šçš„ä»¥å—ä¸ºå•ä½çš„â€œå»¶è¿Ÿâ€ä¹‹åæ‰§è¡Œã€‚ä¾‹å¦‚ï¼Œåœ¨ä¸€ä¸ªç”Ÿæˆå—æ—¶é—´ä¸º 2 ç§’çš„ç½‘ç»œä¸­ï¼Œå»¶è¿Ÿ 30 ä¸ªå—ç­‰äº 1 åˆ†é’Ÿã€‚
è€ƒè™‘åˆ°æ‹å–çš„ä¾‹å­ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡å‘æ‹å–åˆçº¦å‘é€æ¶ˆæ¯æ¥å¼€å§‹æ‹å–ã€‚åœ¨å®Œæˆæ‰€æœ‰å¿…è¦çš„é€»è¾‘åï¼Œæ‹å–åˆåŒå°†å‘è‡ªå·±å‘é€ä¸€ä¸ªå»¶è¿Ÿæ¶ˆæ¯ï¼Œè¿™å°†åœ¨æŒ‡å®šæ—¶é—´åè§£å†³æ‹å–é—®é¢˜ã€‚ç¼–è¾‘æ­¤é¡µä¸Šä¸€é¡µGas é¢„ç•™ä¸‹ä¸€é¡µä¸€è‡´æ€§å’Œå¯é æ€§








System signals | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())è·³åˆ°ä¸»è¦å†…å®¹Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeä¸‹ä¸€é¡µUnstable ğŸš§ä¸‹ä¸€é¡µç®€ä½“ä¸­æ–‡Englishç®€ä½“ä¸­æ–‡æœç´¢æ¬¢è¿Intro to Gear Protocol5 åˆ†é’Ÿå¿«é€Ÿå…¥é—¨Gear NodeDeveloping Smart Contractså¯æ‰§è¡Œå‡½æ•°Gear åº“MailboxState å‡½æ•°å…ƒæ•°æ®æ•°æ®åºåˆ—åŒ–/ååºåˆ—åŒ–å¼‚æ­¥åˆçº¦åˆ›å»ºåˆçº¦Gas é¢„ç•™å»¶è¿Ÿæ¶ˆæ¯ä¸€è‡´æ€§å’Œå¯é æ€§System Signalséƒ¨ç½²åˆçº¦Reply DepositProgram Rentåˆçº¦æµ‹è¯•Testing with gtestTesting with gclientSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksDeveloping Smart ContractsSystem SignalsSystem signals
The Gear Protocol ensures system and program's state consistency via introducing special handling mechanisms for potential issues and corner cases.
Gear actors have three common entry points - init, handle, handle_reply. Another special system entry point introduced by the Gear Protocol is handle_signal. It allows the system to communicate with programs if it is necessary to notify (signal) that some event related to the program's messages has happened. Only the system (Gear node runtime) can send signal messages to a program.
First of all, it can be useful to free up resources occupied by the program. A custom async logic in Gear implies storing Futures in a program's memory. The execution context of Futures can occupy some significant amount of memory in the case of many futures. When a program sends a message and waits for a reply to be woken, the reply can not be received. So there might be the case that if the initial message in the waitlist runs out of gas or the gas amount is not enough to properly finish the execution, the programâ€™s state will be rolled back and Future will never be freed.
In this case, Futures remain in memory pages forever. Other messages are not aware of Futures associated with other messages. Over time, Futures accumulate in the program's memory so eventually a large amount of Futures limits the max amount of space the program can use.
In case a message has been removed from the waitlist due to gas constraints, the system sends a system message (signal) that is baked by an amount of reserved gas, which informs the program that itâ€™s message was removed from the waitlist. Based on this info, a program can clean up its used system resources (Futures).
The gstd library provides a separate exec::system_reserve_gas function for reserving gas specifically for system signal messages. It cannot be used for sending other regular cross-actor messages:
exec::system_reserve_gas(1_000_000_000).expect("Error during system gas reservation");
Even if this function hasn't been called, the system will reserve gas for system messages automatically with the default amount of 1_000_000_000.
If a signal message appears, it uses gas specifically reserved for such kinds of messages. If no gas has been reserved for system messages, they are just skipped and the program will not receive them.
If gas has been reserved but no system messages occur during the current execution, then this gas returns back from where it was taken. The same relates to gas reserved for non-system messages - gas returns back after a defined number of blocks or by the programâ€™s command.
handle_signal has a default implementation if the smart contract has async init or/and async main functions (see Asynchronous Programming for more details about async entry points). To define your own signal handler, you need to use the gstd::async_init/gstd::async_main macro with the specified handle_signal argument. For example:
#[gstd::async_main(handle_signal = my_handle_signal)]async fn main() {    // ...}fn my_handle_signal() {    // ...}
ä¿¡æ¯Note that the custom signal handler derives its default behavior.
Some useful functions that can be used in handle_signal:

msg::signal_from - returns an identifier of the message which caused the signal;
msg::signal_code - returns the reason code of the signal (see SignalCode enum for more details).

It can be useful for a developer when writing communication between programs. Developer can define my_handle_signal function and implement some logic there. For example, Program A sent a message to Program B. Program A is waiting for a reply from Program B but Program B runs out of gas. The current execution will be interrupted, but the system will send a signal to Program A and indicates the message identifier during which the execution was interrupted.
So, Program A sends a message and saves the message identifier:
exec::system_reserve_gas(2_000_000_000)    .expect("Error during system gas reservation");let result = msg::send_for_reply(address, payload, value, reply_deposit);let (msg_id, msg_future) = if let Ok(msg_future) = result {    (msg_future.waiting_reply_to, msg_future)} else {    // handle the error here};// save the `msg_id` in program stateunsafe { STATE.msg_id == msg::id() };let reply = msg_future.await;
The execution fails in Program B, and Program A receives a signal:
#[no_mangle]extern "C" fn my_handle_signal() {    if unsafe { STATE.msg_id == msg::signal_from() } {        // write logic here    }}
However, it is important to understand that the execution of my_handle_signal should not be long and should not consume a lot of gas. It can be used for tracking failures during the transaction. The program can use the information about failures the next time it is executed.
For programs written using the Gear Protocol's gstd library, such signals can be sent to programs automatically under the hood when applicable. If a smart contract developer implements a program using gcore or Gear's syscalls, then such signals should be considered in the program's code explicitly.ç¼–è¾‘æ­¤é¡µä¸Šä¸€é¡µä¸€è‡´æ€§å’Œå¯é æ€§ä¸‹ä¸€é¡µéƒ¨ç½²åˆçº¦








Reply deposit | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())è·³åˆ°ä¸»è¦å†…å®¹Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeä¸‹ä¸€é¡µUnstable ğŸš§ä¸‹ä¸€é¡µç®€ä½“ä¸­æ–‡Englishç®€ä½“ä¸­æ–‡æœç´¢æ¬¢è¿Intro to Gear Protocol5 åˆ†é’Ÿå¿«é€Ÿå…¥é—¨Gear NodeDeveloping Smart Contractså¯æ‰§è¡Œå‡½æ•°Gear åº“MailboxState å‡½æ•°å…ƒæ•°æ®æ•°æ®åºåˆ—åŒ–/ååºåˆ—åŒ–å¼‚æ­¥åˆçº¦åˆ›å»ºåˆçº¦Gas é¢„ç•™å»¶è¿Ÿæ¶ˆæ¯ä¸€è‡´æ€§å’Œå¯é æ€§System Signalséƒ¨ç½²åˆçº¦Reply DepositProgram Rentåˆçº¦æµ‹è¯•Testing with gtestTesting with gclientSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksDeveloping Smart ContractsReply DepositReply deposit
When a program or user sends a reply to a message, it should provide gas for the reply handling. The user replies using gear.sendReply extrinsic. The program uses the msg::reply or msg::reply_with_gas function.
Sometimes, it is more convenient to provide gas for the reply handling in advance. For example, if the program sends a message to another program and waits for a reply, it can provide gas for the reply handling in advance. In this case, the program doesn't need to provide gas for the reply handling when it sends a reply.
To provide gas for the reply handling in advance, the program should use the exec::reply_deposit function:
let message_id =    msg::send(msg::source(), b"Outgoing message", 0).expect("Failed to send message");exec::reply_deposit(message_id, 1_000_000_000).expect("Error during reply deposit");#[no_mangle]extern "C" fn handle_reply() {    // The reply handling will be paid with the deposited gas}
The program can deposit gas when using the msg::send_for_reply function by setting the reply_deposit parameter. The reply_deposit parameter is the amount of gas that will be reserved for the reply handling. The reply_deposit parameter is optional. If the reply_deposit parameter is zero, the program should provide gas for the reply handling when it sends a reply.
let message_id = msg::send_for_reply(    msg::source(),    b"Outgoing message",    0,    1_000_000_000,).expect("Failed to send message");#[no_mangle]extern "C" fn handle_reply() {    // The reply handling will be paid with the deposited gas}ç¼–è¾‘æ­¤é¡µä¸Šä¸€é¡µéƒ¨ç½²åˆçº¦ä¸‹ä¸€é¡µProgram Rent








Program Rent | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())è·³åˆ°ä¸»è¦å†…å®¹Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeä¸‹ä¸€é¡µUnstable ğŸš§ä¸‹ä¸€é¡µç®€ä½“ä¸­æ–‡Englishç®€ä½“ä¸­æ–‡æœç´¢æ¬¢è¿Intro to Gear Protocol5 åˆ†é’Ÿå¿«é€Ÿå…¥é—¨Gear NodeDeveloping Smart Contractså¯æ‰§è¡Œå‡½æ•°Gear åº“MailboxState å‡½æ•°å…ƒæ•°æ®æ•°æ®åºåˆ—åŒ–/ååºåˆ—åŒ–å¼‚æ­¥åˆçº¦åˆ›å»ºåˆçº¦Gas é¢„ç•™å»¶è¿Ÿæ¶ˆæ¯ä¸€è‡´æ€§å’Œå¯é æ€§System Signalséƒ¨ç½²åˆçº¦Reply DepositProgram Rentåˆçº¦æµ‹è¯•Testing with gtestTesting with gclientSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksDeveloping Smart ContractsProgram Rentæœ¬é¡µæ€»è§ˆProgram Rent
Gear Protocol utilizes a rent-based program management system. When developers upload a program (smart contract) to the network, its expiration date is assigned. The expiration period is measured in blocks.
After the expiration date, the program is automatically removed from storage, unless the owner chooses to extend its life by paying rent. The owner must indicate the number of additional blocks they can pay for, and they need to pay the rent in utility tokens to keep the program active beyond its initial expiration date.
ä¿¡æ¯Current initial rent period: 5,000,000 blocks (on Vara it will be around 173 days)
After uploading a program, you can observe a similar event:
gear.ProgramChanged
{    "id": "0xde76e4cf663ff825d94944d6f060204e83fbb5e24f8dfdbbdc25842df4f4135d",    "change": {        "Active": {            "expiration": "12,834,248"        }    }}
How to extend the rent of the program?â€‹
To extend the rent period of a program, simply call the special extrinsic gear.payProgramRent(programId, blockCount). See more
Can I restore a deleted program?â€‹
Yes. Since the blockchain stores all states for the entire history, you can restore the program's state to the previous block before it was deleted.
Why does Gear use the program rent system?â€‹

Optimization and efficient resource usage
Stimulating utility token usage
ç¼–è¾‘æ­¤é¡µä¸Šä¸€é¡µReply Depositä¸‹ä¸€é¡µåˆçº¦æµ‹è¯•How to extend the rent of the program?Can I restore a deleted program?Why does Gear use the program rent system?








Testing with gtest | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())è·³åˆ°ä¸»è¦å†…å®¹Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeä¸‹ä¸€é¡µUnstable ğŸš§ä¸‹ä¸€é¡µç®€ä½“ä¸­æ–‡Englishç®€ä½“ä¸­æ–‡æœç´¢æ¬¢è¿Intro to Gear Protocol5 åˆ†é’Ÿå¿«é€Ÿå…¥é—¨Gear NodeDeveloping Smart Contractså¯æ‰§è¡Œå‡½æ•°Gear åº“MailboxState å‡½æ•°å…ƒæ•°æ®æ•°æ®åºåˆ—åŒ–/ååºåˆ—åŒ–å¼‚æ­¥åˆçº¦åˆ›å»ºåˆçº¦Gas é¢„ç•™å»¶è¿Ÿæ¶ˆæ¯ä¸€è‡´æ€§å’Œå¯é æ€§System Signalséƒ¨ç½²åˆçº¦Reply DepositProgram Rentåˆçº¦æµ‹è¯•Testing with gtestTesting with gclientSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksDeveloping Smart ContractsTesting with gtestæœ¬é¡µæ€»è§ˆTesting with gtest
gtest simulates a real network by providing mockups of the user, program, balances, mailbox, etc. Since it does not include parts of the actual blockchain, it is fast and lightweight. But being a model of the blockchain network, gtest cannot be a complete reflection of the latter.
As we said earlier, gtest is excellent for unit and integration testing. It is also helpful for debugging Gear program logic. Nothing other than the Rust compiler is required for running tests based on gtest. It is predictable and robust when used in continuous integration.
Import gtest libâ€‹
To use the gtest library, you must import it into your Cargo.toml file in the [dev-dependencies] block to fetch and compile it for tests only:
[package]name = "first-gear-app"version = "0.1.0"authors = ["Your Name"]edition = "2021"[dependencies]gstd = { git = "https://github.com/gear-tech/gear.git", tag = "v1.0.2" }[build-dependencies]gear-wasm-builder = { git = "https://github.com/gear-tech/gear.git", tag = "v1.0.2" }[dev-dependencies]gtest = { git = "https://github.com/gear-tech/gear.git", tag = "v1.0.2" }
gtest capabilitiesâ€‹

Initialization of the common environment for running smart contracts:

    // This emulates node's and chain's behavior.    //    // By default, sets:    // - current block equals 0    // - current timestamp equals UNIX timestamp of your system.    // - minimal message id equal 0x010000..    // - minimal program id equal 0x010000..    let sys = System::new();

Program initialization:

    // Initialization of program structure from file.    //    // Takes as arguments reference to the related `System` and the path to wasm binary relatively    // the root of the crate where the test was written.    //    // Sets free program id from the related `System` to this program. For this case it equals 0x010000..    // Next program initialized without id specification will have id 0x020000.. and so on.    let _ = Program::from_file(        &sys,        "./target/wasm32-unknown-unknown/release/demo_ping.wasm",    );    // Also, you may use the `Program::current()` function to load the current program.    let _ = Program::current(&sys);    // We can check the id of the program by calling `id()` function.    //    // It returns `ProgramId` type value.    let ping_pong_id = ping_pong.id();    // There is also a `from_file_with_id` constructor to manually specify the id of the program.    //    // Every place in this lib, where you need to specify some ids,    // it requires generic type 'ID`, which implements `Into<ProgramIdWrapper>`.    //    // `ProgramIdWrapper` may be built from:    // - u64;    // - [u8; 32];    // - String;    // - &str;    // - ProgramId (from `gear_core` one's, not from `gstd`).    //    // String implementation means the input as hex (with or without "0x")    // Numeric    let _ = Program::from_file_with_id(        &sys,        105,        "./target/wasm32-unknown-unknown/release/demo_ping.wasm",    );    // Hex with "0x"    let _ = Program::from_file_with_id(        &sys,        "0xe659a7a1628cdd93febc04a4e0646ea20e9f5f0ce097d9a05290d4a9e054df4e",        "./target/wasm32-unknown-unknown/release/demo_ping.wasm",    );    // Hex without "0x"    let _ = Program::from_file_with_id(        &sys,        "e659a7a1628cdd93febc04a4e0646ea20e9f5f0ce097d9a05290d4a9e054df5e",        "./target/wasm32-unknown-unknown/release/demo_ping.wasm",    );    // Array [u8; 32] (e.g. filled with 5)    let _ = Program::from_file_with_id(        &sys,        [5; 32],        "./target/wasm32-unknown-unknown/release/demo_ping.wasm",    );    // If you initialize program not in this scope, in cycle, in other conditions,    // where you didn't save the structure, you may get the object from the system by id.    let _ = sys.get_program(105);

Getting the program from the system:

    // If you initialize program not in this scope, in cycle, in other conditions,    // where you didn't save the structure, you may get the object from the system by id.    let _ = sys.get_program(105);

Initialization of styled env_logger:

    // Initialization of styled `env_logger` to print logs (only from `gwasm` by default) into stdout.    //    // To specify printed logs, set the env variable `RUST_LOG`:    // `RUST_LOG="target_1=logging_level,target_2=logging_level" cargo test`    //    // Gear smart contracts use `gwasm` target with `debug` logging level    sys.init_logger();

Sending messages:

    To send message to the program need to call one of two program's functions:    // `send()` or `send_bytes()` (or `send_with_value` and `send_bytes_with_value` if you need to send a message with attached funds).    //    // Both of the methods require sender id as the first argument and the payload as second.    //    // The difference between them is pretty simple and similar to `gstd` functions    // `msg::send()` and `msg::send_bytes()`.    //    // The first one requires payload to be CODEC Encodable, while the second requires payload    // implement `AsRef<[u8]>`, that means to be able to represent as bytes.    //    // `send()` uses `send_bytes()` under the hood with bytes from payload.encode().    //    // First message to the initialized program structure is always the init message.    let res = program.send_bytes(100001, "INIT MESSAGE");

Processing the result of the program execution:

    // Any sending functions in the lib returns `RunResult` structure.    //    // It contains the final result of the processing message and others,    // which were created during the execution.    //    // It has 4 main functions.    // Returns the reference to the Vec produced to users messages.    // You may assert them as you wish, iterating through them.    assert!(res.log().is_empty());    // Returns bool which shows that there was panic during the execution    // of the main message.    assert!(!res.main_failed());    // Returns bool which shows that there was panic during the execution    // of the created messages during the main execution.    //    // Equals false if no others were called.    assert!(!res.others_failed());    // Returns bool which shows that logs contain a given log.    //    // Syntax sugar around `res.log().iter().any(|v| v == arg)`.    assert!(!res.contains(&Log::builder()));    // To build a log for assertion you need to use `Log` structure with its builders.    // All fields here are optional.    // Assertion with Logs from core are made on the Some(..) fields    // You will run into panic if you try to set the already specified field.    //    // Constructor for success log.    let _ = Log::builder();    // Constructor for error reply log.    //    // Note that error reply never contains payload.    // And its exit code equals 1, instead of 0 for success replies.    let _ = Log::error_builder();    // Letâ€™s send a new message after the program has been initialized.    // The initialized program expects to receive a byte string "PING" and replies with a byte string "PONG".    let res = ping_pong.send_bytes(100001, "PING");    // Other fields are set optionally by `dest()`, `source()`, `payload()`, `payload_bytes()`.    //    // The logic for `payload()` and `payload_bytes()` is the same as for `send()` and `send_bytes()`.    // First requires an encodable struct. The second requires bytes.    let log = Log::builder()        .source(ping_pong_id)        .dest(100001)        .payload_bytes("PONG");    assert!(res.contains(&log));    let wrong_log = Log::builder().source(100001);    assert!(!res.contains(&wrong_log));    // Log also has `From` implementations from (ID, T) and from (ID, ID, T),    // where ID: Into<ProgramIdWrapper>, T: AsRef<[u8]>    let x = Log::builder().dest(5).payload_bytes("A");    let x_from: Log = (5, "A").into();    assert_eq!(x, x_from);    let y = Log::builder().dest(5).source(15).payload_bytes("A");    let y_from: Log = (15, 5, "A").into();    assert_eq!(y, y_from);    assert!(!res.contains(&(ping_pong_id, ping_pong_id, "PONG")));    assert!(res.contains(&(1, 100001, "PONG")));

Spending blocks:

    // You may control time in the system by spending blocks.    //    // It adds the amount of blocks passed as arguments to the current block of the system.    // Same for the timestamp. Note, that for now 1 block in Gear network is 1 sec duration.    sys.spend_blocks(150);

Balance:

    // If you need to send a message with value you have to mint balance for the message sender:    let user_id = 42;    sys.mint_to(user_id, 5000);    assert_eq!(sys.balance_of(user_id), 5000);    // To give the balance to the program you should use `mint` method:    let prog = Program::current(&sys);    prog.mint(1000);    assert_eq!(prog.balance(), 1000);ç¼–è¾‘æ­¤é¡µä¸Šä¸€é¡µåˆçº¦æµ‹è¯•ä¸‹ä¸€é¡µTesting with gclientImport gtest libgtest capabilities








ä»€ä¹ˆæ˜¯ dApp? | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())è·³åˆ°ä¸»è¦å†…å®¹Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeä¸‹ä¸€é¡µUnstable ğŸš§ä¸‹ä¸€é¡µç®€ä½“ä¸­æ–‡Englishç®€ä½“ä¸­æ–‡æœç´¢æ¬¢è¿Intro to Gear Protocol5 åˆ†é’Ÿå¿«é€Ÿå…¥é—¨Gear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsWeb3dAppæ™ºèƒ½åˆçº¦DeFiNFTDAOGear-based NetworksGeneral topicsdAppä»€ä¹ˆæ˜¯ dApp?
å»ä¸­å¿ƒåŒ–åº”ç”¨ï¼Œæˆ–ç§° dAppsï¼Œæ˜¯æŒ‡æä¾›ä¸ä¼ ç»Ÿåº”ç”¨ç±»ä¼¼çš„åŠŸèƒ½çš„åº”ç”¨ï¼Œä½†ä¸»è¦åŒºåˆ«åœ¨äºå®ƒä»¬æ˜¯åœ¨å»ä¸­å¿ƒåŒ–çš„ç‚¹å¯¹ç‚¹ç½‘ç»œä¸Šè¿è¡Œï¼Œå¦‚åŒºå—é“¾ã€‚å»ä¸­å¿ƒåŒ–çš„åº”ç”¨ç¨‹åºæä¾›æ„æˆ Web3 é©å‘½çš„æœåŠ¡ã€‚
å› ä¸º dApps æ˜¯å»ä¸­å¿ƒåŒ–çš„ï¼Œæ‰€ä»¥æ²¡æœ‰ä¸€ä¸ªå®ä½“æ§åˆ¶ç€åº”ç”¨ç¨‹åºã€‚ç›¸åï¼Œè¿™äº›åº”ç”¨ç¨‹åºæ˜¯å¼€æºçš„ï¼Œå…¶æ•°æ®æ˜¯å…¬å¼€çš„ã€‚DApps ä½¿ç”¨åŠ å¯†ä»¤ç‰Œæ¥å¸®åŠ©ä¿æŒç½‘ç»œå®‰å…¨ï¼Œè€Œä¸”å®ƒä»¬æ˜¯å®Œå…¨æ— æƒé™çš„ï¼Œè¿™æ„å‘³ç€ä»»ä½•äººã€ä»»ä½•åœ°æ–¹éƒ½å¯ä»¥ä¸å®ƒä»¬äº’åŠ¨ã€‚
é™¤äº†å…¶åŒ…å®¹æ€§å’Œç‰¹åˆ«ä½çš„å‡†å…¥é—¨æ§›ä¹‹å¤–ï¼Œä½¿ DApps å¦‚æ­¤åˆ›æ–°çš„åŸå› æ˜¯å®ƒä»¬å…·æœ‰æŠ—å®¡æŸ¥æ€§ã€‚è¿™æ„å‘³ç€ï¼Œç”±äºæ²¡æœ‰å•ç‚¹æ•…éšœï¼Œå¾ˆéš¾é™åˆ¶å¯¹å»ä¸­å¿ƒåŒ–åº”ç”¨çš„è®¿é—®ã€‚è¿™ç§ç¼ºä¹å•ç‚¹æ•…éšœçš„æƒ…å†µä¹Ÿæ„å‘³ç€ dApps å¾ˆéš¾è¢«æ”»å‡»ï¼Œè€Œä¸”å¾€å¾€æ˜¯é›¶åœæœºæ—¶é—´ã€‚
åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œè¦ä¸ dApp äº’åŠ¨ï¼Œç”¨æˆ·å¿…é¡»æ‹¥æœ‰è¯¥åº”ç”¨ç¨‹åºçš„åŸç”ŸåŠ å¯†ä»£å¸ã€‚ç¼–è¾‘æ­¤é¡µä¸Šä¸€é¡µWeb3ä¸‹ä¸€é¡µæ™ºèƒ½åˆçº¦








ä»€ä¹ˆæ˜¯ DeFi? | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())è·³åˆ°ä¸»è¦å†…å®¹Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeä¸‹ä¸€é¡µUnstable ğŸš§ä¸‹ä¸€é¡µç®€ä½“ä¸­æ–‡Englishç®€ä½“ä¸­æ–‡æœç´¢æ¬¢è¿Intro to Gear Protocol5 åˆ†é’Ÿå¿«é€Ÿå…¥é—¨Gear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsWeb3dAppæ™ºèƒ½åˆçº¦DeFiNFTDAOGear-based NetworksGeneral topicsDeFiä»€ä¹ˆæ˜¯ DeFi?
å»ä¸­å¿ƒåŒ–é‡‘èæ˜¯ä¸€ä¸ªé‡‘èæœåŠ¡çš„é›†åˆï¼Œæ˜¯å½“å‰é‡‘èä½“ç³»çš„æ›¿ä»£æ–¹æ¡ˆã€‚
ä¼ ç»Ÿé‡‘èè¡Œä¸šä¸é€æ˜ï¼Œå—åˆ°ä¸¥æ ¼æ§åˆ¶ï¼Œå¹¶ä¸”å·²ç»è¿‡æ—¶ï¼Œè€Œ DeFi èµ‹äºˆäº†ä¸ªäººæƒåŠ›ï¼Œè®©ä»–ä»¬å¯¹è‡ªå·±çš„è´¢åŠ¡æœ‰æ›´å¤šçš„ä¸ªäººæ§åˆ¶ã€‚DeFi åº”ç”¨ç¨‹åºä½¿ä¸ªäººèƒ½å¤Ÿå€Ÿæ¬¾ã€å‚¨è“„ã€æŠ•èµ„å’Œäº¤æ˜“ï¼Œè€Œä¸å¿…ä¾èµ–é“¶è¡Œã€äº¤æ˜“æ‰€æˆ–è´·æ¬¾æœºæ„ç­‰ç¬¬ä¸‰æ–¹ã€‚å®ƒèƒ½å¤Ÿåšåˆ°è¿™ä¸€ç‚¹ï¼Œå› ä¸ºå®ƒå»ºç«‹åœ¨åŒºå—é“¾æŠ€æœ¯ä¸Šï¼Œåˆ©ç”¨åŠ å¯†è´§å¸å’Œæ™ºèƒ½åˆçº¦ï¼Œå¯ä»¥è‡ªåŠ¨å’Œå³æ—¶åœ°æ‰§è¡Œäº¤æ˜“ã€‚
DeFi è§£å†³äº†ä¼ ç»Ÿé‡‘èä½“ç³»ä¸­çš„è®¸å¤šé—®é¢˜ã€‚é¦–å…ˆï¼Œå®ƒä½¿é‡‘èæœåŠ¡æ›´å®¹æ˜“è·å¾—å’ŒåŒ…å®¹ã€‚è¿™å¾ˆé‡è¦ï¼Œå› ä¸ºå®ƒä½¿ä»¥å‰è¢«æ’é™¤åœ¨å¤–çš„17äº¿å¤šäººèƒ½å¤Ÿè·å¾—å®‰å…¨å’Œå¯é çš„é‡‘èä¸šã€‚
é™¤æ­¤ä¹‹å¤–ï¼ŒDeFi æ¯”ä¼ ç»Ÿçš„é‡‘èæœåŠ¡æ›´å¿«ã€æ›´æœ‰æ•ˆï¼Œå› ä¸ºåº”ç”¨ç¨‹åºæ˜¯ç”±æ™ºèƒ½åˆçº¦é©±åŠ¨çš„ã€‚è¿™æ¶ˆé™¤äº†å¯¹ä¸­ä»‹æœºæ„çš„è¦æ±‚ï¼Œä»è€Œæ¶ˆé™¤äº†è®¸å¤šä¸é‡‘èæœåŠ¡ç›¸å…³çš„äº§ç”Ÿçš„è´¹ç”¨ã€‚
DeFi åº”ç”¨ç¨‹åºå¯ä»¥åœ¨ä¸–ç•Œä»»ä½•åœ°æ–¹å…¨å¤©å€™è®¿é—®ï¼Œè¿™æ„å‘³ç€ä¸ªäºº  ä¸å—é™äºåœ¨ç‰¹å®šæ—¥æœŸå’Œæ—¶é—´æˆ–ç‰¹å®šæ—¶åŒºæ“ä½œã€‚ç¼–è¾‘æ­¤é¡µä¸Šä¸€é¡µæ™ºèƒ½åˆçº¦ä¸‹ä¸€é¡µNFT








ä»€ä¹ˆæ˜¯ NFT? | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())è·³åˆ°ä¸»è¦å†…å®¹Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeä¸‹ä¸€é¡µUnstable ğŸš§ä¸‹ä¸€é¡µç®€ä½“ä¸­æ–‡Englishç®€ä½“ä¸­æ–‡æœç´¢æ¬¢è¿Intro to Gear Protocol5 åˆ†é’Ÿå¿«é€Ÿå…¥é—¨Gear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsWeb3dAppæ™ºèƒ½åˆçº¦DeFiNFTDAOGear-based NetworksGeneral topicsNFTä»€ä¹ˆæ˜¯ NFT?
éåŒè´¨åŒ–ä»£å¸ï¼ˆNFT - Non-Fungible Tokenï¼‰æ˜¯ä¸€ç§ç‹¬ç‰¹çš„åŠ å¯†ä»£å¸ç±»å‹ï¼Œèƒ½å¤Ÿå°†ç‹¬ç‰¹çš„æ•°æ®å•ä½é€šè¯åŒ–ï¼Œå¹¶å­˜å‚¨åœ¨åŒºå—é“¾ä¸Šã€‚
NFT æœ¬è´¨ä¸Šå¯ä»¥ä»£è¡¨ä»»ä½•ç‹¬ç‰¹çš„ä¸œè¥¿ï¼Œå…¶ç›®å‰æœ€å¸¸è§çš„ä½¿ç”¨æƒ…å†µæ˜¯ä»£è¡¨æ•°å­—è‰ºæœ¯å“çš„ä»£å¸ã€‚
ç„¶è€Œï¼Œä¸è®¸å¤šäººçš„çœ‹æ³•ç›¸åï¼ŒNFT çš„ç”¨ä¾‹å¹¶ä¸ä»…ä»…æ˜¯éªŒè¯è‰ºæœ¯å“çš„çœŸå®æ€§å’Œæ‰€æœ‰æƒã€‚
NFT å¯ä»¥ä»£è¡¨ä»»ä½•ä¸å¯æ›¿ä»£çš„ä¸œè¥¿ã€‚è¿™æ„å‘³ç€ï¼Œä»»ä½•å…·æœ‰ç‹¬ç‰¹å±æ€§çš„ä¸œè¥¿ç°åœ¨éƒ½æœ‰åŠæ³•ä»¥åŠ å¯†æ–¹å¼è¡¨ç¤ºï¼Œä»¥ä¾¿å­˜å‚¨åœ¨åŒºå—é“¾ä¸Šï¼Œä»å…¶ç‹¬ç‰¹çš„åŠŸèƒ½ä¸­è·ç›Šã€‚
NFT å¯ä»¥ç”¨æ¥ä»£è¡¨ä»»ä½•ä¸œè¥¿ï¼Œä»æˆ¿å­çš„åœ°å¥‘åˆ°äº§å“æˆ–æœåŠ¡çš„æ”¶æ®ã€‚
åœ¨æœªæ¥ï¼Œæ‰€æœ‰ç‹¬ç‰¹çš„æ•°æ®å•ä½éƒ½å¯èƒ½ä»¥æŸç§æ–¹å¼è¡¨ç¤ºä¸º NFTï¼Œå› ä¸ºå®ƒä»¬æ˜¯å­˜å‚¨æœ‰ä»·å€¼æ•°æ®çš„æ›´å®‰å…¨çš„æ–¹å¼ï¼Œè€Œä¸”å®ƒä»¬éå¸¸å®¹æ˜“è·å¾—ï¼Œè¿™ä½¿å¾—ä¼ ç»Ÿçš„éæµåŠ¨æ€§èµ„äº§çš„æµåŠ¨æ€§å¤§å¤§å¢åŠ ã€‚ç¼–è¾‘æ­¤é¡µä¸Šä¸€é¡µDeFiä¸‹ä¸€é¡µDAO








What is Web3? | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable ğŸš§StableEnglishEnglishç®€ä½“ä¸­æ–‡SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsWeb3dAppsSmart ContractsDeFiNFTDAOGear-based NetworksGeneral topicsWeb3What is Web3?
Web 3.0 is a new iteration of the internet thatâ€™s powered by new technologies like artificial intelligence, machine learning and most importantly, blockchain technology.
Web 3.0 aims to create a more open, connected and intelligent internet that is permissionless and open to everyone without monetizing personal data.
With Web3, anyone who is on the network has permission to use all Web3 services. There isnâ€™t a central authority who can block or deny access. Because Web3 is entirely decentralized, there isnâ€™t a single entity that owns or controls the network. Rather, the community are the ones who control the network. And because the infrastructure that powers Web3 is turing-complete, pretty much anything imaginable can get programmed as a decentralized application.
On top of that, most interactions and transactions that occur on Web3 will benefit in terms of security, speed and cost thanks to the unique nature of blockchain technology.
The value proposition is simple. The main advantage of Web3 is that it addresses the biggest problem thatâ€™s resulted from Web2 - the collection and monetization of personal data.
Web3 empowers the user and it creates a more efficient, secure and transparent Internet.Edit this pagePreviousReact-hooksNextdApps








Gear React-hooks | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())è·³åˆ°ä¸»è¦å†…å®¹Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeä¸‹ä¸€é¡µUnstable ğŸš§ä¸‹ä¸€é¡µç®€ä½“ä¸­æ–‡Englishç®€ä½“ä¸­æ–‡æœç´¢æ¬¢è¿Intro to Gear Protocol5 åˆ†é’Ÿå¿«é€Ÿå…¥é—¨Gear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSå¼€å§‹Keyringè®¡ç®— Gasä¸Šä¼ ç¨‹åºPay Program rentæäº¤ä»£ç å‘é€æ¶ˆæ¯è¯»å–çŠ¶æ€Voucherså…ƒæ•°æ® ä¸ Type CreationMailboxEventsç¤ºä¾‹Gear-JS toolsåˆ›å»º Gear AppMeta CLIReact-hooksGeneral topicsGear-based NetworksGear-JSGear-JS toolsReact-hooksæœ¬é¡µæ€»è§ˆGear React-hooks
Hooks allow functional components to have access to programs running on Gear networks and significantly simplify the development of front-end applications.
For example, refer to this article that demonstrates the creation of a React application that connects to an NFT smart contract running on the blockchain.
Installationâ€‹
npm install @gear-js/react-hooks
or
yarn add @gear-js/react-hooks
Getting startedâ€‹
Simple as it is, here's a quick example:
import { useReadFullState } from '@gear-js/react-hooks';import { useMetadata } from './use-metadata'import meta from 'assets/meta/meta.txt';function State() {  const programId = '0x01';  const { metadata } = useMetadata(meta);  const { state } = useReadFullState(programId, meta);  return <div>{JSON.stringify(state)}</div>;}export { State };
Cookbookâ€‹
ä¿¡æ¯In order for these hooks to work, the application must be wrapped in the appropriate Providers. As it is presented in the example. If you use create-gear-app, then all the necessary environment has already been provided.
useApiâ€‹
useApi provides access to the Gear API connected to the selected RPC-node.
import { useApi } from '@gear-js/react-hooks';const { api, isApiReady } = useApi();
useAccountâ€‹
useAccount provides interaction with Polkadot-js extension API, allows to manage accounts from it (for example to sign transactions).
import { useAccount } from '@gear-js/react-hooks';const { account, isAccountReady } = useAccount();
useAlertâ€‹
useAlert shows any alert in the application context.
import { useAlert } from '@gear-js/react-hooks';const alert = useAlert();// type?: 'info' | 'error' | 'loading' | 'success';alert.success('success message')
useMetadataâ€‹
This hook is auxiliary and it is not pre-installed in the react-hook library. useMetadata allows converting the program's metadata (.txt file) into the required format.
import { useEffect, useState } from 'react';import {  getProgramMetadata,  ProgramMetadata} from '@gear-js/api';import { Buffer } from 'buffer';export const useMetadata = (source: RequestInfo | URL) => {  const [data, setData] = useState<ProgramMetadata>();  useEffect(() => {    fetch(source)      .then((res) => res.text())      .then((raw) => getProgramMetadata(`0x${raw}`))      .then((meta) => setData(meta));  }, [source]);  return { metadata: data };};
useWasmMetadataâ€‹
This hook is auxiliary and it is not pre-installed in the react-hook library. useWasmMetadata allows getting Buffer array from the program meta.wasm. Buffer is required always when using custom functions to query specific parts of the program State.
import { useEffect, useState } from 'react';import { Buffer } from 'buffer';export const useWasmMetadata = (source: RequestInfo | URL) => {  const [data, setData] = useState<Buffer>();  useEffect(() => {    if (source) {      fetch(source)        .then((response) => response.arrayBuffer())        .then((array) => Buffer.from(array))        .then((buffer) => setData(buffer))        .catch(({ message }: Error) => console.error(`Fetch error: ${message}`));    }    // eslint-disable-next-line react-hooks/exhaustive-deps  }, [source]);  return { buffer: data };};
useSendMessageâ€‹
useSendMessage allows sending messages to the program.
import { useSendMessage } from '@gear-js/react-hooks';import { useMetadata } from './useMetadata';import meta from 'assets/meta/meta.txt';function sendMessage() {  const programId = '0x01';  const { metadata } = useMetadata(meta);  return useSendMessage(programId, metadata);}
useReadFullStateâ€‹
useReadFullState allows reading full program State.
import { useReadFullState } from '@gear-js/react-hooks';import { useMetadata } from './useMetadata';import meta from 'assets/meta/meta.txt';function readFullState() {  const programId = '0x01';  const { metadata } = useMetadata(meta);  const { state } = useReadFullState(programId, metadata);  return state;}
useReadWasmStateâ€‹
useReadWasmState allows reading program State using specific functions.
import { useReadWasmState } from '@gear-js/react-hooks';import { useWasmMetadata } from './useMetadata';import stateMetaWasm from 'assets/wasm/state.meta.wasm';function useProgramState<T>(functionName: string, payload?: any) {  const programId = '0x01';  const { buffer } = useWasmMetadata(stateMetaWasm);  return useReadWasmState<T>(    programId,    buffer,    functionName,    payload,  );}function firstState() {  const payload = 'some_payload'  const { state } = useProgramState('foo_1', payload);  return state;}function secondState() {  // if program state function doesn't have initial payload  const { state } = useProgramState('foo_2', null);  return state;}
useCreateHandlerâ€‹
useCreateHandler provides a tool for uploading the Gear program to the chain.
import { useCreateHandler } from '@gear-js/react-hooks';import meta from 'assets/meta/meta.txt';import { useMetadata } from './useMetadata';export function useCreateProgram(onSuccess: (programId: Hex) => void) {  const codeHash = '0x01';  const { metadata } = useMetadata(meta);  const createProgram = useCreateHandler(codeHash, meta);  return (payload) => createProgram(payload, { onSuccess });}ç¼–è¾‘æ­¤é¡µä¸Šä¸€é¡µMeta CLIä¸‹ä¸€é¡µWeb3InstallationGetting startedCookbookuseApiuseAccountuseAlertuseMetadatauseWasmMetadatauseSendMessageuseReadFullStateuseReadWasmStateuseCreateHandler








æŒä¹…åŒ–å†…å­˜ | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())è·³åˆ°ä¸»è¦å†…å®¹Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeä¸‹ä¸€é¡µUnstable ğŸš§ä¸‹ä¸€é¡µç®€ä½“ä¸­æ–‡Englishç®€ä½“ä¸­æ–‡æœç´¢æ¬¢è¿Intro to Gear Protocolæœ¯è¯­è¡¨æˆ‘ä»¬ä¸ºä»€ä¹ˆåˆ›å»º Gearï¼ŸGear çš„ç‹¬ç‰¹æ€§Gear Protocol TechnologyActor æ¨¡å‹SubstrateWebAssembly (Wasm)æŒä¹…åŒ–å†…å­˜Gear ç½‘ç»œçŠ¶æ€çŠ¶æ€è½¬ç§»5 åˆ†é’Ÿå¿«é€Ÿå…¥é—¨Gear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksIntro to Gear ProtocolGear Protocol TechnologyæŒä¹…åŒ–å†…å­˜Gear Protocol çš„å¦ä¸€ä¸ªçªå‡ºç‰¹ç‚¹æ˜¯æŒä¹…æ€§å†…å­˜æ–¹æ³•ã€‚å®ƒä½¿å¼€å‘æ›´å®¹æ˜“ï¼Œæ¶ˆé™¤äº†å¾ˆå¤šå¤æ‚æ€§ï¼Œå¹¶ä½¿åè®®å†…å­˜ç®¡ç†ä¸å®é™…ç¡¬ä»¶å’Œæ“ä½œç³»ç»Ÿç›¸åŒ¹é…ã€‚
åœ¨ Gear ç½‘ç»œä¸­è¿è¡Œçš„ç¨‹åºä¸ä½¿ç”¨å­˜å‚¨ï¼Œè€Œæ˜¯å°†å…¨éƒ¨çŠ¶æ€æŒä¹…åŒ–ï¼Œè¿™ç¡®ä¿äº†åŒºå—é“¾ä¸Šä¸‹æ–‡çš„ API é¢è¦å°å¾—å¤šã€‚å®ƒé¿å…äº†ç‰¹å®šé¢†åŸŸçš„è¯­è¨€ç‰¹å¾ï¼Œä¹Ÿå…è®¸ä½¿ç”¨æ›´å¤æ‚çš„è¯­è¨€ç»“æ„--æŒä¹…åŒ–çš„é—­åŒ…ã€åˆæˆå™¨ç­‰ã€‚
Gear Protocol ä½¿ç”¨äº†å·§å¦™çš„å†…å­˜è™šæ‹ŸåŒ–æŠ€æœ¯ (å°½ç®¡æ™®é€šçš„ Wasm æ²¡æœ‰)ï¼Œå†…å­˜åˆ†é…å’Œå›æ”¶æ˜¯è¯¥åè®®çš„ç¬¬ä¸€ç­‰ç³»ç»Ÿè°ƒç”¨ï¼Œè¿˜ä¼šè·Ÿè¸ªå†…å­˜è®¿é—®ï¼ŒåªåŠ è½½/å­˜å‚¨æ‰€éœ€çš„å†…å­˜é¡µã€‚è¿™ä½¿å¾—å­˜å‚¨åœ¨åŒºå—é“¾çŠ¶æ€ä¸­çš„æ™ºèƒ½åˆçº¦çš„å †æ ˆæ¡†æ¶ï¼ˆé€šå¸¸åœ¨æœŸè´§åŠå…¶åˆæˆå™¨ä¸­å‘ç°ï¼‰èƒ½å¤Ÿè¢«æ— ç¼æŒä¹…åŒ–ï¼Œå¹¶åœ¨éœ€è¦æ—¶è¢«è°ƒç”¨ï¼Œåœ¨è¯·æ±‚æ—¶ä¿ç•™å…¶çŠ¶æ€ã€‚
ç¨‹åºä»£ç å­˜å‚¨ä¸ºä¸€ä¸ªä¸å¯å˜çš„ Wasm blobã€‚æ¯ä¸ªç¨‹åºéƒ½æœ‰å›ºå®šæ•°é‡çš„å†…å­˜ï¼Œåœ¨æ¶ˆæ¯å¤„ç†ä¹‹é—´å­˜åœ¨ (æ‰€è°“çš„é™æ€åŒºåŸŸ)ã€‚
Gear å®ä¾‹æŒæœ‰æ¯ä¸ªç¨‹åºçš„å•ç‹¬å†…å­˜ç©ºé—´ï¼Œå¹¶ä¿è¯æŒä¹…æ€§ã€‚ä¸€ä¸ªç¨‹åºåªèƒ½åœ¨å®ƒè‡ªå·±çš„å†…å­˜ç©ºé—´å†…è¿›è¡Œè¯»å†™ï¼Œä¸èƒ½è®¿é—®å…¶ä»–ç¨‹åºçš„å†…å­˜ç©ºé—´ã€‚å•ç‹¬çš„å†…å­˜ç©ºé—´åœ¨ç¨‹åºåˆå§‹åŒ–æœŸé—´ä¸ºå…¶ä¿ç•™ï¼Œä¸éœ€è¦é¢å¤–çš„è´¹ç”¨ï¼ˆå®ƒåŒ…å«åœ¨ç¨‹åºçš„åˆå§‹åŒ–çš„è´¹ç”¨ä¸­ï¼‰ã€‚
ç¨‹åºå¯ä»¥æŒ‰ 64KB çš„å—åˆ†é…æ‰€éœ€çš„å†…å­˜é‡ã€‚æ¯ä¸ªå†…å­˜å—åˆ†é…éƒ½éœ€è¦ gas è´¹ã€‚æ¯ä¸ªé¡µé¢ (64KB) å•ç‹¬å­˜å‚¨åœ¨åˆ†å¸ƒå¼æ•°æ®åº“åç«¯ï¼Œä½†åœ¨è¿è¡Œæ—¶ï¼ŒGear èŠ‚ç‚¹æ„é€ è¿ç»­è¿è¡Œæ—¶å†…å­˜ï¼Œå¹¶å…è®¸ç¨‹åºåœ¨å…¶ä¸Šè¿è¡Œè€Œæ— éœ€é‡æ–°åŠ è½½ã€‚
å†…å­˜å¹¶è¡Œ
æ¯ä¸ªç¨‹åºå•ç‹¬çš„ç‹¬ç«‹å†…å­˜ç©ºé—´å…è®¸ Gear èŠ‚ç‚¹ä¸Šçš„æ¶ˆæ¯å¤„ç†å¹¶è¡ŒåŒ–ã€‚å¹¶è¡Œå¤„ç†æµçš„æ•°é‡ç­‰äº CPU æ ¸æ•°ã€‚æ¯ä¸ªæµå¤„ç†ç”¨äºä¸€ç»„å·²å®šä¹‰ç¨‹åºçš„æ¶ˆæ¯ã€‚å®ƒæ¶‰åŠä»å…¶  ä»–ç¨‹åºæˆ–å¤–éƒ¨å‘é€çš„æ¶ˆæ¯ (ç”¨æˆ·äº‹åŠ¡)ã€‚
ä¾‹å¦‚ï¼Œç»™å®šä¸€ä¸ªæ¶ˆæ¯é˜Ÿåˆ—ï¼Œå…¶ä¸­åŒ…å«é’ˆå¯¹ 100 ä¸ªä¸åŒç¨‹åºçš„æ¶ˆæ¯ï¼ŒGear èŠ‚ç‚¹è¿è¡Œåœ¨ä¸€ä¸ªé…ç½®äº† 2 ä¸ªå¤„ç†çº¿ç¨‹çš„ç½‘ç»œä¸Šã€‚Gear å¼•æ“ä½¿ç”¨è¿è¡Œæ—¶å®šä¹‰çš„æµæ•°é‡ (ç­‰äºä¸€ä¸ªå…¸å‹çš„éªŒè¯æœºä¸Šçš„ CPU æ ¸çš„æ•°é‡)ï¼Œå°†ç›®æ ‡ç¨‹åºçš„æ€»æ•°é™¤ä»¥æµçš„æ•°é‡ï¼Œå¹¶ä¸ºæ¯ä¸ªæµåˆ›å»ºä¸€ä¸ªæ¶ˆæ¯æ±  (æ¯ä¸ªæµ 50 ä¸ªç¨‹åº)ã€‚
ç¨‹åºè¢«åˆ†å‘åˆ°ä¸åŒçš„æµä¸­ï¼Œæ¯ä¸ªæ¶ˆæ¯å‡ºç°åœ¨å®šä¹‰äº†ç›®æ ‡ç¨‹åºçš„æµä¸­ã€‚å› æ­¤ï¼Œæ‰€æœ‰å‘ç»™ç‰¹å®šç¨‹åºçš„æ¶ˆæ¯éƒ½å‡ºç°åœ¨ä¸€ä¸ªå¤„ç†æµä¸­ã€‚
åœ¨æ¯ä¸ªå‘¨æœŸä¸­ï¼Œç›®æ ‡ç¨‹åºå¯ä»¥æœ‰å¤šä¸ªæ¶ˆæ¯ï¼Œä¸€ä¸ªæµå¤„ç†å¤§é‡ç¨‹åºçš„æ¶ˆæ¯ã€‚æ¶ˆæ¯å¤„ç†çš„ç»“æœæ˜¯æ¥è‡ªæ¯ä¸ªæµçš„ä¸€ç»„æ–°æ¶ˆæ¯è¢«æ·»åŠ åˆ°æ¶ˆæ¯é˜Ÿåˆ—ä¸­ï¼Œç„¶åå¾ªç¯å¾€å¤ã€‚åœ¨æ¶ˆæ¯å¤„ç†è¿‡ç¨‹ä¸­ç”Ÿæˆçš„ç»“æœæ¶ˆæ¯é€šå¸¸è¢«å‘é€åˆ°å¦ä¸€ä¸ªåœ°å€ (è¿”å›åŸç‚¹æˆ–ä¸‹ä¸€ä¸ªç¨‹åº)ã€‚
ç¼–è¾‘æ­¤é¡µä¸Šä¸€é¡µWebAssembly (Wasm)ä¸‹ä¸€é¡µGear ç½‘ç»œçŠ¶æ€





  
    
    
    
  
  
    window.location.href = '/zh-cn/docs/node/setting-up' + window.location.search + window.location.hash;
  







Actor Model | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable ğŸš§StableEnglishEnglishç®€ä½“ä¸­æ–‡SearchWelcome!Intro to Gear ProtocolWhy do we build Gear?Gear Distinctive FeaturesGear Protocol TechnologySubstrateActor ModelWebAssembly (Wasm)Persistent MemoryGear Network StateState TransitionGlossaryGetting StartedGear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksIntro to Gear ProtocolGear Protocol TechnologyActor ModelOn this pageActor Model
One of the key and distinguished features of the Gear Protocol is the Actor model for message-passing communications.
Actor model framework enables asynchronous messaging and parallel computation which drastically increases the achievable speed and allows building more complex dApps in an easier way. Asynchronous format of dApps written on the Gear Protocol makes them cross-chain compatible by default.
In concurrent computing systems, â€œmessage-passing communicationâ€ means that programs communicate by exchanging messages. This has its advantages over â€œshared memory communicationâ€ as message passing is easier to understand than shared memory concurrency as itâ€™s more robust and has better performance characteristics.
The principle of the Actor model approach is that programs never share any state and just exchange messages between each other. With the Actor model, a system consists of simultaneously functioning objects that communicate with each other exclusively by messaging.
While an ordinary Actor model does not guarantee message ordering, the Gear Protocol provides some additional guarantees that the order of messages between two particular programs is preserved.
Actors are isolated from each other and do not share memory. They have a state and the only way to change it is by receiving a message.
The Actor model guarantees high scalability and high fault tolerance. As applications become more computationally intensive over time in Web3, the Actor model will naturally allow advancements in CPU technology to support this continued scale.
Actorâ€‹
An Actor in the Actor model is an atomic computational unit that can send and receive messages. With Gear, any instance in the Gear Protocol is an Actor - a program (smart contract) or a user that sends messages to a program. Every Actor has an internal private state, also users have a mailbox. Communication is asynchronous, messages are popped out from the mailbox and allocated to message processing streams where theyâ€™re then processed in cycles.
When an actor receives and processes a message, the response can be the following:

Send a message to another actor
Create another actor
Change its own internal state

Actors are independent, they never share any state and just exchange messages with each other.
Using the Actor model approach provides a way to implement Actor-based concurrency inside smart contract logic. It can utilize various language constructs for asynchronous programming (Futures and async-await in Rust).
Async/await supportâ€‹
Unlike classes, Actors allow only one task to access their mutable state at a time, which makes it safe for code in multiple tasks to interact with the same instance of an actor.
Asynchronous functions significantly streamline concurrency management, but they do not handle the possibility of deadlocks or state corruption. To avoid deadlocks or state corruption, async functions should avoid calling functions that may block their thread. To achieve it, they use an await expression.
Currently, the lack of normal support of async/await patterns in the typical smart contracts code brings a lot of problems for smart contract developers. Actually, achieving better control in a smart contract program flow is actually more or less possible by adding handmade functions (like in Solidity smart contracts). But the problem with many functions in a contract is that one can easily get confused - which function can be called at which stage in the contract's lifetime. It brings unnecessary complexity for developers writing smart contracts using domain specific languages.
Gear natively provides arbitrary async/await syntax for any programs. It greatly simplifies development and testing and reduces the likelihood of errors in smart contract development. The Gear Protocol's API also allows synchronous messages by simply not using await expressions if the logic of the program requires it.Edit this pagePreviousSubstrateNextWebAssembly (Wasm)ActorAsync/await support








Persistent Memory | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable ğŸš§StableEnglishEnglishç®€ä½“ä¸­æ–‡SearchWelcome!Intro to Gear ProtocolWhy do we build Gear?Gear Distinctive FeaturesGear Protocol TechnologySubstrateActor ModelWebAssembly (Wasm)Persistent MemoryGear Network StateState TransitionGlossaryGetting StartedGear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksIntro to Gear ProtocolGear Protocol TechnologyPersistent MemoryAnother distinguished feature of the Gear Protocol is the Persistent memory approach. It is what makes development easier, removes a lot of complexity and makes protocol memory management match real-life hardware and operating systems.
Programs running in Gear Networks donâ€™t use storage but rather their full state is persisted which ensures much less API surface for blockchain context. It avoids domain-specific language features as well as allows using much more complex language constructs â€” persisted boxed closures, futures compositors, etc.
The Gear Protocol uses clever memory virtualization techniques (despite vanilla Wasm does not), memory allocation and deallocation are first-class syscalls of the protocol. Memory access is also tracked and only required pages are loaded/stored. That allows heap-allocated stack frames of smart contracts stored in the blockchainâ€™s state (typically found in futures and their compositors) to be seamlessly persisted and invoked when needed, preserving their state upon request.
Program code is stored as an immutable Wasm blob. Each program has a fixed amount of memory which persists between message-handling (so-called static area).
Gear instance holds individual memory space per program and guarantees its persistence. A program can read and write only within its own memory space and has no access to the memory space of other programs. Individual memory space is reserved for a program during its initialization and does not require an additional fee (it is included in the program's initialization fee).
A program can allocate the required amount of memory in blocks of 64KB. Each memory block allocation requires a gas fee. Each page (64KB) is stored separately on the distributed database backend, but at the run time, Gear node constructs continuous runtime memory and allows programs to run on it without reloads.
Memory parallelism
Individual isolated memory space per program allows parallelization of message processing on a Gear node. Number of parallel processing streams equals the number of CPU cores. Each stream processes messages intended for a defined set of programs. It relates to messages sent from other programs or from outside (userâ€™s transactions).
For example, given a message queue containing messages targeted to 100 different programs, Gear node runs on a network where 2 threads of processing are configured. Gear engine uses a runtime-defined number of streams (equal to number of CPU cores on a typical validator machine), divides total amount of targeted programs to number of streams and creates a message pool for each stream (50 programs per stream).
Programs are distributed to separate streams and each message appears in a stream where its targeted program is defined. So, all messages addressed to a particular program appear in a single processing stream.
In each cycle a targeted program can have more than one message and one stream processes messages for plenty of programs. The result of message processing is a set of new messages from each stream that is added to the message queue, then the cycle repeats. The resultant messages generated during message processing are usually sent to another address (return to origin or to the next program).
Edit this pagePreviousWebAssembly (Wasm)NextGear Network State








meta-cli | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())Skip to main contentReady to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeStableUnstable ğŸš§StableEnglishEnglishç®€ä½“ä¸­æ–‡SearchWelcome!Intro to Gear ProtocolGetting StartedGear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGetting StartedKeyringCalculate GasUpload ProgramPay Program rentUpload CodeSend MessageRead StateVouchersMetadata & Type CreationMailboxEventsCookbookGear-JS toolsGear React application templateMeta CLIReact-hooksGeneral topicsGear-based NetworksGear-JSGear-JS toolsMeta CLIOn this pageDeprecation NoticeThis CLI tool is deprecated and will be removed in the future.Please use getProgramMetadata from @gear-js/api instead as described here.
Gear Meta CLI
CLI tool to encode/decode payloads and work with .meta.wasm files.
Installationâ€‹
npm install -g @gear-js/gear-meta
or
yarn global add @gear-js/gear-meta
Usageâ€‹
Full list of commandsâ€‹
gear-meta --help
Available commandsâ€‹
decode - Decode payload from hex
encode - Encode payload to hex
meta - Display metadata from .meta.wasm
type - Display type structure for particular type from .meta.wasm
You can simply run these commands and you will be prompted to enter the necessary data. Or you can specify data through options:
-t, --type - Type to encode or decode the payload. If it is not specified you can select it later
-m, --meta - Path to .meta.wasm file with program's metadata
-o --output - Output JSON file. If it doesn't exist it will be created
-j --payloadFromJson - If need to take the payload from json
All of these options are available for decode and encode commands
-o --output option is available for meta command
-m, --meta option is available for type command
Examplesâ€‹
gear-meta encode '{"amount": 8, "currency": "GRT"}' -t init_input -m ./path/to/demo_meta.meta.wasm# Output:  # Result:  # 0x080c475254
gear-meta decode '0x080c475254' -t init_input -m ./path/to/demo_meta.meta.wasm# Output:  # Result:  # { amount: '8', currency: 'GRT' }
gear-meta type handle_input -m ./path/to/demo_meta.meta.wasm# Output:  # TypeName:  MessageIn  # { id: { decimal: 'u64', hex: 'Bytes' } }
gear-meta meta ./path/to/demo_meta.meta.wasm# Output:  # Result:  # {  #   types: '0x50000824646...0000023800',  #   init_input: 'MessageInitIn',  #   init_output: 'MessageInitOut',  #   async_init_input: 'MessageInitAsyncIn',  #   async_init_output: 'MessageInitAsyncOut',  #   handle_input: 'MessageIn',  #   handle_output: 'MessageOut',  #   async_handle_input: 'MessageHandleAsyncIn',  #   async_handle_output: 'MessageHandleAsyncOut',  #   title: 'Example program with metadata',  #   meta_state_input: 'Option<Id>',  #   meta_state_output: 'Vec<Wallet>',  #   meta_state: undefined  # }Edit this pagePreviousGear React application templateNextReact-hooksInstallationUsageFull list of commandsAvailable commandsExamples





  
    
    
    
  
  
    window.location.href = '/zh-cn/docs/api/calculate-gas' + window.location.search + window.location.hash;
  







Gear Meta CLI | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())è·³åˆ°ä¸»è¦å†…å®¹Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeä¸‹ä¸€é¡µUnstable ğŸš§ä¸‹ä¸€é¡µç®€ä½“ä¸­æ–‡Englishç®€ä½“ä¸­æ–‡æœç´¢æ¬¢è¿Intro to Gear Protocol5 åˆ†é’Ÿå¿«é€Ÿå…¥é—¨Gear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSå¼€å§‹Keyringè®¡ç®— Gasä¸Šä¼ ç¨‹åºPay Program rentæäº¤ä»£ç å‘é€æ¶ˆæ¯è¯»å–çŠ¶æ€Voucherså…ƒæ•°æ® ä¸ Type CreationMailboxEventsç¤ºä¾‹Gear-JS toolsåˆ›å»º Gear AppMeta CLIReact-hooksGeneral topicsGear-based NetworksGear-JSGear-JS toolsMeta CLIæœ¬é¡µæ€»è§ˆGear Meta CLI
CLI å·¥å…·ï¼Œå¯¹å‚æ•°è¿›è¡Œç¼–ç /è§£ç ï¼Œå¹¶å¯¹ .meta.wasm æ–‡ä»¶è¿›è¡Œå¤„ç†ã€‚
å®‰è£…â€‹
npm install -g @gear-js/gear-meta
æˆ–
yarn global add @gear-js/gear-meta
ç”¨æ³•â€‹
å®Œæ•´çš„å‘½ä»¤åˆ—è¡¨â€‹
gear-meta --help
å¯ç”¨å‘½ä»¤â€‹
decode - è§£æ 16 è¿›åˆ¶çš„ payload
encode - å°† payload ç¼–ç ä¸º 16 è¿›åˆ¶æ•°æ®
meta - ä».meta.wasm æ˜¾ç¤º metadata
type - æ˜¾ç¤ºæ¥è‡ª .meta.wasm çš„ç‰¹å®šç±»å‹çš„ç±»å‹ç»“æ„
ä½ å¯ä»¥è¿è¡Œè¿™äº›å‘½ä»¤çš„ç®€å†™æ¨¡å¼ï¼Œç³»ç»Ÿä¼šæç¤ºä½ è¾“å…¥å¿…è¦çš„æ•°æ®ã€‚æˆ–è€…ä½ å¯ä»¥é€šè¿‡é€‰é¡¹æŒ‡å®šæ•°æ®ï¼š
-t, --type - Type to encode or decode the payload. If it is not specified you can select it later
-m, --meta - _ .meta.wasm æ–‡ä»¶çš„è·¯å¾„_
-o --output - è¾“å‡º JSON æ–‡ä»¶ã€‚å¦‚æœå®ƒä¸å­˜åœ¨ï¼Œå°†ä¼šåˆ›å»º
-j --payloadFromJson - å¦‚æœéœ€è¦ä» json ä¸­è·å–æœ‰æ•ˆè½½è·
_
æ‰€æœ‰è¿™äº›é€‰é¡¹éƒ½é€‚ç”¨äº decode "å’Œencodeå‘½ä»¤
-o --output é€‰é¡¹å¯ç”¨äº meta å‘½ä»¤
-m, --meta é€‰é¡¹å¯ç”¨äº type å‘½ä»¤
ä¾‹å­â€‹
gear-meta encode '{"amount": 8, "currency": "GRT"}' -t init_input -m ./path/to/demo_meta.meta.wasm# Output:  # Result:  # 0x080c475254
gear-meta decode '0x080c475254' -t init_input -m ./path/to/demo_meta.meta.wasm# Output:  # Result:  # { amount: '8', currency: 'GRT' }
gear-meta type handle_input -m ./path/to/demo_meta.meta.wasm# Output:  # TypeName:  MessageIn  # { id: { decimal: 'u64', hex: 'Bytes' } }
gear-meta meta ./path/to/demo_meta.meta.wasm# Output:  # Result:  # {  #   types: '0x50000824646...0000023800',  #   init_input: 'MessageInitIn',  #   init_output: 'MessageInitOut',  #   async_init_input: 'MessageInitAsyncIn',  #   async_init_output: 'MessageInitAsyncOut',  #   handle_input: 'MessageIn',  #   handle_output: 'MessageOut',  #   async_handle_input: 'MessageHandleAsyncIn',  #   async_handle_output: 'MessageHandleAsyncOut',  #   title: 'Example program with metadata',  #   meta_state_input: 'Option<Id>',  #   meta_state_output: 'Vec<Wallet>',  #   meta_state: undefined  # }ç¼–è¾‘æ­¤é¡µä¸Šä¸€é¡µåˆ›å»º Gear Appä¸‹ä¸€é¡µReact-hookså®‰è£…ç”¨æ³•å®Œæ•´çš„å‘½ä»¤åˆ—è¡¨å¯ç”¨å‘½ä»¤ä¾‹å­








å¿«é€Ÿå…¥é—¨ | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())è·³åˆ°ä¸»è¦å†…å®¹Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeä¸‹ä¸€é¡µUnstable ğŸš§ä¸‹ä¸€é¡µç®€ä½“ä¸­æ–‡Englishç®€ä½“ä¸­æ–‡æœç´¢æ¬¢è¿Intro to Gear Protocol5 åˆ†é’Ÿå¿«é€Ÿå…¥é—¨Gear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based Networks5 åˆ†é’Ÿå¿«é€Ÿå…¥é—¨æœ¬é¡µæ€»è§ˆ5 åˆ†é’Ÿå…¥é—¨
æœ¬æŒ‡å—æä¾›äº†åœ¨ Gear ç½‘ç»œä¸Šè¿è¡Œæ™ºèƒ½åˆçº¦çš„ä¸€èˆ¬æ¦‚è¿°ã€‚å®ƒæŒ‡å¯¼æ‚¨å¦‚ä½•ç¼–å†™æ™ºèƒ½åˆçº¦ï¼Œå°†å…¶ç¼–è¯‘ä¸º Wasmï¼Œå¹¶éƒ¨ç½²åˆ° Gear ç½‘ç»œã€‚
åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ä¸€ä¸ªæ¨¡æ‹ŸçœŸå® Gear å»ä¸­å¿ƒåŒ–ç½‘ç»œçš„æ¼”ç¤ºç¯å¢ƒã€‚
å‰æœŸå‡†å¤‡â€‹

ä¸ºäº†æ–¹ä¾¿èµ·è§ï¼Œå»ºè®®æ‚¨ä¸ºæ‰€æœ‰ä¸ Gear ç›¸å…³çš„å†…å®¹åˆ›å»ºä¸€ä¸ªä¸“ç”¨ç›®å½•ã€‚æœ¬æ–‡çš„å…¶ä½™éƒ¨åˆ†å°†å‡è®¾æ‚¨ä½¿ç”¨çš„æ˜¯æ‰€å»ºè®®çš„è·¯å¾„ã€‚è¾“å…¥ä»¥ä¸‹å‘½ä»¤æ¥åœ¨ Home ç›®å½•åˆ›å»ºä¸€ä¸ªä¸“ç”¨æ–‡ä»¶å¤¹å¹¶è·³è½¬åˆ°æ–‡ä»¶å¤¹ä¸­ï¼š

mkdir -p ~/gearcd ~/gear

ç¡®ä¿æ‚¨å·²ç»å®‰è£…äº†åœ¨ Rust ä¸­æ„å»ºæ™ºèƒ½åˆçº¦æ‰€éœ€çš„æ‰€æœ‰å·¥å…·ã€‚æˆ‘ä»¬å°†ä½¿ç”¨ Rustup æ¥å®‰è£… Rust ç¼–è¯‘å™¨ã€‚

curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

ç°åœ¨ï¼Œè®©æˆ‘ä»¬ä¸º rustup å®‰è£…ä¸€ä¸ª nightly ç‰ˆæœ¬ï¼Œå› ä¸º Gear ä½¿ç”¨äº† ä¸€äº› rustup æä¾›çš„æœ€æ–°åŠŸèƒ½ã€‚

rustup updaterustup update nightly

æˆ‘ä»¬éœ€è¦æŠŠ Rust æ™ºèƒ½åˆçº¦ç¼–è¯‘ä¸º Wasmï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦ä¸€ä¸ª Wasm ç¼–è¯‘å™¨ã€‚è®©æˆ‘ä»¬å°† Wasm ç¼–è¯‘å™¨æ·»åŠ åˆ°å·¥å…·é“¾ä¸­ã€‚

rustup target add wasm32-unknown-unknown --toolchain nightly
æ³¨æ„ å¦‚æœä½ ä½¿ç”¨ Windowsï¼Œè¯·ä¸‹è½½å¹¶å®‰è£… Build Tools for Visual Studioã€‚
åˆ›å»ºä½ çš„ç¬¬ä¸€ä¸ª Gear æ™ºèƒ½åˆçº¦â€‹

ç°åœ¨è®©æˆ‘ä»¬åœ¨ gear æ–‡ä»¶å¤¹å†…ï¼Œåˆ›å»º contracts æ–‡ä»¶å¤¹ï¼Œç„¶åé€šè¿‡ cd åˆ‡æ¢è¿›æ–‡ä»¶å¤¹

mkdir -p ~/gear/contractscd ~/gear/contracts

ä¸‹ä¸€æ­¥å°†æ˜¯ä¸ºåˆçº¦å»ºç«‹ä¸€ä¸ª Rust åº“ã€‚

cargo new first-gear-app --lib
gear/contracts ç›®å½•æ ‘åº”è¯¥æ˜¯è¿™æ ·çš„ï¼š
â””â”€â”€ first-gear-app    â”œâ”€â”€ Cargo.toml    â””â”€â”€ src        â””â”€â”€ lib.rs

ç°åœ¨å¼€å§‹å†™ä¸€äº›ä»£ç ã€‚ç”¨ä½ å–œæ¬¢çš„ç¼–è¾‘å™¨æ‰“å¼€ first-gear-appï¼Œæˆ‘ä»¬ä½¿ç”¨VS Codeã€‚

code ~/gear/contracts/first-gear-app

åˆ›å»º build.rs æ–‡ä»¶ï¼Œå¹¶ç²˜è´´ä»¥ä¸‹ä»£ç ï¼š

fn main() {    gear_wasm_builder::build();}
åŒæ—¶é…ç½®Cargo.tomlï¼Œå¯ä»¥ä½¿åˆçº¦æ­£ç¡®åœ°åˆ›å»ºã€‚
[package]name = "first-gear-app"version = "0.1.0"authors = ["Your Name"]edition = "2021"license = "GPL-3.0"[dependencies]gstd = { git = "https://github.com/gear-tech/gear.git", tag = "v1.0.2", features = ["debug"] }[build-dependencies]gear-wasm-builder = { git = "https://github.com/gear-tech/gear.git", tag = "v1.0.2" }[dev-dependencies]gtest = { git = "https://github.com/gear-tech/gear.git", tag = "v1.0.2" }

ç”¨æˆ‘ä»¬çš„ç¬¬ä¸€ä¸ªæ™ºèƒ½åˆçº¦çš„ä»£ç æ›¿æ¢ lib.rsã€‚åœ¨ç¼–è¾‘å™¨ä¸­æ‰“å¼€ src/lib.rs å¹¶ç²˜è´´ä»¥ä¸‹ä»£ç ï¼š

#![no_std]use gstd::{debug, msg, prelude::*};static mut MESSAGE_LOG: Vec<String> = vec![];#[no_mangle]unsafe extern "C" fn handle() {    let new_msg = String::from_utf8(msg::load_bytes().expect("Unable to load bytes"))        .expect("Invalid message");    if new_msg == "PING" {        msg::reply_bytes("PONG", 0).expect("Error in sending reply");    }    MESSAGE_LOG.push(new_msg);    debug!("{:?} total message(s) stored: ", MESSAGE_LOG.len());}
è¿™ä¸ªåˆçº¦å‘é€äº†PINGæ¶ˆæ¯ï¼Œä¼šæ”¶åˆ°PONGæ¶ˆæ¯ä½œä¸ºå›åº”ã€‚

ç„¶åï¼Œç¼–è¯‘åˆçº¦ä»£ç 

cd ~/gear/contracts/first-gear-app/cargo build --release
å¦‚æœä¸€åˆ‡é¡ºåˆ©ï¼Œå·¥ä½œç›®å½•åº”è¯¥æœ‰ä¸€ä¸ª target ç›®å½•ï¼Œå¦‚ä¸‹æ‰€ç¤ºçš„ï¼š
target    â”œâ”€â”€ CACHEDIR.TAG    â”œâ”€â”€ release    â”‚Â Â  â”œâ”€â”€ ...    â””â”€â”€ wasm32-unknown-unknown        â”œâ”€â”€ CACHEDIR.TAG        â””â”€â”€ release            â”œâ”€â”€ build            â”‚Â Â  â””â”€â”€ ...            â”œâ”€â”€ deps            â”‚Â Â  â””â”€â”€ ...            â”œâ”€â”€ examples            â”œâ”€â”€ incremental            â”œâ”€â”€ first_gear_app.d            â””â”€â”€ first_gear_app.wasm <---- this is our .wasm file
æˆ‘ä»¬éœ€è¦çš„æ˜¯ target/wasm32-unknown-unknown/release ç›®å½•å†…çš„ first_gear_app.wasm æ–‡ä»¶ã€‚ç°åœ¨çŸ¥é“å®ƒåœ¨å“ªé‡Œäº†ï¼Œè®©æˆ‘ä»¬è¿›å…¥ä¸‹ä¸€æ­¥ã€‚
åœ¨æµ‹è¯•ç½‘ä¸Šéƒ¨ç½²ä½ çš„ç¬¬ä¸€ä¸ªåˆçº¦â€‹
Gear provides a demo environment that emulates the real Gear decentralized network, available in idea.gear-tech.io.
Gear æä¾›äº†ä¸€ä¸ªæ¨¡æ‹ŸçœŸå® Gear å»ä¸­å¿ƒåŒ–ç½‘ç»œçš„ demo ç¯å¢ƒï¼Œå¯ä»¥é€šè¿‡ idea.gear-tech.io è®¿é—®ã€‚
åˆ›å»ºè´¦æˆ·â€‹


é€šè¿‡ https://polkadot.js.org/extension/ ä¸ºæ‚¨çš„æµè§ˆå™¨ä¸‹è½½ Polkadot æ‰©å±•æ’ä»¶ã€‚è¿™ä¸ªæ‰©å±•æ’ä»¶å¯ä»¥ç®¡ç†è´¦æˆ·å¹¶å…è®¸ç”¨è¿™äº›è´¦æˆ·ç­¾åäº¤æ˜“ã€‚å®ƒæ˜¯ä¸€ä¸ªå®‰å…¨çš„å·¥å…·ï¼Œå…è®¸å°†ä½ çš„è´¦æˆ·æ³¨å…¥åˆ°ä»»ä½•åŸºäº Substrate çš„åº”ç”¨ç¨‹åºã€‚å®ƒä¸æ‰§è¡Œé’±åŒ…åŠŸèƒ½ï¼Œä¾‹å¦‚ï¼Œå‘é€èµ„é‡‘ã€‚


ä¸‹è½½å®Œæˆåï¼Œç‚¹å‡» '+' æ¥åˆ›å»ºæ–°çš„è´¦æˆ·ï¼š




ç¡®ä¿ä½ å®‰å…¨çš„ä¿å­˜äº† 12 ä¸ªå•è¯çš„åŠ©è®°è¯ã€‚



é€‰æ‹©åˆé€‚çš„ç½‘ç»œ - é€‰æ‹© "Allow to use on any chain"ã€‚ä¸ºè¿™ä¸ªè´¦æˆ·æä¾›ä»»ä½•åç§°å’Œå¯†ç ï¼Œå¹¶ç‚¹å‡»"Add the account with the generated seed" æ¥å®Œæˆè´¦æˆ·æ³¨å†Œã€‚



å‰å¾€ idea.gear-tech.ioã€‚ç³»ç»Ÿå°†æç¤ºä½ æˆäºˆ Gear Tech åº”ç”¨ç¨‹åºå¯¹ä½ è´¦æˆ·çš„è®¿é—®æƒï¼Œç‚¹å‡» "Yes, allow this application access" ã€‚




ç‚¹å‡»å³ä¸Šæ–¹çš„ Connect æŒ‰é’®ï¼Œé€‰æ‹©ä¸€ä¸ªè´¦æˆ·ï¼Œè¿æ¥åˆ° Gear Techã€‚


æ ¹æ® Actor æ¨¡å‹ï¼Œæ™ºèƒ½åˆçº¦é€šè¿‡æ¶ˆæ¯ä¸Šä¼ åˆ°ç½‘ç»œã€‚Gear èŠ‚ç‚¹åœ¨æ¶ˆæ¯å¤„ç†è¿‡ç¨‹ä¸­ä¼šæ”¶å–ä¸€å®š  çš„ gasã€‚è´¦æˆ·éœ€è¦æœ‰è¶³å¤Ÿçš„èµ„é‡‘æ¥ä¸Šä¼ æ™ºèƒ½åˆçº¦åˆ°TestNetã€‚ç‚¹å‡» "Get test balance"ã€‚



çª—å£çš„åº•éƒ¨ä¼šå‡ºç°ä¸€ä¸ªå…³äºæˆåŠŸè·å¾—ä½™é¢çš„é€šçŸ¥ã€‚ä½ è¿˜å¯ä»¥åœ¨å³ä¸Šè§’çš„è´¦æˆ·åç§°æ—è¾¹çœ‹åˆ°å½“å‰çš„è´¦æˆ·ä½™é¢ã€‚

ä¸Šä¼ åˆçº¦â€‹

å½“ä½ çš„è´¦æˆ·ä½™é¢è¶³å¤Ÿæ—¶ï¼Œç‚¹å‡» Upload program å¹¶æ‰¾åˆ°æˆ‘ä»¬ä¸Šé¢æåˆ°çš„ .wasm æ–‡ä»¶ã€‚



æŒ‡å®šåˆçº¦åç§°ï¼Œå¹¶è®¾å®š Gas limit ä¸º 20 000 000ï¼Œç„¶åç‚¹å‡» Upload program æŒ‰é’®ã€‚



ç­¾ç½²äº¤æ˜“ï¼Œå°†åˆçº¦ä¸Šä¼ åˆ° Gear ç½‘ç»œã€‚æ­¤å¤–ï¼Œç­¾ç½²åˆçº¦å¹¶å°†å…ƒæ•°æ®ä¸Šä¼ åˆ° Gear æ¼”ç¤ºç¯å¢ƒï¼Œä»¥ä¾¿å¯ä»¥ä½¿ç”¨è¯¥åˆçº¦ã€‚ä¸ºæ–¹ä¾¿èµ·è§ï¼Œå»ºè®®è®¾ç½®å¤é€‰æ¡† Remember my password for the next 15 minutes ã€‚


å¤‡æ³¨ä¸Šä¼ åï¼Œå¦‚æœåˆçº¦åç§°å‰é¢æœ‰çº¢ç‚¹ï¼Œä»£è¡¨åˆå§‹åŒ–é”™è¯¯ã€‚è¯·å†æ¬¡ä¸Šä¼ åˆçº¦ï¼Œå¹¶æ‰©å¤§ Gas limitï¼Œå¯ä»¥å°è¯•å°†é»˜è®¤å€¼æ‰©å¤§ 10 å€ã€‚

åˆçº¦ä¸Šä¼ åï¼Œå‰å¾€ Recently uploaded programs å¹¶æ‰¾åˆ°ä½ çš„åˆçº¦ã€‚


å‘åˆçº¦å‘é€æ¶ˆæ¯â€‹


ç°åœ¨ï¼Œå°è¯•å‘æ–°ä¸Šä¼ çš„åˆçº¦å‘é€ä¸€æ¡æ¶ˆæ¯ï¼Œçœ‹çœ‹å®ƒæ˜¯å¦‚ä½•å“åº”çš„ï¼ä½¿ç”¨è¿™ä¸ªæŒ‰é’®ï¼š



åœ¨æ‰“å¼€çš„å¯¹è¯æ¡†ä¸­ PING çš„ Payload å­—æ®µä¸­ï¼Œæä¾› 20 000 000 çš„ gasï¼Œç„¶åç‚¹å‡» Send request æŒ‰é’®ã€‚





ç­¾åæ¶ˆæ¯å‘é€äº¤æ˜“ï¼Œå¦‚ä¸Šä¼ åˆçº¦ä¸­çš„æ­¥éª¤ 3 æ‰€ç¤º


æˆåŠŸå¤„ç†æ¶ˆæ¯åï¼Œåˆçº¦ä¼šå‘é€ PONG ä½œä¸ºå“åº”ï¼š




æ›´å¤šå†…å®¹â€‹
é™¤äº†è¿™ç¯‡ "5 åˆ†é’Ÿå…¥é—¨"ï¼Œä½ è¿˜å¯ä»¥å‚è€ƒå¦ä¸€ç¯‡å±•ç¤ºåœ¨ Gear å¹³å°ä¸Šåˆ›å»ºåº”ç”¨ç¨‹åºçš„ç®€å•æ€§å’Œä¾¿åˆ©æ€§çš„æ–‡ç« --åˆå­¦è€…çš„ç¬¬ä¸€ä¸ªæ™ºèƒ½åˆçº¦ã€‚
è¿™ç¯‡æ–‡ç« ä»¥ Voting åº”ç”¨ç¨‹åºä¸ºä¾‹ï¼Œæè¿°äº† Gear æ™ºèƒ½åˆçº¦çš„ç»“æ„ï¼Œå¦‚ä½•ä½¿ç”¨ç¨‹åºçš„è§’è‰²æ¨¡å‹æ¶æ„ï¼Œå¤„ç†æ¶ˆæ¯ï¼Œä»¥åŠå¦‚ä½•å¤„ç†çŠ¶æ€ã€‚
å…³äº Gear ç¼–å†™æ™ºèƒ½åˆçº¦çš„ä¿¡æ¯ä»¥åŠæ™ºèƒ½åˆçº¦å®ç°èƒŒåçš„å…·ä½“å†…å®¹ï¼Œè¯·è®¿é—® æ™ºèƒ½åˆçº¦ã€‚ç¼–è¾‘æ­¤é¡µä¸Šä¸€é¡µçŠ¶æ€è½¬ç§»ä¸‹ä¸€é¡µé…ç½®èŠ‚ç‚¹å‰æœŸå‡†å¤‡åˆ›å»ºä½ çš„ç¬¬ä¸€ä¸ª Gear æ™ºèƒ½åˆçº¦åœ¨æµ‹è¯•ç½‘ä¸Šéƒ¨ç½²ä½ çš„ç¬¬ä¸€ä¸ªåˆçº¦åˆ›å»ºè´¦æˆ·ä¸Šä¼ åˆçº¦å‘åˆçº¦å‘é€æ¶ˆæ¯æ›´å¤šå†…å®¹








é…ç½®æœ¬åœ°èŠ‚ç‚¹ | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())è·³åˆ°ä¸»è¦å†…å®¹Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeä¸‹ä¸€é¡µUnstable ğŸš§ä¸‹ä¸€é¡µç®€ä½“ä¸­æ–‡Englishç®€ä½“ä¸­æ–‡æœç´¢æ¬¢è¿Intro to Gear Protocol5 åˆ†é’Ÿå¿«é€Ÿå…¥é—¨Gear Nodeé…ç½®èŠ‚ç‚¹å°†èŠ‚ç‚¹ç¨‹åºé…ç½®æˆæœåŠ¡èŠ‚ç‚¹ç›‘æ§å¤‡ä»½å’Œæ¢å¤å¼€å‘ç½‘ç»œå¤šèŠ‚ç‚¹æ¨¡å¼å¸¸è§é—®é¢˜å¸¸è§é”™è¯¯Developing Smart ContractsSmart Contract ExamplesGear IDEAGear-JSGeneral topicsGear-based NetworksGear Nodeé…ç½®èŠ‚ç‚¹æœ¬é¡µæ€»è§ˆé…ç½®æœ¬åœ°èŠ‚ç‚¹
ä»‹ç»â€‹
æœ¬æ•™ç¨‹è¦†ç›–äº†å®‰è£…å’Œè¿è¡Œ Gear èŠ‚ç‚¹æ‰€éœ€çš„æ­¥éª¤ã€‚
è¿™é‡Œæœ‰ä¸¤ç§æ–¹å¼æ¥å¼€å§‹è¿è¡Œ Gear èŠ‚ç‚¹ã€‚ç¬¬ä¸€ç§æ–¹å¼ï¼Œä½ å¯ä»¥ä¸‹è½½é¢„ç¼–è¯‘å¥½çš„äºŒè¿›åˆ¶æ–‡ä»¶ï¼Œç›´æ¥è¿è¡Œã€‚ç¬¬äºŒç§æ–¹å¼ï¼Œä½ å¯ä»¥è‡ªè¡Œç¼–è¯‘å’Œé…ç½®ã€‚ä½¿ç”¨å·²ç»å‡†å¤‡å¥½çš„ç¼–è¯‘æ–‡ä»¶æ˜¯æœ€å¿«å’Œæœ€ä¾¿æ·çš„å¼€å§‹æ–¹å¼ï¼Œå› ä¸ºä½ å¯ä»¥è·³è¿‡è¯¸å¦‚å®‰è£… Rustã€å®‰è£…ä¾èµ–å’ŒèŠ‚ç‚¹ç¼–è¯‘çš„è¿‡ç¨‹ã€‚ä»å¦ä¸€æ–¹é¢æ¥è®²ï¼Œå¦‚æœä½ å†³å®šè¦é‡‡ç”¨è‡ªå·±ç¼–è¯‘çš„æ–¹å¼æ¥åˆ›å»ºä½ çš„å¼€å‘èŠ‚ç‚¹ï¼Œé‚£ä¹ˆå®ƒå°†èŠ±è´¹å¤§çº¦ 20 åˆ†é’Ÿæ—¶é—´æˆ–è€…æ›´å¤šï¼Œè¿™ä¸€åˆ‡å–å†³äºä½ çš„æœºå™¨é…ç½®ã€‚
ä¿¡æ¯ç³»ç»Ÿé…ç½®è¦æ±‚â€‹ç”±äºéœ€è¦å¯¹ AVX å’Œ SSE 4.2 çš„æ”¯æŒï¼ŒGear èŠ‚ç‚¹ä¸èƒ½åœ¨ QEMU è™šæ‹Ÿ CPU ä¸Šæ­£å¸¸å·¥ä½œã€‚Gear èŠ‚ç‚¹å¹¶ä¸è¦æ±‚ç‰¹æ®Šçš„ç¡¬ä»¶é…ç½®ï¼Œé™¤äº†å»ºè®®ä½¿ç”¨ SSD ç¡¬ç›˜ã€‚
é‡‡ç”¨é¢„ç¼–è¯‘çš„äºŒè¿›åˆ¶æ–‡ä»¶æ¥å®‰è£…â€‹
ä¾æ®ä½ çš„æ“ä½œç³»ç»Ÿï¼Œä½ éœ€è¦ä¸‹è½½ Gear èŠ‚ç‚¹çš„ nightly build ç‰ˆæœ¬ï¼š
Windows x64MacOS ARMMacOS x64Linux x64Terminal:curl -O https://get.gear.rs/gear-nightly-x86_64-pc-windows-msvc.zipæˆ–Windows x64: gear-nightly-x86_64-pc-windows-msvc.zipTerminal:wget https://get.gear.rs/gear-nightly-aarch64-apple-darwin.tar.xz && \tar xvf gear-nightly-aarch64-apple-darwin.tar.xz && \rm gear-nightly-aarch64-apple-darwin.tar.xzæˆ–macOS M1: gear-nightly-aarch64-apple-darwin.tar.xzTerminal:wget https://get.gear.rs/gear-nightly-x86_64-apple-darwin.tar.xz && \tar xvf gear-nightly-x86_64-apple-darwin.tar.xz && \rm gear-nightly-x86_64-apple-darwin.tar.xzæˆ–macOS Intel x64: gear-nightly-x86_64-apple-darwin.tar.xzTerminal:wget https://get.gear.rs/gear-nightly-x86_64-unknown-linux-gnu.tar.xz && \tar xvf gear-nightly-x86_64-unknown-linux-gnu.tar.xz && \rm gear-nightly-x86_64-unknown-linux-gnu.tar.xzæˆ–Linux x64: gear-nightly-x86_64-unknown-linux-gnu.tar.xz
è‡ªè¡Œç¼–è¯‘ Gear èŠ‚ç‚¹â€‹
è‡ªè¡Œç¼–è¯‘ç‰ˆæœ¬éœ€è¦èŠ±è´¹ä¸€äº›æ—¶é—´ï¼ŒåŒæ—¶éœ€è¦å®‰è£…ä¸€äº›ä¾èµ–ï¼š
å‰æœŸå‡†å¤‡â€‹
Linux ç”¨æˆ·éœ€è¦ä¾ç…§è‡ªå·±çš„å‘è¡Œç‰ˆæœ¬æ¥å®‰è£… GCC å’Œ Clangã€‚
å¦å¤–ï¼Œéœ€è¦å®‰è£…åŒ…å«æ‰€éœ€çš„ wasm-opt å·¥å…·çš„ binaryenå·¥å…·é›†ã€‚
ä¾‹å¦‚åœ¨ Ubuntu ä¸Šä½¿ç”¨å¦‚ä¸‹å‘½ä»¤ï¼š
sudo apt install -y clang build-essential binaryen cmake protobuf-compiler
åœ¨ macOS ä¸Šï¼Œä½ å¯ä»¥é€šè¿‡è¿è¡Œä»¥ä¸‹å‘½ä»¤å¾—åˆ°ç¼–è¯‘å™¨å·¥å…·é›†å’Œbinaryenã€‚
xcode-select --installbrew install binaryen
å®‰è£… Rustâ€‹
å¦‚æœä½ å·²ç»å®‰è£… Rustï¼Œä½ å¯ä»¥è·³è¿‡è¿™ä¸€æ­¥ã€‚
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
ä¹‹åä½ éœ€è¦é‡å¯ä½ çš„ç»ˆç«¯ã€‚
å®‰è£… Wasm Toolchains:â€‹
rustup toolchain add nightlyrustup target add wasm32-unknown-unknown --toolchain nightly
ä¸‹è½½ Gear ä»£ç â€‹
git clone https://github.com/gear-tech/gear.gitcd gear
ç¼–è¯‘â€‹
cargo build -p gear-cli --release
æˆ–
make node-release
å¤‡æ³¨ä½ å°†åœ¨ /gear/target/release/gear æ‰¾åˆ°æœ€ç»ˆçš„ç¼–è¯‘è¾“å‡ºå‰å¾€ï¼šcd target/release
è¿è¡Œ Gear èŠ‚ç‚¹â€‹
ä¿¡æ¯è¿™ä¸€æ­¥åŒæ˜¯å¦æ˜¯ä¸‹è½½çš„é¢„ç¼–è¯‘ç‰ˆæœ¬è¿˜æ˜¯è‡ªå·±ç¼–è¯‘çš„ç‰ˆæœ¬æ— å…³ã€‚åœ¨ gear-node å®‰è£…çš„ç›®å½•è¿è¡Œå¦‚ä¸‹å‘½ä»¤æ¥é“¾æ¥æµ‹è¯•ç½‘ï¼š
./gear
é‡‡ç”¨å¦‚ä¸‹å‘½ä»¤æ¥è¿è¡Œå¼€å‘æ¨¡å¼çš„ Gear èŠ‚ç‚¹ï¼š
./gear --dev
å‘½ä»¤æ ‡è®°å’Œé€‰é¡¹â€‹
gear [flags] [options]
--chain=testnet
é“¾æ¥åˆ° Gear æµ‹è¯•ç½‘ã€‚
--dev
è¿è¡Œå•èŠ‚ç‚¹ Gear å¼€å‘ç½‘ç»œã€‚
purge-chain
åˆ é™¤é€‰å®šé“¾çš„å­˜å‚¨ã€‚éœ€è¦æ˜ç¡®é“¾çš„ç±»å‹ --chain=staging æˆ– --devã€‚
--help
å¸®åŠ©ä¿¡æ¯ã€‚
ç‰¹æ®Šç¯å¢ƒå˜é‡â€‹
è¿è¡Œ Gear èŠ‚ç‚¹æ—¶å¼€å¯åˆçº¦æ—¥å¿—ï¼š
RUST_LOG="gwasm=debug" gear [flags]ç¼–è¾‘æ­¤é¡µä¸Šä¸€é¡µ5 åˆ†é’Ÿå¿«é€Ÿå…¥é—¨ä¸‹ä¸€é¡µå°†èŠ‚ç‚¹ç¨‹åºé…ç½®æˆæœåŠ¡ä»‹ç»ç³»ç»Ÿé…ç½®è¦æ±‚é‡‡ç”¨é¢„ç¼–è¯‘çš„äºŒè¿›åˆ¶æ–‡ä»¶æ¥å®‰è£…è‡ªè¡Œç¼–è¯‘ Gear èŠ‚ç‚¹å‰æœŸå‡†å¤‡å®‰è£… Rustå®‰è£… Wasm Toolchains:ä¸‹è½½ Gear ä»£ç ç¼–è¯‘è¿è¡Œ Gear èŠ‚ç‚¹å‘½ä»¤æ ‡è®°å’Œé€‰é¡¹ç‰¹æ®Šç¯å¢ƒå˜é‡








Getting started | Gear Documentation Portal
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-213824102-2","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")


window.dataLayer=window.dataLayer||[]
!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-54QDWGN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")










<iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54QDWGN" height="0" width="0" style="display:none;visibility:hidden"></iframe>

!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())è·³åˆ°ä¸»è¦å†…å®¹Ready to build on the edge of Web3? Join Vara online hackathon -  Gear upGear WikiDocsVara NetworkGear-tech.ioContributeä¸‹ä¸€é¡µUnstable ğŸš§ä¸‹ä¸€é¡µç®€ä½“ä¸­æ–‡Englishç®€ä½“ä¸­æ–‡æœç´¢æ¬¢è¿Intro to Gear Protocol5 åˆ†é’Ÿå¿«é€Ÿå…¥é—¨Gear NodeDeveloping Smart ContractsSmart Contract ExamplesGear IDEAGear-JSå¼€å§‹Keyringè®¡ç®— Gasä¸Šä¼ ç¨‹åºPay Program rentæäº¤ä»£ç å‘é€æ¶ˆæ¯è¯»å–çŠ¶æ€Voucherså…ƒæ•°æ® ä¸ Type CreationMailboxEventsç¤ºä¾‹Gear-JS toolsGeneral topicsGear-based NetworksGear-JSå¼€å§‹æœ¬é¡µæ€»è§ˆGetting started
Gear-JS APIâ€‹
Gear-JS API æä¾›äº†ä¸€ç»„å®ç”¨ç¨‹åºã€åº“å’Œå·¥å…·ï¼Œä½¿ JavaScript åº”ç”¨ç¨‹åºèƒ½å¤Ÿé€šè¿‡å¯¹ Gear èŠ‚ç‚¹çš„æŸ¥è¯¢ä¸åœ¨ Gear ç½‘ç»œä¸­è¿è¡Œçš„æ™ºèƒ½åˆçº¦è¿›è¡Œäº¤äº’ã€‚
ä»¥ä¸‹éƒ¨åˆ†æè¿°äº†ä½ å¯ä»¥åœ¨ JS åº”ç”¨ç¨‹åºä¸­ä½¿ç”¨çš„å·¥å…·æ¥å®ç°åŸºæœ¬åŠŸèƒ½ï¼Œä¾‹å¦‚ç®¡ç†å¯†é’¥å¯¹ï¼ˆå¸æˆ·ï¼‰ã€è®¡ç®—ç½‘ç»œæ“ä½œæ‰€éœ€çš„gasã€åœ¨ç½‘ç»œä¸­ä¸Šä¼ ç¨‹åºã€å‘ç¨‹åºå‘é€æ¶ˆæ¯ã€è¯»å–ç¨‹åºçš„çŠ¶æ€ã€ ä» mailbox ä¸­è·å–æ¶ˆæ¯ï¼Œä½¿ç”¨å…ƒæ•°æ®ç­‰ç­‰ã€‚ Cookbook éƒ¨åˆ†æä¾›äº†ä¸€äº›æœ‰ç”¨çš„ä»£ç ç‰‡æ®µã€‚
åŸºæœ¬çš„APIæ˜¯åœ¨Substrateå±‚å®ç°çš„ï¼Œå¯¹æ‰€æœ‰åŸºäºSubstrateçš„ç½‘ç»œéƒ½æ˜¯ä¸€æ ·çš„ã€‚Gear-JSçš„APIä»£ç å¯ä»¥åœ¨GitHubä¸Šæ‰¾åˆ°ã€‚å®Œæ•´çš„APIæ¦‚è¿°å¯ä»¥åœ¨[Polkadot æ–‡æ¡£]ï¼ˆhttps://polkadot.js.org/docs/ï¼‰ä¸Šæ‰¾åˆ°ã€‚
å®‰è£…â€‹
npm install @gear-js/api
æˆ–è€…
yarn add @gear-js/api
å¼€å§‹â€‹
ä½¿ç”¨ API è¿æ¥æœ¬åœ°èŠ‚ç‚¹ï¼š
import { GearApi } from '@gear-js/api';const gearApi = await GearApi.create();
æˆ–è€…è¿æ¥ä¸åŒèŠ‚ç‚¹
const gearApi = await GearApi.create({  providerAddress: 'wss://someIP:somePort',});
å¤‡æ³¨ä»¥ä¸‹æ˜¯ä¸Gear RPCèŠ‚ç‚¹å‡ ä¸ªå…¥å£ã€‚è¿æ¥æœ¬åœ°èŠ‚ç‚¹ï¼šws://127.0.0.1:9944è¿æ¥æµ‹è¯•èŠ‚ç‚¹ï¼šwss://rpc-node.gear-tech.io:443
è·å–èŠ‚ç‚¹ä¿¡æ¯ï¼š
const chain = await gearApi.chain();const nodeName = await gearApi.nodeName();const nodeVersion = await gearApi.nodeVersion();const genesis = gearApi.genesisHash.toHex();
ä¾‹å­â€‹
è¿™ä¸ªç®€å•çš„ä¾‹å­æè¿°äº†å¦‚ä½•è®¢é˜…ä¸€ä¸ªæ–°çš„åŒºå—å¹¶è·å¾—é“¾çš„åŸºæœ¬ä¿¡æ¯ï¼š
async function connect() {  const gearApi = await GearApi.create();  const [chain, nodeName, nodeVersion] = await Promise.all([    gearApi.chain(),    gearApi.nodeName(),    gearApi.nodeVersion(),  ]);  console.log(    `You are connected to chain ${chain} using ${nodeName} v${nodeVersion}`,  );  const unsub = await gearApi.gearEvents.subscribeToNewBlocks((header) => {    console.log(      `New block with number: ${header.number.toNumber()} and hash: ${header.hash.toHex()}`,    );  });}connect().catch(console.error);ç¼–è¾‘æ­¤é¡µä¸Šä¸€é¡µSS58 åœ°å€æ ¼å¼ä¸‹ä¸€é¡µKeyringGear-JS APIå®‰è£…å¼€å§‹ä¾‹å­



