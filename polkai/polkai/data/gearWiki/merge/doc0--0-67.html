{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"Welcome to Gear’s documentation portal. This is the central source of information for everyone who is looking for general information about Gear. Here you will find guides and developer's documentation that will enable you to dive deeper into developing smart contracts on the Gear Protocol.","lang":"en","canonicalLink":"https://wiki.gear-tech.io/docs/","tags":[],"image":"https://wiki.gear-tech.io/img/ogimage.jpg","videos":[],"links":[{"text":"Vara Network","href":"https://vara-network.io/"},{"text":"GitHub","href":"https://github.com/gear-tech"},{"text":"Discord server","href":"https://discord.gg/7BQznC9uD9"},{"text":"@gear_techs","href":"https://twitter.com/gear_techs"},{"text":"@gear_tech","href":"https://t.me/gear_tech"},{"text":"Medium","href":"https://medium.com/@gear_techs"}],"text":"Welcome to Gear’s documentation portal. This is the central source of information for everyone who is looking for general information about Gear. Here you will find guides and developer's documentation that will enable you to dive deeper into developing smart contracts on the Gear Protocol.\n\nOur Wiki outlines foundational information required, general technology overviews and key advantages of Gear’s technology, including how to implement and run your smart contracts and how to get started with the Gear node setup, while also providing full API details and examples.\n\nAll code, libraries, and tools are available on GitHub. Feel free to use the tools and libraries, log issues as you find them, or create pull requests for your bug-bears or features.\n\nAs our project is developing and growing, contributions are more than welcome!\n\nThe Gear Protocol is a Substrate-based smart-contract platform that enables anyone to develop and run a dApp in a matter of minutes. The Gear Protocol is the most developer-friendly way to implement smart contracts with arbitrary logic and of any complexity. Gear smart-contracts run as WebAssembly programs so they can be compiled from many popular programming languages, such as Rust, C, C++ and many more.\n\nThe protocol ensures very minimal, intuitive and sufficient APIs for implementing programs and running them on multiple networks without having to rewrite them. From a technological point of view, the Gear Protocol is distinguished by fundamentally new features that enable you to create asynchronous programs with a completely new and previously unattainable user experience, namely - the Actor model for communication, the persistent memory concept and WebAssembly execution environment. The protocol dictates what actors should look like as communicating entities.\n\nThe Gear Protocol will assist with the transition to mass use of Web3 technologies by enabling the running of innovative dApps, microservices, middleware and open APIs.\n\nThe Gear Protocol provides the most cost-effective way to run smart contracts. Powered by the Gear Protocol, Gear Networks can act as standalone L1 networks, as well as become a parachain in the Polkadot and Kusama ecosystem too. By deploying on Gear Protocol, developers can fully leverage the benefits offered by Gear.\n\nVara Network is the first stand-alone layer-1 decentralized network built and running on top of Gear Protocol.\n\nInstructions and other development-focused conversations are found on our GitHub.\n\nGeneral information and non-technical conversation are found on our Discord server.\n\nFollow us on Twitter for regular updates: @gear_techs\n\nGet smart with our regular articles on Medium."}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"lang":"zh","canonicalLink":"https://wiki.gear-tech.io/zh-cn/","tags":[],"image":"https://wiki.gear-tech.io/zh-cn/img/ogimage.jpg","videos":[],"links":[],"text":""}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"Gear IDEA 是一个方便的工具，其目的是让用户熟悉 Gear 平台。它为智能合约开发者提供了最简单、最快捷的方式来编写、编译、测试并直接通过浏览器将智能合约上传到测试网络，而无需额外的配置。","lang":"zh","canonicalLink":"https://wiki.gear-tech.io/zh-cn/docs/idea/idea-overview","tags":[],"image":"https://wiki.gear-tech.io/zh-cn/img/ogimage.jpg","videos":[],"links":[],"text":""}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"Substrate 是一个模块化框架，通过组合定制或预先构建的组件，可以创建独特的区块链。","lang":"zh","canonicalLink":"https://wiki.gear-tech.io/zh-cn/docs/gear/technology/substrate","tags":[],"image":"https://wiki.gear-tech.io/zh-cn/img/ogimage.jpg","videos":[],"links":[],"text":""}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"Substrate is a modular framework that enables the creation of custom-built unique blockchains by composing custom or pre-built components with networking, consensus mechanism, core functionality, security and governance features out of the box.","lang":"en","canonicalLink":"https://wiki.gear-tech.io/docs/gear/technology/substrate","tags":[],"image":"https://wiki.gear-tech.io/img/ogimage.jpg","videos":[],"links":[{"text":"Substrate Documentation","href":"https://substrate.dev/docs/en/"}],"text":"Substrate is a modular framework that enables the creation of custom-built unique blockchains by composing custom or pre-built components with networking, consensus mechanism, core functionality, security and governance features out of the box.\n\nUsing a Substrate framework, the creation of different blockchains for specific applications is simplified. Substrate provides extensive functionality out-of-the-box and allows developers to focus on creating a custom engine on top of the protocol. This covers the most desired requirements for enterprise-ready decentralized projects.\n\nIt is an important component of the Polkadot network and it allows every team creating a new blockchain not to waste efforts for implementing the code for networking, consensus and other essential components from scratch. Refer to the Substrate Documentation for more details.\n\nPolkadot is a next-generation Layer-0 blockchain protocol intended to unite multiple purpose-built blockchains, allowing them to operate seamlessly together at scale. The critical aspect of the Polkadot network is its ability to route arbitrary messages between chains. These messages enable negotiation channels between two parachains and allow sending asynchronous messages through it.\n\nIt's easy to understand the functions of Substrate by its name. The main Substrate features are the following:\n\nSubstrate enables the Gear team to significantly reduce development time and focus on developing the main Gear Protocol components. Rust guarantees security and high performance.\n\nGear's unique asynchronous messaging architecture enables efficient communication between networks built on Substrate technology. This seamless integration contributes to interoperability for improved network functionality and participation.\n\nBut even with Substrate, launching a new blockchain remains relatively expensive and time consuming. But the Gear Protocol allows dApp developers to focus on their projects rather than building and operating an entirely new blockchain from scratch."}

{"title":"Сonfiguring a node as a Linux service","softTitle":"Сonfiguring a node as a Linux service","date":null,"author":[],"publisher":null,"copyright":null,"description":"Prerequisites","lang":"en","canonicalLink":"https://wiki.gear-tech.io/docs/node/node-as-service","tags":[],"image":"https://wiki.gear-tech.io/img/ogimage.jpg","videos":[],"links":[{"text":"See more","href":"/docs/node/setting-up#install-with-pre-build-binary"}],"text":"You need to download or compile the gear executable file for your OS. See more\n\nCopy the gear executable to the /usr/bin directory:\n\nTo run the Gear node as one of the Linux services, you need to configure the systemd file:\n\nThat’s it. We can now start the service.\n\nAutomatically get it to start on boot:\n\nHow to check status of gear-node service?\n\nYou may see the service logs by running the following command:\n\nUse navigation keys to browse the logs and  key to exit.\n\nYou may see the last 50 lines of logs by adding -n 50 parameter:\n\nAdd -f parameter to see the last lines of logs in continuous mode (press Ctrl+C to exit):\n\nAfter the node has been running for a while, you may need to update it to the latest version.\n\nYou just need to replace the node executable (gear) with the latest version and restart the execution. For example, if your Linux executable is located at /usr/bin/gear (as we've configured above) you are to run:\n\nIf you no longer need to run the node, you can completely purge it from the disk.\n\nYou are to remove the node's storage, the service configuration, and the executable itself:"}

{"title":"Sending Gear node telemetry","softTitle":"Sending Gear node telemetry","date":null,"author":[],"publisher":null,"copyright":null,"description":"The health of each Gear node and the entire network needs to be monitored to ensure truly decentralized and robust operations. This includes the various block production metrics as well as node uptime which is vital in PoS networks.","lang":"en","canonicalLink":"https://wiki.gear-tech.io/docs/node/telemetry","tags":[],"image":"https://wiki.gear-tech.io/img/ogimage.jpg","videos":[],"links":[{"text":"https://telemetry.rs","href":"https://telemetry.rs"},{"text":"Substrate docs","href":"https://docs.substrate.io/maintain/monitor/"}],"text":"The health of each Gear node and the entire network needs to be monitored to ensure truly decentralized and robust operations. This includes the various block production metrics as well as node uptime which is vital in PoS networks.\n\nAs any other Substrate based nodes, Gear node can be connected to an arbitrary telemetry backend using the --telemetry-url.\n\nTo start sending telemetry messages to the arbitrary telemetry server instance, one needs to specify an additional key during node run that will enable sending telemetry to specified http address.\n\nIf you want to participate and share your telemetry, run your node with the flag (we assume the executable is in /usr/bin directory):\n\nAlso, you can provide your node name using the --name flag:\n\nFor example, to start a node with telemetry, run the command:\n\nYou can send more information (e.g., the validator address) by increasing the verbosity level:\n\nTo check telemetry for currently running nodes, visit the web address: https://telemetry.rs.\n\nYou can find some additional information about monitoring in the Substrate docs."}

{"title":"Running Gear node in Dev Net mode","softTitle":"Running Gear node in Dev Net mode","date":null,"author":[],"publisher":null,"copyright":null,"description":"Dev net is helpful for the development and debugging of your smart contracts. You can upload your program directly to a local node, send messages to a program and validate the program's logic.","lang":"en","canonicalLink":"https://wiki.gear-tech.io/docs/node/dev-net","tags":[],"image":"https://wiki.gear-tech.io/img/ogimage.jpg","videos":[],"links":[{"text":"setting-up","href":"/docs/node/setting-up"},{"text":"https://idea.gear-tech.io/","href":"https://idea.gear-tech.io/"}],"text":"Dev net is helpful for the development and debugging of your smart contracts. You can upload your program directly to a local node, send messages to a program and validate the program's logic.\n\nTo run the Gear node in a dev net mode:\n\nCompile or download nightly build for your operating system as described in setting-up.\n\nRun the node in dev mode (we assume the executable is in /usr/bin directory):\n\nFollow https://idea.gear-tech.io/ and connect to a local dev node. Click network selection via the left top button, choose Development -> Local node, and click the Switch button. Use the Idea portal for sending messages, reading the program's state, etc."}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"Can I run the Gear node now?","lang":"en","canonicalLink":"https://wiki.gear-tech.io/docs/node/node-faq","tags":[],"image":"https://wiki.gear-tech.io/img/ogimage.jpg","videos":[],"links":[{"text":"Setting Up","href":"/docs/node/setting-up"},{"text":"System Requirements","href":"/docs/node/setting-up#system-requirements"},{"text":"Troubleshooting","href":"/docs/node/troubleshooting"},{"text":"Gear node as a service","href":"/docs/node/node-as-service"},{"text":"https://community.hetzner.com/tutorials/block-outgoing-traffic-to-private-networks","href":"https://community.hetzner.com/tutorials/block-outgoing-traffic-to-private-networks"},{"text":"Update","href":"/docs/node/node-as-service#update-the-node-with-the-new-version"},{"text":"Checking logs","href":"/docs/node/node-as-service#checking-logs"},{"text":"https://telemetry.rs","href":"https://telemetry.rs"}],"text":"Yes, follow the instructions from this article on how to set up and run Gear node under MacOS, Linux and Windows:\n\nSetting Up\n\nThere are no special hardware requirements except SSD for running Gear node connected to a test net or in a dev net mode. For nodes in a production network, the hardware requirements will be provided further.\n\nPlease refer to the System Requirements to see the actual hardware requirements.\n\nPlease refer to the Troubleshooting section to find typical errors and solutions.\n\nRunning a node in a production network will be incentivized. There are no regular rewards for running nodes in a test net, but participation in community events is also incentivized. Stay tuned.\n\nNot at the moment. Stay tuned.\n\nThat's all at the moment, but stay tuned for future updates.\n\nThe solution is to configure the Gear node as a service.\n\nThis should be resolved by adding --no-private-ipv4 argument when running the node. If for some reason, that argument doesn't solve the issue for you, then you can deny egress traffic to:\n\nFor example you can use this manual: https://community.hetzner.com/tutorials/block-outgoing-traffic-to-private-networks\n\nYou just need to replace the node executable (gear) with the latest version and restart the execution. For example, if your Linux executable is located at /usr/bin you are to run:\n\nUpdate the node binary to the latest version.\n\nUse one of the supported flags when running the node:\n\nSee the Checking logs section for details.\n\nThe full node syncing time may be calculated using the info from the log:\n\nFor example, let's calculate the syncing time from the following log record:\n\nYes, it is visible on the telemetry portal - https://telemetry.rs. It will be gray until the block height becomes up to date.\n\nNo, not at the moment.\n\nThere is no such command."}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"Gear nodes charge gas fees for all network operations, whether that be executing a program’s code or processing a message. This gas is paid for by the initiator of these actions.","lang":"en","canonicalLink":"https://wiki.gear-tech.io/docs/api/calculate-gas","tags":[],"image":"https://wiki.gear-tech.io/img/ogimage.jpg","videos":[],"links":[],"text":"Gear nodes charge gas fees for all network operations, whether that be executing a program’s code or processing a message. This gas is paid for by the initiator of these actions.\n\nThey guarantee successful message processing and to avoid errors like Gaslimit exceeded, you can simulate the execution in advance to calculate the exact amount of gas that will be consumed.\n\nTo find out the minimum gas amount required to send extrinsic, use api.program.calculateGas.[method]. Depending on the conditions, you can calculate gas for initializing a program or processing a message in handle() or reply()."}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"To pay program rent, use the following JavaScript code:","lang":"en","canonicalLink":"https://wiki.gear-tech.io/docs/api/program-rent","tags":[],"image":"https://wiki.gear-tech.io/img/ogimage.jpg","videos":[],"links":[],"text":"To pay program rent, use the following JavaScript code:\n\nYou can calculate the current rent price using the following code:\n\nIf a program was paused and its pages removed from storage, you can restore it using the api.program.resumeSession methods:\n\n* init: Start a new session to resume the program.\n\nHere's how you can resume a paused program:"}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"If you need to load the program code into the chain without initialization use GearApi.code.upload method to create upload_code extrinsic:","lang":"en","canonicalLink":"https://wiki.gear-tech.io/docs/api/submit-code","tags":[],"image":"https://wiki.gear-tech.io/img/ogimage.jpg","videos":[],"links":[],"text":"If you need to load the program code into the chain without initialization use GearApi.code.upload method to create upload_code extrinsic:"}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"Welcome to Gear’s documentation portal.","lang":"zh","canonicalLink":"https://wiki.gear-tech.io/zh-cn/docs/next/","tags":[],"image":"https://wiki.gear-tech.io/zh-cn/img/ogimage.jpg","videos":[],"links":[],"text":""}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"Vouchers, issued by any actor empower users with gas-free interactions, enabling them to send messages to specific programs seamlessly.","lang":"en","canonicalLink":"https://wiki.gear-tech.io/docs/api/vouchers","tags":[],"image":"https://wiki.gear-tech.io/img/ogimage.jpg","videos":[],"links":[{"text":"Battleship","href":"/docs/examples/Gaming/battleship"}],"text":"Vouchers, issued by any actor empower users with gas-free interactions, enabling them to send messages to specific programs seamlessly.\n\nAn example of using vouchers is shown in the Battleship game. Users without tokens on their balance can make moves by sending messages to a program using a voucher.\n\nUse api.voucher.issue method to issue a new voucher for a user to be used to pay for sending messages to program_id program.\n\nUse api.voucher.exists method to check that the voucher exists for a particular user and program:\n\nTo send message with voucher you can use api.voucher.call method:\n\nSending a reply with issued voucher works similar to sending message with voucher:"}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"The mailbox contains messages from the program that are waiting for user action.","lang":"en","canonicalLink":"https://wiki.gear-tech.io/docs/api/mailbox","tags":[],"image":"https://wiki.gear-tech.io/img/ogimage.jpg","videos":[],"links":[],"text":"The mailbox contains messages from the program that are waiting for user action.\n\nTo claim value from a message in the mailbox use api.mailbox.claimValue.submit method.\n\nTo read the program's waitlist use api.waitlist.read method."}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"Events are generated for certain operations during execution. The following sections describe events that are part of the default Gear runtime.","lang":"en","canonicalLink":"https://wiki.gear-tech.io/docs/api/events","tags":[],"image":"https://wiki.gear-tech.io/img/ogimage.jpg","videos":[],"links":[],"text":"Events are generated for certain operations during execution. The following sections describe events that are part of the default Gear runtime.\n\nTo subscribe to all events:\n\nSummary: When a user successfully sends a message to a program and it gets added to the Gear message queue.\n\nSummary: When someone has sent a message to the user.\n\nSummary: When a message has been marked as \"read\" and it has been removed from the Mailbox. This event only affects messages, which were already prior inserted into the Mailbox.\n\nSummary: The result of when a message is processed within the block.\n\nSummary: When a message's execution has been delayed and it has been added to the Gear waitlist.\n\nSummary: When a message is ready to continue its execution and has been removed from the Waitlist.\n\nSummary: When a program's code has been altered."}

{"title":"Gear React application template","softTitle":"Gear React application template","date":null,"author":[],"publisher":null,"copyright":null,"description":"Introducing Gear React Application Template: Accelerate Your Decentralized App Development","lang":"en","canonicalLink":"https://wiki.gear-tech.io/docs/api/tooling/create-gear-app","tags":[],"image":"https://wiki.gear-tech.io/img/ogimage.jpg","videos":[],"links":[{"text":"GitHub","href":"https://github.com/gear-foundation/dapps-react-app"}],"text":"Are you looking to swiftly launch your decentralized application (dApp) on Gear-powered blockchains? Look no further! Gear React Application Template, also known as create-gear-app, is a pre-configured application template designed to streamline the development process. With its well-thought-out infrastructure and convenient features, it allows developers to quickly create and deploy their dApps on Gear-powered blockchains.\n\nGear React Application Template can be found on GitHub. This template is packed with a range of benefits and features that make it an ideal choice for developers seeking efficiency and simplicity in their dApp development workflow.\n\nLet's delve into the key features that Gear React Application Template has to offer:\n\nGear API Connections: Integrating your dApp with Gear-powered blockchains is made seamless with pre-configured API connections, saving developers the hassle of manually setting up the necessary connections. By leveraging Gear's powerful infrastructure, developers can easily interact with the blockchain and access essential blockchain functionalities.\n\nLogin Interface: User authentication is a critical aspect of any application, and Gear React Application Template includes a pre-built login interface. This feature enables developers to quickly implement user authentication and securely manage user access to their dApps. With this functionality readily available, developers can focus on building the core features of their dApp without worrying about the authentication process.\n\nGear React-Hooks Support: Gear React Application Template is designed to take advantage of Gear's react-hooks library, providing developers with a smooth and intuitive development experience. The template includes all the necessary environments and configurations to seamlessly integrate react-hooks into your dApp.\n\nBranded UI-Kit: User experience plays a crucial role in the success of any application. Gear React Application Template offers a branded UI-kit that ensures a visually appealing and consistent user interface. The UI-kit is designed to align with Gear's branding guidelines, providing developers with a head start in creating an attractive and professional-looking dApp. This feature allows developers to focus on developing the unique aspects of their application while maintaining a polished and cohesive design.\n\nGear React Application Template is an invaluable resource for various developers in the blockchain space. Whether you are a seasoned blockchain developer or just starting your journey, this template can significantly speed up your dApp development process. It simplifies the integration with Gear-powered blockchains, provides a robust login interface, offers support for Gear react-hooks, and includes a branded UI-kit for a visually appealing application.\n\nFurthermore, Gear React Application Template is particularly beneficial for developers who prioritize efficiency and value a well-structured and standardized development workflow. By leveraging the template's pre-configured infrastructure, developers can save precious time and effort that would otherwise be spent on setting up and integrating the various components required for a blockchain application.\n\nSimply clone this repo to your local folder:"}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"When the program sends a message to the user (e.g., using the msg::send function), this message is placed in the user's mailbox. Actually, the mailbox is a dedicated storage that keeps a message received from a program.","lang":"en","canonicalLink":"https://wiki.gear-tech.io/docs/developing-contracts/mailbox","tags":[],"image":"https://wiki.gear-tech.io/img/ogimage.jpg","videos":[],"links":[{"text":"msg::send","href":"https://docs.gear.rs/gstd/msg/fn.send.html"},{"text":"UserMessageSent","href":"https://docs.gear.rs/pallet_gear/pallet/enum.Event.html#variant.UserMessageSent"},{"text":"msg::reply","href":"https://docs.gear.rs/gstd/msg/fn.reply.html"},{"text":"https://idea.gear-tech.io/mailbox","href":"https://idea.gear-tech.io/mailbox"},{"text":"send_reply","href":"https://docs.gear.rs/pallet_gear/pallet/struct.Pallet.html#method.send_reply"},{"text":"claim_value","href":"https://docs.gear.rs/pallet_gear/pallet/struct.Pallet.html#method.claim_value"}],"text":"When the program sends a message to the user (e.g., using the msg::send function), this message is placed in the user's mailbox. Actually, the mailbox is a dedicated storage that keeps a message received from a program.\n\nThe user can detect a message received by subscribing to the UserMessageSent event. It's important to note that the reply (sent using the msg::reply function) doesn't go to the mailbox, it just generates an event.\n\nWhen using the IDEA website one should go to the https://idea.gear-tech.io/mailbox section.\n\nLet's explore possible user reactions to the mailbox's message.\n\nThe program can send a message to the user and wait for a reply from him. The user can reply using a send_reply extrinsic. The value associated with the message is transferred to the user's account, the message is removed from the mailbox, and the new reply message is added to the message queue.\n\nIf a message in the mailbox has an associated value, the user can claim it using a claim_value extrinsic. Value is transferred to the user's account and the message is removed from the mailbox.\n\nA message is charged for every block in the mailbox within its gas limit. If the message hasn't an explicit gas limit, gas is borrowed from the origin's limit (e.g. an actor that has initiated the execution).\n\nWhen the message's gas runs out, the message is removed from the mailbox, and the associated value transferred back to the message sender."}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"Persistent data of the Gear smart contract is stored in the same way as in a classic program and does not require initialization of the external storage.","lang":"en","canonicalLink":"https://wiki.gear-tech.io/docs/developing-contracts/state","tags":[],"image":"https://wiki.gear-tech.io/img/ogimage.jpg","videos":[],"links":[{"text":"Learn more","href":"/docs/developing-contracts/metadata"}],"text":"Persistent data of the Gear smart contract is stored in the same way as in a classic program and does not require initialization of the external storage.\n\nIf you're programming in Rust or other object-oriented languages, you should be familiar with most types. However, the ActorId type is something new when developing contracts via the Gear Protocol.\n\nTo display the contract state information, the state() function is used. It allows you to instantly read the contract status (for example, contract balance). Reading state is a free function and does not require gas costs.\n\nExample of the returning all wallets defined above:\n\nAdditionally, you can handle incoming payload and return only the necessary part of the state. For example, you can return only the selected wallet:\n\nAdditionally, you can create your own program to read the state. This wrapper will allow you to implement custom functions for the client side, not depending on the main program.\n\nThis has a number of advantages, for example, you will always be able to read the state even if the program changes (as long as the incoming or outgoing types have not changed). Or you are creating a service based on an already existing program and you need some of your own functions to get your own chanks of data from the state.\n\nTo do this, we need to create an independent program and describe the necessary functions inside the metawasm trait. For example:\n\nOr more complex example:\n\nTo build *.meta.wasm, the following build.rs file in the root of your project is required:"}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"To optimize how data is sent and received over the network, Gear uses the parity-scale-codec - a Rust implementation of the SCALE Codec. This codec is used by the Substrate nodes' internal runtime. SCALE is a lightweight format that enables the serialization and deserialization of data. Encoding (and decoding) data using SCALE makes it highly suitable for resource-constrained execution environments like blockchain runtimes and low-power/low-memory devices.","lang":"en","canonicalLink":"https://wiki.gear-tech.io/docs/developing-contracts/codec","tags":[],"image":"https://wiki.gear-tech.io/img/ogimage.jpg","videos":[],"links":[{"text":"parity-scale-codec","href":"https://docs.rs/parity-scale-codec"},{"text":"here","href":"https://github.com/paritytech/parity-scale-codec"},{"text":"scale-info","href":"https://docs.rs/scale-info/"},{"text":"here","href":"https://github.com/paritytech/scale-info"}],"text":"To optimize how data is sent and received over the network, Gear uses the parity-scale-codec - a Rust implementation of the SCALE Codec. This codec is used by the Substrate nodes' internal runtime. SCALE is a lightweight format that enables the serialization and deserialization of data. Encoding (and decoding) data using SCALE makes it highly suitable for resource-constrained execution environments like blockchain runtimes and low-power/low-memory devices.\n\nTo use SCALE codec in your program, you should add it in Cargo.toml:\n\nLearn more about SCALE Codec here.\n\nscale-info is a library to describe Rust types, intended for providing information about the structure of encodable SCALE types.\n\nThe definitions provide third party tools (e.g. a UI client) with information about how they are able to decode types agnostic of language. The interface that uses scale-info for Gear programs is called metadata. It defines incoming and outgoing types for all necessary entry points and allows contracts and the client part to understand each other.\n\nTo use scale-info in your project:\n\nLearn more about scale-info here"}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"Gas reservation is the powerful feature of Gear Protocol that enables the new approach to smart-contract programming and modern use cases.","lang":"en","canonicalLink":"https://wiki.gear-tech.io/docs/developing-contracts/gas-reservation","tags":[],"image":"https://wiki.gear-tech.io/img/ogimage.jpg","videos":[],"links":[{"text":"use cases","href":"/docs/gear/distinctive-features"},{"text":"messages delayed","href":"/docs/developing-contracts/delayed-messages"},{"text":"ReservationId::reserve","href":"https://docs.gear.rs/gstd/struct.ReservationId.html#method.reserve"},{"text":"ReservationId","href":"https://docs.gear.rs/gstd/struct.ReservationId.html"}],"text":"Gas reservation is the powerful feature of Gear Protocol that enables the new approach to smart-contract programming and modern use cases.\n\nBriefly, a program can send a message using gas that was reserved before instead of using gas from the currently processing message.\n\nOne of the key advantage of this feature is an ability of sending messages delayed in time automatically to any actor in the network - a user or another smart contract as well as to itself. In fact, a program is able to execute itself unlimited number of blocks (provided that enough gas for execution is kept available).\n\nA program developer can provide a special function in the program's code which takes some defined amount of gas from the amount available for this program and reserves it. A reservation gets a unique identifier that can be used by a program to get this reserved gas and use it later.\n\nTo reserve the amount of gas for further usage use the ReservationId::reserve function:\n\nYou also have to indicate the block count within which the reserve must be used. Gas reservation is not free: the reservation for one block costs some gas. The reserve function returns ReservationId, which one can use for sending a message with that gas. To send a message using the reserved gas:\n\nIf gas is not needed within the time specified during the reservation, it can be unreserved and the gas will be returned to the user who made the reservation.\n\nPrograms can have different executions, change state and evaluate somehow, but when it is necessary, a program can send a message with this reserved gas instead of using its own gas.\n\nFor example, let's consider the game that works completely on-chain. The players are smart contracts that compete with each other by implementing various playing strategies. Usually, in these types of games, there is a master contract that starts the game and controls the move order between the players.\n\nTo start the game, someone sends a message to the contract. The gas attached to this message is spent on the players' contracts, which in turn spend gas on their execution. Since the game can last quite a lot of rounds, the attached gas may not be enough to complete the game. You can send a message asking the program to continue the game, or you can use the gas reservation and make a fully automatic play.\n\nUsing gas reservation the contract will be able to hold the game without interruption."}

{"title":"Delayed messages for smart contracts automation","softTitle":"Delayed messages for smart contracts automation","date":null,"author":[],"publisher":null,"copyright":null,"description":"The usual way that smart contracts on other blockchains continue to function is by relying on external, centralized resources. This means that the code of these contracts will not run and make changes to the blockchain's state until it is triggered by an on-chain transaction.","lang":"en","canonicalLink":"https://wiki.gear-tech.io/docs/developing-contracts/delayed-messages","tags":[],"image":"https://wiki.gear-tech.io/img/ogimage.jpg","videos":[],"links":[{"text":"gas reservation","href":"/docs/developing-contracts/gas-reservation"},{"text":"msg::send_delayed","href":"https://docs.gear.rs/gstd/msg/fn.send_delayed.html"},{"text":"msg::send_delayed_from_reservation","href":"https://docs.gear.rs/gstd/msg/fn.send_delayed_from_reservation.html"}],"text":"The usual way that smart contracts on other blockchains continue to function is by relying on external, centralized resources. This means that the code of these contracts will not run and make changes to the blockchain's state until it is triggered by an on-chain transaction.\n\nThe external transaction serves as a \"poke\" to activate the smart contract and initiate its logic. For instance, we can start an auction by sending a message to the auction contract. When the auction time has passed, the contract will need to process the result of the auction. However, this will not happen until someone sends the appropriate message to the contract to trigger this action.\n\nGear Protocol solves this issue by introducing delayed messaging functionality. The smart contracts in Gear Networks are able to execute themselves an unlimited number of blocks, as long as enough gas for execution is kept available. The gas reservation option allows you to ensure this. As a result the need for including centralized components in dApps is eliminated, allowing them to function totally on-chain.\n\nmsg::send_delayed function allows sending a message after a specified delay. The function takes the following parameters:\n\n* program - the program (or user) to which the message will be sent\n\n* payload - the payload of the message\n\n* value - the amount of tokens to be sent with the message\n\n* delay - the delay in blocks after which the message will be sent\n\nThe delayed message will be executed after the specified delay measured in blocks. For example, on a network with a block producing time of 3 seconds, a delay of 20 is equal to 1 minute.\n\nWe can make the message processing to be paid with the reserved gas by using the msg::send_delayed_from_reservation function which takes a reservation ID as the first parameter.\n\nConsidering the example with auction, we can start the auction by sending a message to the auction contract. After completing all the necessary logic, the auction contract will send a delayed message to itself, which will settle the auction after the indicated time."}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"When a program or user sends a reply to a message, it should provide gas for the reply handling. The user replies using gear.sendReply extrinsic. The program uses the msg::replywithgas function.","lang":"en","canonicalLink":"https://wiki.gear-tech.io/docs/developing-contracts/reply-deposit","tags":[],"image":"https://wiki.gear-tech.io/img/ogimage.jpg","videos":[],"links":[{"text":"gear.sendReply","href":"https://docs.gear.rs/pallet_gear/pallet/struct.Pallet.html#method.send_reply"},{"text":"msg::reply","href":"https://docs.gear.rs/gstd/msg/fn.reply.html"},{"text":"msg::reply_with_gas","href":"https://docs.gear.rs/gstd/msg/fn.reply_with_gas.html"},{"text":"exec::reply_deposit","href":"https://docs.gear.rs/gstd/exec/fn.reply_deposit.html"},{"text":"msg::send_for_reply","href":"https://docs.gear.rs/gstd/msg/fn.send_for_reply.html"}],"text":"When a program or user sends a reply to a message, it should provide gas for the reply handling. The user replies using gear.sendReply extrinsic. The program uses the msg::reply or msg::reply_with_gas function.\n\nSometimes, it is more convenient to provide gas for the reply handling in advance. For example, if the program sends a message to another program and waits for a reply, it can provide gas for the reply handling in advance. In this case, the program doesn't need to provide gas for the reply handling when it sends a reply.\n\nTo provide gas for the reply handling in advance, the program should use the exec::reply_deposit function:\n\nThe program can deposit gas when using the msg::send_for_reply function by setting the reply_deposit parameter. The reply_deposit parameter is the amount of gas that will be reserved for the reply handling. The reply_deposit parameter is optional. If the reply_deposit parameter is zero, the program should provide gas for the reply handling when it sends a reply."}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"This guide provides a general overview of running smart contracts on the networks powered by Gear Protocol (such as the Vara Network). It guides you through how to write a smart contract, compile it to Wasm and deploy it to the Gear network.","lang":"en","canonicalLink":"https://wiki.gear-tech.io/docs/getting-started-in-5-minutes","tags":[],"image":"https://wiki.gear-tech.io/img/ogimage.jpg","videos":[],"links":[{"text":"Vara Network","href":"https://vara-network.io/"},{"text":"Gear Academy&apos;s","href":"https://academy.gear.foundation/"},{"text":"Gear Smart Contract Developer","href":"https://academy.gear.foundation/course/tamagotchi"},{"text":"Rustup","href":"https://rustup.rs/"},{"text":"Build Tools for Visual Studio","href":"https://visualstudio.microsoft.com/downloads/?q=build+tools"},{"text":"idea.gear-tech.io","href":"https://idea.gear-tech.io"},{"text":"https://polkadot.js.org/extension/","href":"https://polkadot.js.org/extension/"},{"text":"idea.gear-tech.io","href":"https://idea.gear-tech.io"},{"text":"this article on Smart Contracts","href":"/docs/developing-contracts/introduction"}],"text":"This guide provides a general overview of running smart contracts on the networks powered by Gear Protocol (such as the Vara Network). It guides you through how to write a smart contract, compile it to Wasm and deploy it to the Gear network.\n\nAttention developers! Want to take your blockchain development skills to the next level? Join Gear Academy's free course, \"Gear Smart Contract Developer.\" In this comprehensive course, you'll learn the ins and outs of developing on the Gear Protocol, from deploying programs onto the blockchain and interacting with them, to testing your programs on the Gear Network. You'll also gain hands-on experience navigating the @gear-js library for interacting with contracts on the client side and developing real-world applications, including contracts and frontends. Don't miss this opportunity to become a pro Gear blockchain developer. Enroll now in Gear Academy's \"Gear Smart Contract Developer\" course!\n\nLinux users should generally install GCC and Clang, according to their distribution’s documentation.\n\nFor example, on Ubuntu use:\n\nOn macOS, you can get a compiler toolset by running:\n\nMake sure you have installed all the tools required to build a smart-contract in Rust. Rustup will be used to get Rust compiler ready:\n\nNow, let's install a nightly version of the toolchain with rustup, since Gear uses the most up-to-date features rustup provides. We use nightly-2023-09-18 as it is the latest version that is compatible with Gear.\n\nAs we will be compiling our Rust smart contract to Wasm, we will need a Wasm compiler. Let's add it to the toolchain.\n\nAlso, you need to install the wasm-proc utility that optimizes compiled Wasm to be more compact.\n\nNote: If you use Windows, download and install Build Tools for Visual Studio.\n\nFor your convenience, it is recommended that you create a dedicated directory for everything Gear-related. The rest of the article will assume that you are using the paths suggested. Type to create a folder in your home directory:\n\nThe next step would be to build a Rust library for our contract:\n\nNow, your gear/contracts directory tree should look like this:\n\nIt's time to write some code. Open counter with your favorite editor. For VS Code editor type:\n\nIn the counter folder, configure Cargo.toml for our contract to be properly built:\n\nReplace the default contents of lib.rs in the counter folder with the code for our first smart-contract.\n\nThis simple smart-contract accepts inc, dec, and get commands. Open src/lib.rs in your editor and paste the following code:\n\n#![no_std]use gstd::{msg, prelude::*};static mut COUNTER: i32 = 0;#[no_mangle]extern \"C\" fn handle() {    let command = msg::load_bytes().expect(\"Invalid message\");    let mut counter = unsafe { COUNTER };    match command.as_slice() {        b\"inc\" => counter += 1,        b\"dec\" => counter -= 1,        b\"get\" => {            msg::reply_bytes(format!(\"{counter}\"), 0).expect(\"Unable to reply\");        }        _ => (),    }    unsafe { COUNTER = counter };}\n\nNow compile the smart-contract to Wasm using cargo:\n\nThis command is quite verbose, so we can create cargo config and Rust toolchain override files to make it shorter. Create a .cargo/config.toml file in the counter directory with the following contents:\n\nAnd create a rust-toolchain.toml file in the counter directory with the following contents:\n\nNow you can build your smart-contract with a single command:\n\nIf everything goes well, your working directory should now have a target directory that looks like this:\n\nThe last preparation step is to optimize the Wasm binary using wasm-proc:\n\nA new Wasm file will be created:\n\nNow the target/wasm32-unknown-unknown/release directory contains two required Wasm binaries:\n\ncounter.wasm is the output Wasm binary built from source files\n\ncounter.opt.wasm is the optimized Wasm aimed to be uploaded to the blockchain\n\nGear provides a demo application that implements all of the possibilities of interaction with smart-contracts in Gear networks, available at idea.gear-tech.io.\n\nDownload the Polkadot extension for your browser via https://polkadot.js.org/extension/. This extension manages accounts and allows the signing of transactions with those accounts. It is a secure tool that allows injecting your accounts into any Substrate-based dapp. It does not perform wallet functions, e.g send funds.\n\nMake sure you save your 12-word mnemonic seed securely.\n\nSelect the network that will be used for this account - choose \"Allow to use on any chain\". Provide any name to this account and password and click \"Add the account with the generated seed\" to complete account registration.\n\nGo to idea.gear-tech.io. You will be prompted to grant access to your account for Gear Tech application, click \"Yes, allow this application access\".\n\nMake sure you are connected to the Vara Network Testnet. The network name is on the bottom left corner of the page.\n\nYou may switch the network by clicking on the network name.\n\nClick the Connect button on the top-right to select an account that will be connected to Gear Tech.\n\nIn accordance with the Actor model, smart contracts are uploaded to a network via messages. Gear node charges a gas fee during message processing. Your account balance needs to have enough funds to upload a smart-contract to the TestNet. Click the following button to get the test balance:\n\nA notification about successful balance replenishment will appear after passing captcha at the bottom of the window. You can also see the current account balance next to the account name in the upper right corner.\n\nWhen your account balance is sufficient, click the  and navigate to the .opt.wasm file we have pointed to above.\n\nSpecify the program Name and click  button. The Gas limit will be set automatically. Now click the  button.\n\nSign the program uploading the transaction to the Gear network. Also, sign the program and metadata upload to the Gear demo environment so you could work with the program. It is recommended to set the checkbox Remember my password for the next 15 minutes for your convenience.\n\nOnce your program is uploaded, head to the Programs section and find your program.\n\nNow, try sending your newly uploaded program a message to see how it responds! Click the  button.\n\nIn the Payload field of the opened dialog type 0x696E63 (this is inc encoded in hex). Click  button, the Gas limit will be set automatically. Now click the  button.\n\nSign the message sending transaction as it is shown in step 3 of the section Upload Program.\n\nAfter your message has been successfully processed, you are to see correspondent log messages:\n\nNow you have sent an increment command to the program. After processing the counter will be incremented to 1.\n\nRepeat step 2 with 0x676574 payload (this is get command). This will send a get command to the program.\n\nPress the  button to enter the mailbox and find the reply.\n\nThe reply is in the mailbox for a limited time depending on the gas limit. If you don't see the reply, try resending the 0x676574 (get) message with the gas limit increasing and go to the mailbox immediately after sending the message.\n\nFor more info about writing smart contracts for Gear and the specifics behind the smart contract implementation, refer to this article on Smart Contracts."}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"Following the principles of Actor model for communication, uploading a program in the network is just one of the specific types of transactions that contain a Wasm file as a payload.","lang":"en","canonicalLink":"https://wiki.gear-tech.io/docs/developing-contracts/deploy","tags":[],"image":"https://wiki.gear-tech.io/img/ogimage.jpg","videos":[],"links":[{"text":"here","href":"/docs/api/events#gear-events-types"},{"text":"idea.gear-tech.io","href":"https://idea.gear-tech.io"},{"text":"Gear API","href":"/docs/api/getting-started"},{"text":"gear-program GitHub repo","href":"https://github.com/gear-tech/gear-program"}],"text":"Following the principles of Actor model for communication, uploading a program in the network is just one of the specific types of transactions that contain a Wasm file as a payload.\n\nUploading a new program (smart-contract) to the blockchain takes place by calling the custom extrinsic gear.uploadProgram(code, salt, initPayload, gasLimit, value). Where:\n\n* salt: Bytes - the random data that is added to the hashing process to force their uniqueness\n\n* initPayload: Bytes- the init message payload that will be processed by the init() function during program initialization\n\n* gasLimit: u64 - the amount of gas that users are willing to spend on processing the upload of a new program\n\n* value: u128 - the value that will be transferred to a balance of the newly created account for the program\n\nNote: while extrinsics represent information from the outside world, events represent information from the chain. Extrinsics can trigger events.\n\nThe extrinsic that was called to upload a program triggers a series of events. Learn more about events here.\n\nThere are several ways to upload a program:\n\nThe easiest way to upload the program is to use the “Upload program” option in the Gear Idea portal - idea.gear-tech.io.\n\nThe Gear-js library provides a simple and intuitive way to connect Gear Component APIs, including interaction with programs. More details: Gear API.\n\ngear-program is the command line (CLI) utility for interacting with the blockchain network. Refer to gear-program GitHub repo for details."}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"gtest simulates a real network by providing mockups of the user, program, balances, mailbox, etc. Since it does not include parts of the actual blockchain, it is fast and lightweight. But being a model of the blockchain network, gtest cannot be a complete reflection of the latter.","lang":"en","canonicalLink":"https://wiki.gear-tech.io/docs/developing-contracts/testing-gtest","tags":[],"image":"https://wiki.gear-tech.io/img/ogimage.jpg","videos":[],"links":[],"text":"gtest simulates a real network by providing mockups of the user, program, balances, mailbox, etc. Since it does not include parts of the actual blockchain, it is fast and lightweight. But being a model of the blockchain network, gtest cannot be a complete reflection of the latter.\n\nAs we said earlier, gtest is excellent for unit and integration testing. It is also helpful for debugging Gear program logic. Nothing other than the Rust compiler is required for running tests based on gtest. It is predictable and robust when used in continuous integration.\n\nTo use the gtest library, you must import it into your Cargo.toml file in the [dev-dependencies] block to fetch and compile it for tests only:\n\n* Initialization of the common environment for running smart contracts:\n\n* Getting the program from the system:\n\n* Processing the result of the program execution:"}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"gclient is intended to be used as a tool for testing Gear programs with a real blockchain network. It allows you to send extrinsics and RPCs by connecting to the network. We recommend using gclient for end-to-end testing to ensure the program works as expected in the real blockchain world.","lang":"en","canonicalLink":"https://wiki.gear-tech.io/docs/developing-contracts/testing-gclient","tags":[],"image":"https://wiki.gear-tech.io/img/ogimage.jpg","videos":[],"links":[{"text":"https://get.gear.rs","href":"https://get.gear.rs"},{"text":"previous section","href":"/docs/developing-contracts/testing#building-a-program-in-test-mode"},{"text":"Getting Started","href":"/docs/getting-started-in-5-minutes#creating-your-first-gear-smart-contract"},{"text":"gclient docs","href":"https://docs.gear.rs/gclient/"}],"text":"gclient is intended to be used as a tool for testing Gear programs with a real blockchain network. It allows you to send extrinsics and RPCs by connecting to the network. We recommend using gclient for end-to-end testing to ensure the program works as expected in the real blockchain world.\n\nIt is essential to underline that testing with gclient requires the running node as the second part of the test suite. The gclient interacts with the node over the WebSocket protocol. Depending on the purpose of testing, gclient can communicate with either a local or a remote node. The best choice is to use the local node in developer mode for initial debugging and continuous integration.\n\nTesting with gclient is slower than gtest and produces more build artifacts, so it is better suited as the last mile in quality control. However, gclient gives the most accurate test results.\n\nTo use the gclient library, you must import it into your Cargo.toml file in the [dev-dependencies] block. Also, you need to add some external crates that are used together with gclient:\n\nThe best way is to download the latest node binary for your operating system from https://get.gear.rs. Then unpack the package and run the node. Here and below, we assume the node is running in developer mode.\n\nOpen the second terminal window and run tests using cargo as it was described in the previous section.\n\nLet's add an end-to-end test to our first-gear-app introduced in the Getting Started section.\n\nAdd the tests directory next to the src directory and create the end2end.rs file in it.\n\nRun the following command and wait for all tests to be green:\n\nIt's recommended to mark with the #[ignore] attribute tests with gclient to separate their slow execution from the rest. To execute ignored tests with Cargo, add the --include-ignored flag after a double dash (--) as shown above.\n\nLet's explore what we've done in the test function above.\n\nFirstly, we instantiate the API that allows interaction with the node by calling correspondent extrinsics. Then we create an event listener, as getting the feedback from the node is possible only by subscribing to events. We use the API instance both for invoking RPC calls (e.g., calculating the gas amount needed for processing) and sending extrinsics (e.g., uploading the program and sending a message). Events listener allows us to get the result of operation.\n\nPlease refer to the gclient docs for more information about its capabilities and use cases."}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"Key information and security","lang":"en","canonicalLink":"https://wiki.gear-tech.io/docs/idea/account/create-account","tags":[],"image":"https://wiki.gear-tech.io/img/ogimage.jpg","videos":[],"links":[{"text":"more","href":"https://docs.substrate.io/fundamentals/accounts-addresses-keys/"},{"text":"here","href":"https://talisman.xyz/"},{"text":"link","href":"https://subwallet.app/download.html"},{"text":"Chromium","href":"https://chrome.google.com/webstore/detail/polkadot%7Bjs%7D-extension/mopnmbcafieddcagagdcbnhejhlodfdd?hl=en"},{"text":"FireFox","href":"https://addons.mozilla.org/en-US/firefox/addon/polkadot-js-extension"},{"text":"img alt","href":"/assets/files/create-account-1-61b6042e92671d253cec4ad9b1bd2aa4.png"},{"text":"<img loading=\"lazy\" alt=\"img alt\" src=\"/assets/images/nova-logo-29c7436881b084aafe66871f3813637f.png\" width=\"340\" height=\"108\" class=\"img_ev3q\">","href":"https://novawallet.io/"},{"text":"<img loading=\"lazy\" alt=\"img alt\" src=\"/assets/images/subwallet-logo-030772530670f3ff8f32615a1d09fd11.png\" width=\"356\" height=\"120\" class=\"img_ev3q\">","href":"https://subwallet.app/"},{"text":"here","href":"https://wiki.polkadot.network/docs/build-wallets"},{"text":"Gear Idea","href":"https://idea.gear-tech.io"}],"text":"Account represents an identity - typically a person or an organization, that is capable of making transactions or holding funds. Users can upload smart-contracts and interact with them through transactions in blockchain networks built on top of Gear Protocol. To make this happen, users need to connect a Substrate account. Gear Idea portal can work with Substrate accounts in any connected Gear-powered networks. Moreover this account can be used for holding funds and making transactions in any network of the Dotsama ecosystem and even more.\n\nThere are several ways to create a Substrate account, depending on whether you are using a desktop or a mobile device.\n\nThere are two main features that make up an account - an address and a key:\n\n* An address is the public aspect of the account. This is essentially a location that can be shared with others in order to send transactions to and from.\n\n* A key is the private part of the account. This is what enables you as an account owner to access the address. The only way to access your account is via your private key (using the mnemonic phrase, seed, or your account's JSON file and a password).\n\nTalisman is a popular and user-friendly wallet for creating and managing Substrate accounts. Being connected to web3 applications across various networks, Talisman browser extension allows to store, send and receive assets.\n\nOpen the extension by clicking on the logo in the menu bar.\n\nAnd that's it. Your wallet has been created:\n\nSubwallet is another advanced wallet for managing Substrate as well as EVM accounts.\n\nOpen Subwallet by clicking on its logo in the browser menu bar.\n\nSelect the type of account you want to create (Subwallet allows you to create Substrate-like and Ethereum accounts at once). Copy your seed phrase and keep it in the same place:\n\nProvide your password in the next step. And click \"Add the account with the generated seed\"\n\nCongratulations, your wallet has been successfully created!\n\nThe polkadot.js browser extension is the original application created by Parity Technologies for managing Substate accounts. This method involves installing the polkadot.js plugin and using it as a \"virtual vault\" that's separate from your browser to store your private keys and sign transactions.\n\nYou can install the extension via the following links.\n\nOpen the extension by clicking on the logo in the menu bar\n\nClick the large plus button to create a new account. Alternatively, you can navigate to the smaller plus icon in the top right and select \"Create New Account\".\n\nSave the seed phrase in a safe place using the security advices at the beginning of this article.\n\nSpecify the name of your account and a strong password for making transactions. Click \"Add the account with the generated seed\".\n\nYou've now successfully created a new account using the polkadot.js browser extension.\n\nIf you need access to your accounts on a mobile device, then you can use the following mobile wallets for the Polkadot/Kusama ecosystem:\n\nAll supported wallets you can check here.\n\nIf you have Gear node installed, you can generate a new seed phrase using the command:\n\nAnd then import the generated seed phrase into any convenient wallet.\n\nYes, you can access your account on a different device or wallet of your choice as long as you have the account's seed phrase or JSON file associated with the account.\n\nThere isn't functionality to make transactions directly in the polkadot.js browser extension. To make transactions, you need to launch Gear Idea on your browser. Before you can make any transactions, you have to allow Gear Idea to access your account. The browser extension is what holds your account information. You choose which websites get to access this information."}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"Decentralized Applications, or dApps, are applications that offer similar functionality to traditional applications but the main difference is that they are run on decentralized peer-to-peer networks, such as blockchains. Decentralized applications offer the services that make up the Web3 revolution.","lang":"en","canonicalLink":"https://wiki.gear-tech.io/docs/general/dApps","tags":[],"image":"https://wiki.gear-tech.io/img/ogimage.jpg","videos":[],"links":[],"text":"Decentralized Applications, or dApps, are applications that offer similar functionality to traditional applications but the main difference is that they are run on decentralized peer-to-peer networks, such as blockchains. Decentralized applications offer the services that make up the Web3 revolution.\n\nBecause dApps are decentralized, there isn’t a single entity that has control over the application. Instead these applications are open-source and their data is publicly available. DApps use cryptographic tokens to help keep the network secure and they are totally permissionless, which means that anyone, anywhere can interact with them.\n\nWhat makes dApps so innovative apart from their inclusive nature and exceptionally low barrier to entry is that they are censorship-resistant. This means that because there is no single point of failure, it’s very difficult to restrict access to a decentralized application. This lack of a single point of failure also means that dApps are very difficult to attack and that there is often zero downtime.\n\nIn most cases, to interact with a dApp, users must possess that application's native cryptocurrency."}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"DAOs are an effective and safe way to work with like-minded people around the globe. Essentially, they’re safe ways to collaborate with strangers and commit funds to a specific cause. You can think of DAOs as magic internet organizations that’re collectively owned and managed by its members.","lang":"en","canonicalLink":"https://wiki.gear-tech.io/docs/general/dao","tags":[],"image":"https://wiki.gear-tech.io/img/ogimage.jpg","videos":[],"links":[],"text":"DAOs are an effective and safe way to work with like-minded people around the globe. Essentially, they’re safe ways to collaborate with strangers and commit funds to a specific cause. You can think of DAOs as magic internet organizations that’re collectively owned and managed by its members.\n\nThe backbone of a DAO is the smart contract. The contract defines the rules of the organisation and holds the group's treasury. Once the contract is live, no one can change the rules except by a vote. If anyone tries to do something that's not covered by the rules and logic in the code, it will fail.\n\nThis means that DAOs don't need a central authority, which is their biggest superpower. Instead, the group makes decisions collectively via votes and the execution of those votes are authorised automatically when a vote passes. This means that there is no need for human handling and that error and that fraudulent or malicious manipulation is severely minimised.\n\nDAOs differ from traditional organisations in many ways, but the most noticeable is that they’re usually flat and fully democratised instead of hierarchical. This is different from traditional organisations because they usually have a sole decision maker. DAOs are also fully transparent and public instead of private with certain information limited to executives and managers.\n\nThe concept of DAOs are extremely exciting as they promise to revolutionize organizational structure as we know it. DAOs solve almost everything that’s wrong with how modern day organisations are run. A perfectly structured DAO gives every member the opportunity to shape the organisation, which can help shape an entire industry."}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"Hooks allow functional components to have access to programs running on Gear networks and significantly simplify the development of front-end applications.","lang":"en","canonicalLink":"https://wiki.gear-tech.io/docs/api/tooling/react-hooks","tags":[],"image":"https://wiki.gear-tech.io/img/ogimage.jpg","videos":[],"links":[{"text":"this article","href":"/docs/examples/NFTs/nft-marketplace/nft-application"},{"text":"NFT smart contract","href":"/docs/examples/Standards/gnft-721"}],"text":"Hooks allow functional components to have access to programs running on Gear networks and significantly simplify the development of front-end applications.\n\nFor example, refer to this article that demonstrates the creation of a React application that connects to an NFT smart contract running on the blockchain.\n\nSimple as it is, here's a quick example:\n\nuseApi provides access to the Gear API connected to the selected RPC-node.\n\nuseAccount provides interaction with Polkadot-js extension API, allows to manage accounts from it (for example to sign transactions).\n\nuseAlert shows any alert in the application context.\n\nThis hook is auxiliary and it is not pre-installed in the react-hook library. useMetadata allows converting the program's metadata (.txt file) into the required format.\n\nThis hook is auxiliary and it is not pre-installed in the react-hook library. useWasmMetadata allows getting Buffer array from the program meta.wasm. Buffer is required always when using custom functions to query specific parts of the program State.\n\nuseSendMessage allows sending messages to the program.\n\nuseCreateHandler provides a tool for uploading the Gear program to the chain."}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"真正的去中心化","lang":"zh","canonicalLink":"https://wiki.gear-tech.io/zh-cn/docs/gear/distinctive-features","tags":[],"image":"https://wiki.gear-tech.io/zh-cn/img/ogimage.jpg","videos":[],"links":[],"text":""}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"需要监控每个 Gear 节点和整个网络的健康状况，以确保真正的去中心化和稳健的运营。这包括各种块生成指标以及在 PoS 网络中至关重要的节点正常运行时间。","lang":"zh","canonicalLink":"https://wiki.gear-tech.io/zh-cn/docs/node/telemetry","tags":[],"image":"https://wiki.gear-tech.io/zh-cn/img/ogimage.jpg","videos":[],"links":[],"text":""}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"数据格式","lang":"zh","canonicalLink":"https://wiki.gear-tech.io/zh-cn/docs/node/backup-restore","tags":[],"image":"https://wiki.gear-tech.io/zh-cn/img/ogimage.jpg","videos":[],"links":[],"text":""}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"Gear-JS API","lang":"en","canonicalLink":"https://wiki.gear-tech.io/docs/api/getting-started","tags":[],"image":"https://wiki.gear-tech.io/img/ogimage.jpg","videos":[],"links":[{"text":"GitHub","href":"https://github.com/gear-tech/gear-js"},{"text":"Polkadot documentation portal","href":"https://polkadot.js.org/docs/"},{"text":"article","href":"/docs/examples/NFTs/nft-marketplace/nft-application"},{"text":"NFT smart contract","href":"/docs/examples/Standards/gnft-721"}],"text":"The Gear-JS API provides a set of utilities, libraries and tools that enable JavaScript applications to interact with smart contracts running in the Gear network via queries to a Gear node.\n\nSections below describe tools that you can use in your JS application to implement basic functions such as managing your key pair (account), calculating gas required for network operations, uploading program in the network, sending a message to a program, reading program's state, getting messages from the user's mailbox, working with metadata and more. Some useful code snippets are provided in the Cookbook section.\n\nThe basic API is implemented on the Substrate layer and is the same for all Substrate-based networks. The Gear-JS API code is available on GitHub. Complete API overview can be found on the Polkadot documentation portal.\n\nStart the API connection to the local running RPC node:\n\nYou can also connect to a different node:\n\nThis simple example describes how to subscribe to a new blocks and get chain spec:\n\nAlso, refer to the article that demonstrates the creation of a React application that connects to an NFT smart contract running on the blockchain."}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"现在可以运行节点吗？","lang":"zh","canonicalLink":"https://wiki.gear-tech.io/zh-cn/docs/node/node-faq","tags":[],"image":"https://wiki.gear-tech.io/zh-cn/img/ogimage.jpg","videos":[],"links":[],"text":""}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"Keyring 使你能够管理你的密钥对（账户），以执行各种的操作，包括签署、验证和加密/解密。私钥永远不会暴露在外部。","lang":"zh","canonicalLink":"https://wiki.gear-tech.io/zh-cn/docs/api/keyring","tags":[],"image":"https://wiki.gear-tech.io/zh-cn/img/ogimage.jpg","videos":[],"links":[],"text":""}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"编译为 Wasm 的智能合约可以作为程序上传到 Gear 网络。在上传期间，它在网络中被初始化，以便能够与网络中的其他参与者（程序和用户）发送和接收消息。","lang":"zh","canonicalLink":"https://wiki.gear-tech.io/zh-cn/docs/api/upload-program","tags":[],"image":"https://wiki.gear-tech.io/zh-cn/img/ogimage.jpg","videos":[],"links":[],"text":""}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"To pay program rent, use the following JavaScript code:","lang":"zh","canonicalLink":"https://wiki.gear-tech.io/zh-cn/docs/api/program-rent","tags":[],"image":"https://wiki.gear-tech.io/zh-cn/img/ogimage.jpg","videos":[],"links":[],"text":""}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"向程序发送消息：","lang":"zh","canonicalLink":"https://wiki.gear-tech.io/zh-cn/docs/api/send-message","tags":[],"image":"https://wiki.gear-tech.io/zh-cn/img/ogimage.jpg","videos":[],"links":[],"text":""}

{"title":"Basics & Metadata / Type creation","softTitle":"Basics & Metadata / Type creation","date":null,"author":[],"publisher":null,"copyright":null,"description":"元数据实现了客户端（JavaScript 应用程序）和智能合约（Rust 程序）之间的交互。元数据是一种接口映射，可以将一组字节码识别为可理解的结构，并将其排序，并展示出它所要实现的功能。","lang":"zh","canonicalLink":"https://wiki.gear-tech.io/zh-cn/docs/api/metadata-type-creation","tags":[],"image":"https://wiki.gear-tech.io/zh-cn/img/ogimage.jpg","videos":[],"links":[],"text":""}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"这里收集了一组以问答形式出现的有用的代码片段。","lang":"zh","canonicalLink":"https://wiki.gear-tech.io/zh-cn/docs/api/extra-queries","tags":[],"image":"https://wiki.gear-tech.io/zh-cn/img/ogimage.jpg","videos":[],"links":[],"text":""}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"\"Create-Gear-App\" 是一个现成的应用程序模板，是一个周密的基础设施，用于在 Gear 区块链上快速启动应用程序。","lang":"zh","canonicalLink":"https://wiki.gear-tech.io/zh-cn/docs/api/tooling/create-gear-app","tags":[],"image":"https://wiki.gear-tech.io/zh-cn/img/ogimage.jpg","videos":[],"links":[],"text":""}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"Gear Protocol 的库gstd为开发智能合约提供了所有必要和完善的功能和方法。","lang":"zh","canonicalLink":"https://wiki.gear-tech.io/zh-cn/docs/developing-contracts/gstd","tags":[],"image":"https://wiki.gear-tech.io/zh-cn/img/ogimage.jpg","videos":[],"links":[],"text":""}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"Gear 智能合约的持久化数据的存储方式与传统程序相同，不需要初始化外部存储。","lang":"zh","canonicalLink":"https://wiki.gear-tech.io/zh-cn/docs/developing-contracts/state","tags":[],"image":"https://wiki.gear-tech.io/zh-cn/img/ogimage.jpg","videos":[],"links":[],"text":""}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"Global aspect","lang":"en","canonicalLink":"https://wiki.gear-tech.io/docs/gear/why","tags":[],"image":"https://wiki.gear-tech.io/img/ogimage.jpg","videos":[],"links":[{"text":"parachain auction","href":"https://parachains.info/auctions"},{"text":"Gear Whitepaper","href":"https://whitepaper.gear.foundation"}],"text":"Blockchain technology launched a rapid transition from a centralized, server-based internet (Web2) to a decentralized, distributed one (Web3). Its distinctive features are: no single point of failure (the network can still function even if a large proportion of participants are attacked/taken out), censorship resistance, anyone in the network has the possibility to use the service (permissionless).\n\nWeb3 introduces new types of decentralized applications (dApps) and assets such as: decentralized finances (DeFi), decentralized currency exchanges (DEX), decentralized marketplaces and gaming platforms, NFTs, Social Tokens and more.\n\nToday the industry is still in its infancy, which presents the opportunity for rapid growth. What's more, with the demand for Web3 developers currently at its all time high, adoption seems to be growing faster than ever.\n\nGear was built for the purpose of becoming an essential platform for building the Web3 ecosystem.\n\nAt their core, blockchains store a history of transactions between parties in a form that can be accessible by anybody. They ensure decentralized, immutable and permissionless access to data in the blockchain.\n\nNetworks that were at the dawn of blockchain technology have a number of significant issues:\n\n* Lack of scalability, low transaction speed, high transaction costs - all of it hinders the growth of applications in Web3\n\n* Domain-specific development languages lead to high barriers to entry. The need to learn new programming language and paradigms holds back the growth of developers entering Web3\n\nThe solution has been found in Parity Technologies, which is focused on creating a Layer-0 technology that connects blockchains together into one big network - Polkadot.\n\nPolkadot provides a system in which blockchains coexist and complement each other. Different parallel blockchains (parachains) are built on Substrate as well as Polkadot and connected to the relay chain and have a native connection. This allows for different nodes to run different application logic, keeping each chain on its own platform. All parachains are interconnected, creating a massive network of multifunctional blockchain services. Parachains compose the Layer-1 of the Polkadot ecosystem, the main difference in connection with other standalone Layer-1 blockchain networks like Ethereum, Bitcoin, Solana, etc. is that parachains are connected through Substrate Cumulus library and standalone blockchains through bridges.\n\nPolkadot and its testnet Kusama are designed to be a fully extensible and scalable blockchain development, deployment and interaction test bed. It is built to be a largely future-proof harness able to assimilate new blockchain technology as it becomes available without over-complicated decentralized coordination or hard forks.\n\nToday Polkadot is one of the fastest-growing multi-chain networks. Although it has an adaptive architecture for building smart-contract platforms and rapid technology development for decentralized applications, it is not a smart contract platform by itself.\n\nBuilt on Substrate, Gear Protocol facilitates access to the deployment infrastructure of Layer-1 parachains or a standalone network. Gear simplifies the dApp deployment process thanks to Gear's technical development, software, and utility, which enable network participation and functionality for broader information access and technical support.\n\nThere are several components in the Polkadot architecture, namely:\n\nRelay Chain is the heart of Polkadot, responsible for the network’s security, consensus and cross-chain interoperability. It allows specialized blockchains and public blockchains to connect within the unified and interoperable Polkadot network. The Relay Chain can be understood as a Layer-0 platform.\n\nThe Relay Chain has minimal functionality, which naturally means that advanced functionality features, like smart contracts, for example, are not supported. Other specific work is delegated to the parachains, which each have different implementations and features.\n\nThe main task of the Relay Chain is to coordinate the overall system and its connected parachains to build a scalable and interoperable network.\n\nIt’s also the Relay Chain that is responsible for the network’s shared security, consensus and cross-chain interoperability.\n\nParachains are sovereign blockchains that can have their own tokens and optimize their functionality for specific use cases.\n\nParachains must be connected to the Relay Chain to ensure interoperability with other networks. For this, parachains lease a slot for continuous connectivity or they can pay as they go (in this case they are called Parathreads). Parachains compose the Layer-2 of the Polkadot ecosystem.\n\nParachains are validatable by validators of the Relay Chain and they get their name from the concept of parallelizable chains that run parallel to the main Relay Chain. Due to their parallel nature, they are able to parallelize transaction processing which helps improve the scalability of the Polkadot network.\n\nParachains optimize their functionality for specific use cases and, in many instances, support their own tokens.\n\nIn order to become a parachain on Polkadot and Kusama, projects have to participate in a parachain auction.\n\nA blockchain bridge is a special connection that allows the Polkadot ecosystem to connect to and communicate with external networks like Ethereum, Bitcoin and others. Such networks can be considered as Layer-1. A Bridge connection enables the transfer of tokens or arbitrary data from one blockchain to another.\n\nLike Polkadot, the Gear Protocol uses a Substrate framework. This simplifies the creation of different blockchains for specific applications. Substrate provides extensive functionality out-of-the-box and allows one to focus on creating a custom engine on top of the protocol. Projects building on Gear Protocol can seamlessly integrate their solutions into the whole Polkadot/Kusama ecosystem.\n\nThe central aspect of Polkadot is its ability to route arbitrary messages between chains. Both Polkadot and Gear networks speak the same language — asynchronous messages — so all the projects built using Gear easily integrate into the Polkadot and Kusama networks. The asynchronous messaging architecture allows Gear networks to be efficient and easy-to-use parachains.\n\nThe majority of developers and inspirers of the Gear Protocol were directly involved in creating Polkadot and Substrate technologies. Gear is developing, taking into account, the features of the architecture and design of its older brother. We rely on the high security and flexibility of our product, just like Polkadot.\n\nGear networks scale naturally as hardware improves as it utilizes all CPU cores. Anyone with a standard computer can run a Gear node today and always. With its shardable design, Gear networks can scale by deploying across multiple parachain slots and can be sharded as a standalone network for additional scalability.\n\nFor additional details, refer to the Gear Whitepaper."}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"元数据是一种接口映射，有助于将一组字节转换为可理解的结构，并展示出该结构的用途。元数据决定了所有传入和传出数据的编码/解码方式。","lang":"zh","canonicalLink":"https://wiki.gear-tech.io/zh-cn/docs/developing-contracts/metadata","tags":[],"image":"https://wiki.gear-tech.io/zh-cn/img/ogimage.jpg","videos":[],"links":[],"text":""}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"Gear 程序之间的异步交互与通常的异步请求类似，在使用await并通过发送消息来实现。","lang":"zh","canonicalLink":"https://wiki.gear-tech.io/zh-cn/docs/developing-contracts/interactions-between-programs","tags":[],"image":"https://wiki.gear-tech.io/zh-cn/img/ogimage.jpg","videos":[],"links":[],"text":""}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"Gas 预留是 Gear 协议的强大功能，它为智能合约编程和现代用例提供了新方法。","lang":"zh","canonicalLink":"https://wiki.gear-tech.io/zh-cn/docs/developing-contracts/gas-reservation","tags":[],"image":"https://wiki.gear-tech.io/zh-cn/img/ogimage.jpg","videos":[],"links":[],"text":""}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"Gear Protocol 的关键特性之一是使用 Actor 模型进行消息传递通信。Actor 模型框架支持异步消息传递和并行计算，这极大地提高了 dapp 的可实现速度和可伸缩性。在 Actor 模型中，程序不共享状态，而是通过消息相互通信。如果一个程序向另一个程序发送异步消息，它必须等待另一个程序的回复，然后才能继续进行下一个操作。","lang":"zh","canonicalLink":"https://wiki.gear-tech.io/zh-cn/docs/developing-contracts/distributed_transactions","tags":[],"image":"https://wiki.gear-tech.io/zh-cn/img/ogimage.jpg","videos":[],"links":[],"text":""}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"When a program or user sends a reply to a message, it should provide gas for the reply handling. The user replies using gear.sendReply extrinsic. The program uses the msg::replywithgas function.","lang":"zh","canonicalLink":"https://wiki.gear-tech.io/zh-cn/docs/developing-contracts/reply-deposit","tags":[],"image":"https://wiki.gear-tech.io/zh-cn/img/ogimage.jpg","videos":[],"links":[],"text":""}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"Gear gtest 库是程序（智能合约）逻辑测试的推荐选项。这篇文章介绍如何使用gtest来测试程序。","lang":"zh","canonicalLink":"https://wiki.gear-tech.io/zh-cn/docs/developing-contracts/testing","tags":[],"image":"https://wiki.gear-tech.io/zh-cn/img/ogimage.jpg","videos":[],"links":[],"text":""}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"gtest simulates a real network by providing mockups of the user, program, balances, mailbox, etc. Since it does not include parts of the actual blockchain, it is fast and lightweight. But being a model of the blockchain network, gtest cannot be a complete reflection of the latter.","lang":"zh","canonicalLink":"https://wiki.gear-tech.io/zh-cn/docs/developing-contracts/testing-gtest","tags":[],"image":"https://wiki.gear-tech.io/zh-cn/img/ogimage.jpg","videos":[],"links":[],"text":""}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"去中心化应用，或称 dApps，是指提供与传统应用类似的功能的应用，但主要区别在于它们是在去中心化的点对点网络上运行，如区块链。去中心化的应用程序提供构成 Web3 革命的服务。","lang":"zh","canonicalLink":"https://wiki.gear-tech.io/zh-cn/docs/general/dApps","tags":[],"image":"https://wiki.gear-tech.io/zh-cn/img/ogimage.jpg","videos":[],"links":[],"text":""}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"去中心化金融是一个金融服务的集合，是当前金融体系的替代方案。","lang":"zh","canonicalLink":"https://wiki.gear-tech.io/zh-cn/docs/general/defi","tags":[],"image":"https://wiki.gear-tech.io/zh-cn/img/ogimage.jpg","videos":[],"links":[],"text":""}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"DAO是与全球志同道合的人合作的一种有效和安全的方式。从本质上讲，它们是与陌生人合作并为某一特定事业投入资金的安全方式。你可以把 DAO 看作是由其成员集体拥有和管理的神奇互联网组织。","lang":"zh","canonicalLink":"https://wiki.gear-tech.io/zh-cn/docs/general/dao","tags":[],"image":"https://wiki.gear-tech.io/zh-cn/img/ogimage.jpg","videos":[],"links":[],"text":""}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"Web 3.0 is a new iteration of the internet that’s powered by new technologies like artificial intelligence, machine learning and most importantly, blockchain technology.","lang":"en","canonicalLink":"https://wiki.gear-tech.io/docs/general/web3","tags":[],"image":"https://wiki.gear-tech.io/img/ogimage.jpg","videos":[],"links":[],"text":"Web 3.0 is a new iteration of the internet that’s powered by new technologies like artificial intelligence, machine learning and most importantly, blockchain technology.\n\nWeb 3.0 aims to create a more open, connected and intelligent internet that is permissionless and open to everyone without monetizing personal data.\n\nWith Web3, anyone who is on the network has permission to use all Web3 services. There isn’t a central authority who can block or deny access. Because Web3 is entirely decentralized, there isn’t a single entity that owns or controls the network. Rather, the community are the ones who control the network. And because the infrastructure that powers Web3 is turing-complete, pretty much anything imaginable can get programmed as a decentralized application.\n\nOn top of that, most interactions and transactions that occur on Web3 will benefit in terms of security, speed and cost thanks to the unique nature of blockchain technology.\n\nThe value proposition is simple. The main advantage of Web3 is that it addresses the biggest problem that’s resulted from Web2 - the collection and monetization of personal data.\n\nWeb3 empowers the user and it creates a more efficient, secure and transparent Internet."}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"Hooks allow functional components to have access to programs running on Gear networks and significantly simplify the development of front-end applications.","lang":"zh","canonicalLink":"https://wiki.gear-tech.io/zh-cn/docs/api/tooling/react-hooks","tags":[],"image":"https://wiki.gear-tech.io/zh-cn/img/ogimage.jpg","videos":[],"links":[],"text":""}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"Gear Protocol 的另一个突出特点是持久性内存方法。它使开发更容易，消除了很多复杂性，并使协议内存管理与实际硬件和操作系统相匹配。","lang":"zh","canonicalLink":"https://wiki.gear-tech.io/zh-cn/docs/gear/technology/persist-memory","tags":[],"image":"https://wiki.gear-tech.io/zh-cn/img/ogimage.jpg","videos":[],"links":[],"text":""}

{"title":"","softTitle":"","date":null,"author":[],"publisher":null,"copyright":null,"lang":null,"canonicalLink":"/zh-cn/docs/node/node-as-service","tags":[],"image":null,"videos":[],"links":[],"text":""}

{"title":"What is WebAssembly (Wasm)","softTitle":"What is WebAssembly (Wasm)","date":null,"author":[],"publisher":null,"copyright":null,"description":"WebAssembly is a way to run applications in programming languages other than JavaScript as web pages. Essentially, Wasm is just a virtual machine that runs on all modern browsers, but whereas in the past you were required to use JavaScript to run code in a web page, Wasm makes it possible to run code in browsers with programming languages other than JavaScript.","lang":"en","canonicalLink":"https://wiki.gear-tech.io/docs/gear/technology/WASM","tags":[],"image":"https://wiki.gear-tech.io/img/ogimage.jpg","videos":[],"links":[],"text":"WebAssembly is a way to run applications in programming languages other than JavaScript as web pages. Essentially, Wasm is just a virtual machine that runs on all modern browsers, but whereas in the past you were required to use JavaScript to run code in a web page, Wasm makes it possible to run code in browsers with programming languages other than JavaScript.\n\nThe WebAssembly Virtual Machine, or Wasm for short, is proven to be faster than any alternative virtual machine because of technology peculiarities. The use of WebAssembly enables Gear’s smart contracts to compile directly into machine code and run at near-native speeds. Higher speeds means lower transaction costs and higher efficiency.\n\nAll Gear programs and smart-contract are run as WebAssembly programs. This means for example, that developers can bring their applications to the web and achieve full performance with the apps’ full set of capabilities - that they’d typically have when running native on Windows or Mac - in a web browser. The developers won’t actually have to write the Wasm code directly either. Instead, they’d use Wasm as a compilation target for programs written in other languages.\n\nThe main problem that Wasm solves is the inability to use programming languages other than JavaScript on the web. Although JavaScript is a great programming language, it wasn’t designed to be super fast in large applications. What’s game changing about Wasm is that it brings the performance of native applications, written in other programming languages, to the web in a way that's completely secure.\n\nWasm should give significant speed increases in two main areas. First, it should significantly increase application start up speed. In fact, applications that are already using Wasm have been able to cut application start up time in half, and as more optimizations are made, it will only continue to increase startup speed further. This will allow huge applications to load up very, very quickly. Secondly, Wasm enables significant benefits in throughput too, which means that once code is compiled, it will run much faster - making applications more efficient and responsive which will significantly improve user experience.\n\nWebAssembly has the following advantages:\n\nWasm is extremely fast, efficient and portable. Code can be executed at near-native speed across different platforms.\n\nWasm is also readable and debuggable. Although WebAssembly is a low-level language, it does have a human-readable text format that allows code to be written, viewed and debugged by hand.\n\nIt’s also extremely secure as it’s run in a safe, sandboxed environment and like other web code, it will enforce the browsers same-origin and permissionless security policies.\n\nWasm format allows Gear Protocol’s developers write applications in Rust today along with C#/C++, Go, and Javascript in the future."}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"Another distinguished feature of the Gear Protocol is the Persistent memory approach. It is what makes development easier, removes a lot of complexity and makes protocol memory management match real-life hardware and operating systems.","lang":"en","canonicalLink":"https://wiki.gear-tech.io/docs/gear/technology/persist-memory","tags":[],"image":"https://wiki.gear-tech.io/img/ogimage.jpg","videos":[],"links":[],"text":"Another distinguished feature of the Gear Protocol is the Persistent memory approach. It is what makes development easier, removes a lot of complexity and makes protocol memory management match real-life hardware and operating systems.\n\nPrograms running in Gear Networks don’t use storage but rather their full state is persisted which ensures much less API surface for blockchain context. It avoids domain-specific language features as well as allows using much more complex language constructs — persisted boxed closures, futures compositors, etc.\n\nThe Gear Protocol uses clever memory virtualization techniques (despite vanilla Wasm does not), memory allocation and deallocation are first-class syscalls of the protocol. Memory access is also tracked and only required pages are loaded/stored. That allows heap-allocated stack frames of smart contracts stored in the blockchain’s state (typically found in futures and their compositors) to be seamlessly persisted and invoked when needed, preserving their state upon request.\n\nProgram code is stored as an immutable Wasm blob. Each program has a fixed amount of memory which persists between message-handling (so-called static area).\n\nGear instance holds individual memory space per program and guarantees its persistence. A program can read and write only within its own memory space and has no access to the memory space of other programs. Individual memory space is reserved for a program during its initialization and does not require an additional fee (it is included in the program's initialization fee).\n\nA program can allocate the required amount of memory in blocks of 64KB. Each memory block allocation requires a gas fee. Each page (64KB) is stored separately on the distributed database backend, but at the run time, Gear node constructs continuous runtime memory and allows programs to run on it without reloads.\n\nIndividual isolated memory space per program allows parallelization of message processing on a Gear node. Number of parallel processing streams equals the number of CPU cores. Each stream processes messages intended for a defined set of programs. It relates to messages sent from other programs or from outside (user’s transactions).\n\nFor example, given a message queue containing messages targeted to 100 different programs, Gear node runs on a network where 2 threads of processing are configured. Gear engine uses a runtime-defined number of streams (equal to number of CPU cores on a typical validator machine), divides total amount of targeted programs to number of streams and creates a message pool for each stream (50 programs per stream).\n\nPrograms are distributed to separate streams and each message appears in a stream where its targeted program is defined. So, all messages addressed to a particular program appear in a single processing stream.\n\nIn each cycle a targeted program can have more than one message and one stream processes messages for plenty of programs. The result of message processing is a set of new messages from each stream that is added to the message queue, then the cycle repeats. The resultant messages generated during message processing are usually sent to another address (return to origin or to the next program)."}

{"title":"","softTitle":"","date":null,"author":[],"publisher":null,"copyright":null,"lang":null,"canonicalLink":"/docs/node/node-as-service","tags":[],"image":null,"videos":[],"links":[],"text":""}

{"title":"","softTitle":"","date":null,"author":[],"publisher":null,"copyright":null,"lang":null,"canonicalLink":"/zh-cn/docs/api/calculate-gas","tags":[],"image":null,"videos":[],"links":[],"text":""}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"CLI 工具，对参数进行编码/解码，并对 .meta.wasm 文件进行处理。","lang":"zh","canonicalLink":"https://wiki.gear-tech.io/zh-cn/docs/api/tooling/meta-cli","tags":[],"image":"https://wiki.gear-tech.io/zh-cn/img/ogimage.jpg","videos":[],"links":[],"text":""}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"本指南提供了在 Gear 网络上运行智能合约的一般概述。它指导您如何编写智能合约，将其编译为 Wasm，并部署到 Gear 网络。","lang":"zh","canonicalLink":"https://wiki.gear-tech.io/zh-cn/docs/getting-started-in-5-minutes","tags":[],"image":"https://wiki.gear-tech.io/zh-cn/img/ogimage.jpg","videos":[],"links":[],"text":""}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"介绍","lang":"zh","canonicalLink":"https://wiki.gear-tech.io/zh-cn/docs/node/setting-up","tags":[],"image":"https://wiki.gear-tech.io/zh-cn/img/ogimage.jpg","videos":[],"links":[],"text":""}

{"title":"Gear Documentation Portal","softTitle":"Gear Documentation Portal","date":null,"author":[],"publisher":null,"copyright":null,"description":"Gear-JS API","lang":"zh","canonicalLink":"https://wiki.gear-tech.io/zh-cn/docs/api/getting-started","tags":[],"image":"https://wiki.gear-tech.io/zh-cn/img/ogimage.jpg","videos":[],"links":[],"text":""}

